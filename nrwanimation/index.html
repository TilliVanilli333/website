<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>NRW Kompetenzstufen Animation</title>
  <style>
    :root {
      /* Responsive font sizes with better mobile support */
      --number-font-size: clamp(14px, calc(3vw + 8px), 24px);
      --desc-font-size: clamp(10px, calc(2vw + 6px), 18px);
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 600px) {
      :root {
        --number-font-size: clamp(12px, 4vw, 18px);
        --desc-font-size: clamp(9px, 3vw, 14px);
      }
    }
    
    @media (max-width: 400px) {
      :root {
        --number-font-size: 12px;
        --desc-font-size: 9px;
      }
    }

    /* Ensure the canvas takes up the entire window without scrollbars */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* We leave the background transparent so the embedding page's
         own background shows through. */
      background-color: transparent;
      font-family: sans-serif;
      color: #8dd9ff;
    }

    /* Container for CSS2D objects (numbers and labels) */
    #labels {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0 20px;
      pointer-events: none; /* Let mouse interactions pass through */
    }

    .number-label {
      font-size: var(--number-font-size);
      font-weight: bold;
      color: #68cfff;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 50%;
      text-align: center;
      white-space: nowrap;
      line-height: 1;
      /* Make it circular */
      width: 45px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(104, 207, 255, 0.3);
      box-shadow: 0 0 10px rgba(104, 207, 255, 0.2);
    }
    
    @media (max-width: 600px) {
      .number-label {
        width: 38px;
        height: 38px;
      }
    }
    
    @media (max-width: 400px) {
      .number-label {
        width: 32px;
        height: 32px;
        border-width: 1px;
      }
    }

    .desc-label {
      font-size: var(--desc-font-size);
      color: #6fa8dc;
      background: rgba(0, 0, 0, 0.75);
      padding: 2px 5px;
      border-radius: 3px;
      margin-top: 5px;
      text-align: center;
      white-space: nowrap;
      line-height: 1.2;
    }
    
    /* Ensure label container centers the circular number */
    .label-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Hide description labels on very small screens */
    @media (max-width: 400px) {
      .desc-label {
        display: none;
      }
    }
    
    /* Alternating label positions for medium screens */
    @media (min-width: 401px) and (max-width: 768px) {
      .label-container:nth-child(even) {
        transform: translate(-50%, -70%);
      }
      .label-container:nth-child(odd) {
        transform: translate(-50%, -40%);
      }
    }
  </style>
</head>
<body>
  <div id="labels"></div>
  <!-- Base64 encoded textures for silhouettes are defined in this file -->
  <script src="base64_texture.js"></script>
  <!-- Include Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.152.0/three.min.js"></script>
  <script>
  (function() {
    // Basic error handler to surface runtime errors on the page.  If an error occurs
    // (for example, missing assets or syntax issues), a red banner will appear at
    // the top of the page with the error message so we can debug what went wrong.
    window.onerror = function(message, source, lineno, colno, error) {
      const div = document.createElement('div');
      div.style.position = 'fixed';
      div.style.top = '0';
      div.style.left = '0';
      div.style.width = '100%';
      div.style.background = '#c00';
      div.style.color = '#fff';
      div.style.padding = '5px';
      div.style.zIndex = '10000';
      div.textContent = 'Fehler: ' + message + ' at line ' + lineno;
      document.body.appendChild(div);
      return false;
    };
    const scene = new THREE.Scene();
    const group = new THREE.Group();
    scene.add(group);

    // Perspective camera with dynamic distance based on viewport
    function getCameraDistance() {
      const width = window.innerWidth;
      if (width < 600) {
        return 25;  // Closer on mobile
      } else if (width < 900) {
        return 28;
      } else if (width < 1200) {
        return 30;
      }
      return 35;  // Standard distance on desktop
    }
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, getCameraDistance());

    // WebGL renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    // Transparent clear color so underlying page background shows through
    renderer.setClearColor(0x000000, 0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    /**
     * Helper to create a glowing halo texture using a radial gradient.
     * This is used to accentuate each character with a soft neon glow.
     */
    function createHaloTexture(color) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      const rgb = new THREE.Color(color);
      const r = Math.floor(rgb.r * 255);
      const g = Math.floor(rgb.g * 255);
      const b = Math.floor(rgb.b * 255);
      gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
      gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    // Create halo texture (blueish) to match website color scheme
    const haloTexture = createHaloTexture(0x24c8ff);

    /**
     * Preload all silhouettes as textures.
     * Returns a promise that resolves when all textures are loaded.
     */
    function loadTextures(paths) {
      const loader = new THREE.TextureLoader();
      return Promise.all(paths.map(p => new Promise((resolve, reject) => {
        loader.load(p, tex => {
          tex.anisotropy = 4;
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          resolve(tex);
        }, undefined, err => reject(err));
      })));
    }

    /**
     * Flip a texture horizontally by drawing it onto an offscreen canvas
     * with a reversed X scale.  This is used to mirror certain sprites
     * (e.g. the children for stages C and D) so they face towards
     * the astronaut.  The returned texture inherits the same filter settings
     * as the original.
     * @param {THREE.Texture} texture
     * @returns {THREE.Texture}
     */
    function flipTextureHorizontally(texture) {
      const img = texture.image;
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      // Flip horizontally: move origin to the far right and scale X by -1
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0);
      const flipped = new THREE.CanvasTexture(canvas);
      flipped.anisotropy = texture.anisotropy;
      flipped.minFilter = texture.minFilter;
      flipped.magFilter = texture.magFilter;
      flipped.needsUpdate = true;
      return flipped;
    }

    // Character definitions: Data URI (from base64Textures), label, percentage, and scale factor
    // Heights are scaled up to match the broader slope, keeping the astronaut as
    // the dominant figure while the remaining stages decrease gradually.
    const characters = [
      { uri: base64Textures.astro, label: 'Kompetenzstufe A', value: '36%', height: 5.0 },
      { uri: base64Textures.girl, label: 'Kompetenzstufe B', value: '34%', height: 4.4 },
      { uri: base64Textures.boy_walk, label: 'Kompetenzstufe C', value: '20%', height: 3.8 },
      { uri: base64Textures.boy_lean, label: 'Kompetenzstufe D', value: '10%', height: 3.2 }
    ];

    // Dynamic positioning to use full content width
    function calculatePositions() {
      const width = window.innerWidth;
      
      // Calculate based on viewport to match content width
      let baseSpread;
      
      if (width < 400) {
        baseSpread = 7;   // Fixed smaller spread for very small screens
      } else if (width < 600) {
        baseSpread = 9;   // Mobile
      } else if (width < 900) {
        baseSpread = 11;  // Tablet
      } else if (width < 1200) {
        baseSpread = 13;  // Small desktop
      } else {
        baseSpread = 15;  // Large desktop
      }
      
      // Y-Positionen basierend auf tatsÃ¤chlichen Prozentwerten
      // Skalierung: 10% = -1.0, 36% = 1.0
      const scalePercent = (percent) => {
        return ((percent - 10) / 26) * 2 - 1;  // Normalisiert zwischen -1 und 1
      };
      
      return [
        new THREE.Vector3(-baseSpread, scalePercent(36), 0),      // Stage A (36%)
        new THREE.Vector3(-baseSpread/3, scalePercent(34), 0),    // Stage B (34%)
        new THREE.Vector3(baseSpread/3, scalePercent(20), 0),     // Stage C (20%)
        new THREE.Vector3(baseSpread, scalePercent(10), 0)        // Stage D (10%)
      ];
    }
    
    let positions = calculatePositions();

    // Scale vertical coordinates and character heights so the animation fills the container
    (function scaleToContainer() {
      const width = positions[positions.length - 1].x - positions[0].x;
      const heights = characters.map(c => c.height);
      const maxY = Math.max(...positions.map((p, i) => p.y + heights[i] / 2));
      const minY = Math.min(...positions.map((p, i) => p.y - heights[i] / 2));
      const height = maxY - minY;
      const aspect = window.innerWidth / window.innerHeight;
      const desiredHeight = width / aspect;
      const scale = desiredHeight / height;
      for (let i = 0; i < positions.length; i++) {
        positions[i].y *= scale;
        characters[i].height *= scale;
      }
    })();

    // Create slope segments as thin glowing rectangles to emulate the descending line
    function createSlope() {
      const material = new THREE.MeshBasicMaterial({ color: 0x24c8ff, transparent: true, opacity: 0.85 });
      // Create a smooth curve through all points
      const curve = new THREE.CatmullRomCurve3(positions);
      const tubularSegments = 64;
      // Increase radius slightly to make the connecting line more visible on small screens
      const radius = 0.3;
      const radialSegments = 8;
      const closed = false;
      const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, closed);
      const tube = new THREE.Mesh(tubeGeometry, material);
      tube.renderOrder = 1;
      group.add(tube);
      // Add glowing spheres at each node on the curve
      const sphereGeom = new THREE.SphereGeometry(radius * 1.4, 20, 20);
      const sphereMat = new THREE.MeshBasicMaterial({ color: 0x24c8ff, emissive: 0x24c8ff });
      positions.forEach(pos => {
        const s = new THREE.Mesh(sphereGeom, sphereMat);
        s.position.copy(pos);
        group.add(s);
      });
    }
    createSlope();

    // Store animated objects for updates
    const animatedSprites = [];
    const labelContainer = document.getElementById('labels');

    function project3DToScreen(position, camera, renderer) {
      const vector = position.clone().project(camera);
      return {
        x: (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth,
        y: (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight
      };
    }

    function updateLabelPositions() {
      const width = window.innerWidth;
      animatedSprites.forEach((sprite, index) => {
        const label = sprite.userData.domLabel;
        if (!label) return;
        const screenPos = project3DToScreen(sprite.position, camera, renderer);
        const rect = label.getBoundingClientRect();
        const halfWidth = rect.width / 2;
        const margin = 5;
        let clampedX = screenPos.x;
        
        // Prevent label cutoff at edges
        if (screenPos.x - halfWidth < margin) {
          clampedX = margin + halfWidth;
        } else if (screenPos.x + halfWidth > window.innerWidth - margin) {
          clampedX = window.innerWidth - margin - halfWidth;
        }
        
        // Adjust vertical offset based on screen size and alternating pattern
        let verticalOffset = 60;
        if (width < 600) {
          // Alternate labels up/down on mobile to prevent overlap
          verticalOffset = index % 2 === 0 ? 50 : 70;
        } else if (width < 900) {
          verticalOffset = index % 2 === 0 ? 55 : 65;
        }
        
        label.style.left = `${clampedX}px`;
        label.style.top = `${screenPos.y + verticalOffset}px`;
      });
    }

    function fitCameraToObject(camera, object, offset = 1.1) {
      object.updateMatrixWorld();
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const distanceY = size.y / (2 * Math.tan(fov / 2));
      const fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
      const distanceX = size.x / (2 * Math.tan(fovh / 2));
      
      // Use different offset based on viewport width
      const width = window.innerWidth;
      if (width < 600) {
        offset = 1.25;  // More offset on mobile to see everything
      } else if (width < 900) {
        offset = 1.2;
      } else {
        offset = 1.15;  // Less offset on desktop
      }
      
      const distance = Math.max(distanceX, distanceY) * offset;
      camera.position.set(center.x, center.y, Math.max(distance, getCameraDistance()));
      camera.lookAt(center);
    }

      function setLabelSizes() {
        // Responsive label sizing based on both width and height
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        if (width < 400) {
          // Very small mobile
          document.documentElement.style.setProperty('--number-font-size', '12px');
          document.documentElement.style.setProperty('--desc-font-size', '9px');
        } else if (width < 600) {
          // Mobile
          const numberSize = Math.min(height * 0.045, 16);
          const descSize = Math.min(height * 0.03, 12);
          document.documentElement.style.setProperty('--number-font-size', numberSize + 'px');
          document.documentElement.style.setProperty('--desc-font-size', descSize + 'px');
        } else if (width < 900) {
          // Tablet
          const numberSize = Math.min(height * 0.05, 20);
          const descSize = Math.min(height * 0.035, 15);
          document.documentElement.style.setProperty('--number-font-size', numberSize + 'px');
          document.documentElement.style.setProperty('--desc-font-size', descSize + 'px');
        } else {
          // Desktop
          const numberSize = Math.min(height * 0.06, 24);
          const descSize = Math.min(height * 0.04, 18);
          document.documentElement.style.setProperty('--number-font-size', numberSize + 'px');
          document.documentElement.style.setProperty('--desc-font-size', descSize + 'px');
        }
      }
    setLabelSizes();

    // Load textures and initialize sprites
    loadTextures(characters.map(c => c.uri)).then(textures => {
      for (let i = 0; i < characters.length; i++) {
        const char = characters[i];
        let texture = textures[i];
        // Flip the texture horizontally for stages C and D so the children face the astronaut
        if (i >= 2) {
          texture = flipTextureHorizontally(texture);
        }
        // Create halo sprite behind the character for glow
        // Halo to provide a subtle glow behind the silhouette
        const haloMaterial = new THREE.SpriteMaterial({ 
          map: haloTexture, 
          blending: THREE.AdditiveBlending, 
          transparent: true,
          opacity: 0.3  // Reduced opacity for subtler glow
        });
        // Do not write depth so glow is always visible
        haloMaterial.depthWrite = false;
        haloMaterial.depthTest = false;
        const halo = new THREE.Sprite(haloMaterial);
        halo.scale.set(char.height * 1.5, char.height * 1.5, 1);  // Smaller halo
        halo.position.copy(positions[i]);
        halo.position.z = 0.1; // halo sits just behind sprites
        halo.renderOrder = 2;
        group.add(halo);

        // Create the character sprite itself.  We tint it slightly to stand out against the dark background
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, color: 0x122c47 });
        // Disable depth testing/writing so the silhouettes always appear on top of the slope
        material.depthTest = false;
        material.depthWrite = false;
        const sprite = new THREE.Sprite(material);
        // Maintain aspect ratio when scaling
        const aspect = texture.image.width / texture.image.height;
        sprite.scale.set(char.height * aspect, char.height, 1);
        // We no longer flip the X scale here because we already flip the
        // texture for the last two characters using the helper function
        // flipTextureHorizontally().  Leaving the scale positive ensures
        // correct orientation.
        // Raise the sprite in front of the slope so it renders above
        const spritePos = positions[i].clone();
        spritePos.z = 0.3;
        sprite.position.copy(spritePos);
        sprite.renderOrder = 3;
        group.add(sprite);

        // Link halo and sprite for easy access in the animation loop
        sprite.userData.halo = halo;
        sprite.userData.basePosition = positions[i].clone();
        sprite.userData.scaleFactor = char.height;
        sprite.userData.index = i;
        animatedSprites.push(sprite);

        // Create DOM label for number and description.
        const lbl = document.createElement('div');
        lbl.className = 'label-container';
        lbl.style.position = 'absolute';
        lbl.style.transform = 'translate(-50%, -50%)';
        lbl.style.pointerEvents = 'none';
        lbl.style.zIndex = 1000 - i; // Ensure proper layering
        const numberSpan = document.createElement('div');
        numberSpan.className = 'number-label';
        numberSpan.textContent = char.value;
        lbl.appendChild(numberSpan);
        const descSpan = document.createElement('div');
        descSpan.className = 'desc-label';
        descSpan.textContent = char.label;
        lbl.appendChild(descSpan);
        // Append to label container in the DOM
        document.getElementById('labels').appendChild(lbl);
        // Store reference to the DOM label in sprite for position updates
        sprite.userData.domLabel = lbl;
      }
      fitCameraToObject(camera, group);
    }).catch(err => {
      console.error('Texture loading error:', err);
    });

    // Animate the scene
    function animate() {
      requestAnimationFrame(animate);
      // We removed the star field, so there is nothing to rotate here.
      // Animate characters: bobbing up and down; astronaut slight waving
      const time = Date.now() * 0.001;
      animatedSprites.forEach(sprite => {
        const base = sprite.userData.basePosition;
        const idx = sprite.userData.index;
        // small vertical bobbing (phase offset per sprite)
        const bob = 0.1 * Math.sin(time * 1.5 + idx);
        sprite.position.y = base.y + bob;
        // Keep halo in sync
        // Keep associated halo in sync vertically with its sprite
        const halo = sprite.userData.halo;
        if (halo) {
          halo.position.y = sprite.position.y;
        }
        // Astronaut gentle waving (rotate slightly around Z)
        if (idx === 0) {
          // Astronaut gently waves by tilting slightly back and forth
          sprite.material.rotation = 0.3 * Math.sin(time * 1.5);
        } else {
          // Other children subtly lean toward the previous character along the slope
          // Calculate a small parameter that oscillates between -0.1 and 0.1
          const t = 0.05 * Math.sin(time * 0.5 + idx);
          // Move toward previous position along slope
          const start = sprite.userData.basePosition;
          const prev = positions[idx - 1];
          sprite.position.x = start.x + (prev.x - start.x) * t;
          sprite.position.y = (start.y + (prev.y - start.y) * t) + bob;
          // Update halo position accordingly
          if (halo) {
            halo.position.x = sprite.position.x;
            halo.position.y = sprite.position.y;
          }
        }
      });
      updateLabelPositions();
      renderer.render(scene, camera);
    }
    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.position.z = getCameraDistance();  // Update camera distance
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Recalculate positions for new viewport
      const newPositions = calculatePositions();
      
      // Update sprite and halo positions
      animatedSprites.forEach((sprite, i) => {
        sprite.userData.basePosition = newPositions[i].clone();
        const spritePos = newPositions[i].clone();
        spritePos.z = 0.3;
        sprite.position.copy(spritePos);
        
        if (sprite.userData.halo) {
          sprite.userData.halo.position.copy(newPositions[i]);
          sprite.userData.halo.position.z = 0.1;
        }
      });
      
      // Recreate slope with new positions
      positions = newPositions;
      
      fitCameraToObject(camera, group);
      setLabelSizes();
      updateLabelPositions();
    });
  })();
  </script>
</body>
</html>
