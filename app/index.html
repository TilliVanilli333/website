<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="robots" content="noindex, nofollow, noarchive">
    <title>🌟 Raumstation Wünschestadt</title>
    
    <!-- iOS Web App Meta Tags for Stability -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Wünschestadt">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Prevent reload on orientation change -->
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Theme color -->
    <meta name="theme-color" content="#34D399">
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css' rel='stylesheet' />
    
    <!-- Turf.js for geographic calculations -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    
    <!-- Development Configuration -->
    <script src="dev-config.js"></script>
    
    <!-- Define global functions early -->
    <script>
        // Define these functions globally so they're available for onclick handlers
        window.showTab = function(tabName) {
            // Update tab buttons
            document.querySelectorAll('.project-tab').forEach(tab => tab.classList.remove('active'));
            const activeTab = document.getElementById(`tab-${tabName}`);
            if (activeTab) activeTab.classList.add('active');
            
            // Show/hide tab content
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
            const activeContent = document.getElementById(`tab-${tabName}-content`);
            if (activeContent) activeContent.style.display = 'block';
            
            if (tabName === 'load') {
                // Load local projects when switching to load tab
                if (window.loadProjectsList) {
                    window.loadProjectsList();
                }
            } else if (tabName === 'cloud') {
                // Load cloud projects when switching to cloud tab
                if (window.showCloudProjectList) {
                    window.showCloudProjectList();
                }
            }
        };
        // Area selection functions will be defined later
        
        // These will be defined later in the main script
        
        // showProjectMenu will be defined later in the main script
    </script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, updateDoc, deleteDoc, query, where, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDCLU0RmjRBHQni21qZuRgufzTIHE6keCQ",
            authDomain: "kinderperspektiven-6a87f.firebaseapp.com",
            projectId: "kinderperspektiven-6a87f",
            storageBucket: "kinderperspektiven-6a87f.firebasestorage.app",
            messagingSenderId: "718502793148",
            appId: "1:718502793148:web:46ccbbadf9866ef4c425b9"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const firebaseDb = getFirestore(app);
        const storage = getStorage(app);
        
        // Make Firebase available globally
        window.firebase = {
            app,
            db: firebaseDb,
            storage,
            // Export functions for use
            collection,
            doc,
            setDoc,
            getDoc,
            getDocs,
            updateDoc,
            deleteDoc,
            query,
            where,
            serverTimestamp,
            ref,
            uploadBytes,
            getDownloadURL,
            deleteObject,
            listAll
        };
        
        console.log('🔥 Firebase initialized successfully');
        
        // Update cloud status indicator
        const cloudStatusContainer = document.getElementById('cloud-status-container');
        const cloudStatus = document.getElementById('cloud-status');
        if (cloudStatusContainer && cloudStatus) {
            cloudStatusContainer.style.display = 'block';
            cloudStatus.textContent = 'Bereit';
            cloudStatus.className = 'status-online';
        }
    </script>
    
    <!-- SVG Filters for Paper/Sketch Effect -->
    <svg style="display: none;">
        <defs>
            <filter id="paperSketch">
                <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" seed="2" />
                <feDisplacementMap in="SourceGraphic" scale="2" />
                <feGaussianBlur stdDeviation="0.3" />
            </filter>
            
            <filter id="roughPaper">
                <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="3" result="turbulence" seed="1" />
                <feComposite in="turbulence" in2="SourceGraphic" operator="over" />
            </filter>
        </defs>
    </svg>
    
    <style>
        :root {
            /* Apple-inspired Color System - Light Theme */
            --primary: #F5F5F7;
            --secondary: #FFFFFF;
            --tertiary: #FAFAFA;
            --accent: #007AFF;
            --text-primary: #1D1D1F;
            --text-secondary: #86868B;
            --text-tertiary: #515154;
            --border: #D2D2D7;
            --shadow: rgba(0, 0, 0, 0.08);
            --shadow-hover: rgba(0, 0, 0, 0.12);
            
            /* Glass morphism effects */
            --glass-bg: rgba(0, 0, 0, 0.3);
            --glass-border: rgba(255, 255, 255, 0.2);
            
            /* Begehung Colors */
            --begehung-professional: #FF3B30;
            --begehung-children: #FFCC00;
            
            /* Status Colors */
            --success: #34C759;
            --warning: #FF9500;
            --danger: #FF3B30;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', system-ui, sans-serif;
            background: var(--secondary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Setup Screen */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #0f0f23);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }

        .setup-content {
            background: white;
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 25px;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: var(--shadow-hover);
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: auto;
        }

        .setup-content h1 {
            font-size: 28px;
            background: linear-gradient(135deg, var(--accent), #8a2be2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--accent);
            font-weight: 500;
            font-size: 14px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 15px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            min-height: 44px; /* Touch-friendly minimum height */
            white-space: nowrap; /* Prevent text wrapping */
        }

        .btn.primary {
            background: var(--accent);
            color: white;
        }

        .btn.secondary {
            background: var(--secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Map Preview Styles */
        .setup-layout {
            display: flex;
            gap: 30px;
            width: 100%;
        }
        
        .setup-left {
            flex: 1;
            min-width: 350px;
        }
        
        .setup-right {
            flex: 1;
            min-width: 400px;
            position: relative;
        }
        
        .map-preview-container {
            background: #f0f0f0;
            border: 1px solid var(--border);
            border-radius: 12px;
            height: 400px;
            overflow: hidden;
            position: relative;
            display: block !important;
        }
        
        #map-preview {
            width: 100%;
            height: 100%;
            display: block !important;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .area-selection-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            box-shadow: var(--shadow);
            z-index: 1000;
        }
        
        .area-btn {
            padding: 8px 12px;
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 13px;
            margin-bottom: 5px;
            width: 100%;
            text-align: left;
        }
        
        .area-btn.active {
            background: var(--accent);
            color: white;
        }
        
        .area-list {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .area-item {
            padding: 5px;
            font-size: 12px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border);
        }
        
        @media (max-width: 1024px) {
            .setup-layout {
                flex-direction: column;
            }
            
            .setup-left {
                min-width: 100%;
            }
            
            .setup-right {
                min-width: 100%;
                margin-top: 20px;
            }
            
            .map-preview-container {
                height: 300px;
            }
        }
        
        @media (max-width: 768px) {
            .setup-content {
                padding: 20px;
                max-width: 100%;
            }
            
            .map-preview-container {
                height: 250px;
            }
        }

        .progress {
            margin: 20px 0;
            text-align: left;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, var(--accent), var(--success));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Main App Layout */
        .app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        .map-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            display: none !important; /* Completely hidden in new design */
        }
        
        .sidebar.collapsed {
            transform: translateY(calc(100% - 50px));
        }
        
        .sidebar-toggle {
            position: absolute;
            top: 10px;
            right: 150px;
            width: 60px;
            height: 45px;
            background: rgba(26, 27, 58, 0.95);
            border: 2px solid var(--accent);
            border-radius: 12px;
            color: var(--accent);
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.4);
        }
        
        .sidebar-toggle:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 255, 255, 0.6);
        }
        
        .map-container.expanded {
            bottom: 0 !important;
        }

        .sidebar-section {
            min-width: 280px;
            flex-shrink: 0;
            padding-bottom: 10px; /* Extra padding for each section */
        }

        .sidebar-section h3 {
            color: var(--accent);
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(135deg, var(--accent), #8a2be2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status-bar {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 11px;
            min-width: 220px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-online { color: var(--success); }
        .status-offline { color: var(--warning); }

        .layer-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .layer-option:hover {
            background: rgba(0,255,255,0.1);
            border-color: var(--accent);
        }

        .layer-option.active {
            background: rgba(0,255,255,0.2);
            border-color: var(--accent);
            font-weight: 600;
        }

        .layer-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        .layer-count {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
        }

        .toggle-switch {
            width: 30px;
            height: 16px;
            background: rgba(255,255,255,0.2);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--success);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(14px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(0,255,255,0.1), rgba(128,0,255,0.1));
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 8px;
            padding: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 2px;
        }

        .stat-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .tool-section {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 5px 0;
            max-width: 100%;
        }

        @media (max-width: 768px) {
            .tool-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }
            
            .tool-section {
                max-height: none; /* Remove height limit */
                padding: 8px;
                overflow: visible;
            }
        }

        @media (max-width: 480px) {
            .tool-grid {
                grid-template-columns: repeat(2, 1fr); /* Only 2 columns for better visibility */
                gap: 5px;
            }
            
            .tool-btn {
                padding: 8px;
                font-size: 11px;
                min-height: 50px;
            }
            
            .tool-btn .tool-icon {
                font-size: 16px;
            }
            
            .tool-section {
                max-height: none;
                padding: 6px;
                overflow: visible;
            }
        }

        .tool-btn {
            padding: 10px 5px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 65px;
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(0, 255, 255, 0.25);
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
        }

        .tool-btn.active {
            background: var(--success);
            color: var(--primary);
        }

        .tool-icon {
            font-size: 20px;
        }
        
        .tool-btn div:last-child {
            font-size: 11px;
            font-weight: 500;
            line-height: 1.2;
        }

        .measure-display {
            background: rgba(0,255,255,0.1);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
        }

        .measure-mode-btn, .route-type-btn, .route-action-btn {
            padding: 4px 8px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .measure-mode-btn:hover, .route-type-btn:hover, .route-action-btn:hover {
            background: var(--accent);
            color: var(--primary);
        }

        .measure-mode-btn.active, .route-type-btn.active {
            background: var(--accent);
            color: var(--primary);
            font-weight: bold;
        }

        .measure-input-section {
            text-align: left;
        }

        .route-info {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 6px;
            margin: 5px 0;
            font-size: 10px;
        }

        /* Project Management Styles */
        .project-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .project-tab {
            flex: 1;
            padding: 10px 15px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .project-tab:hover {
            background: rgba(0,255,255,0.2);
            border-color: var(--accent);
        }

        .project-tab.active {
            background: var(--accent);
            color: white;
            font-weight: bold;
        }

        .tab-content {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .project-item {
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .project-item:hover {
            background: var(--tertiary);
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .project-name {
            font-size: 16px;
            font-weight: bold;
            color: var(--accent);
        }

        .project-date {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .project-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .project-stat {
            display: flex;
            justify-content: space-between;
        }

        .project-actions {
            display: flex;
            gap: 5px;
        }

        .project-action-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .load-btn {
            background: var(--success);
            color: white;
        }

        .export-btn {
            background: var(--accent);
            color: var(--primary);
        }

        .delete-btn {
            background: var(--danger);
            color: white;
        }

        .project-action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .loading-projects {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .no-projects {
            text-align: center;
            padding: 40px;
            color: #ccc;
        }

        /* New Bottom Control Bar */
        .bottom-control-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--primary);
            border-top: 1px solid var(--border);
            box-shadow: 0 -2px 10px var(--shadow);
            z-index: 1000;
            padding: var(--spacing-md);
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: var(--spacing-md);
            transition: transform 0.3s ease;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }
        
        .bottom-control-bar::-webkit-scrollbar {
            height: 4px;
        }
        
        .bottom-control-bar::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .bottom-control-bar::-webkit-scrollbar-thumb {
            background-color: var(--border);
            border-radius: 2px;
        }
        
        .control-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-primary) !important; /* Force text color */
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 75px;
            height: 60px; /* Fixed height for consistency */
            font-size: 11px;
            font-weight: 500;
            gap: var(--spacing-xs);
            flex-shrink: 0; /* Prevent shrinking */
        }
        
        .control-button .control-button-label {
            color: var(--text-primary) !important; /* Ensure label is always visible */
        }
        
        .control-button:hover {
            background: var(--secondary);
            box-shadow: 0 2px 8px var(--shadow-hover);
            transform: translateY(-2px);
        }
        
        .control-button.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .control-button.professional {
            border-color: var(--begehung-professional);
        }
        
        .control-button.professional.active {
            background: var(--begehung-professional);
        }
        
        .control-button.children {
            border-color: var(--begehung-children);
        }
        
        .control-button.children.active {
            background: var(--begehung-children);
            color: var(--text-primary);
        }
        
        /* Highlighting for quick actions during Begehung */
        .control-button.highlight-professional {
            border: 2px solid var(--begehung-professional);
            background: rgba(255, 59, 48, 0.1);
        }
        
        .control-button.highlight-children {
            border: 2px solid var(--begehung-children);
            background: rgba(255, 204, 0, 0.1);
        }
        
        .control-button-icon {
            font-size: 20px;
        }
        
        .control-button-label {
            font-size: 11px;
            margin-top: 2px;
        }
        
        .control-divider {
            width: 1px;
            height: 40px;
            background: var(--border);
            margin: 0 var(--spacing-sm);
        }
        
        /* Quick Action Buttons during Begehung */
        .begehung-actions {
            position: fixed;
            bottom: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .begehung-actions.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .quick-action {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--primary);
            border: 1px solid var(--border);
            box-shadow: 0 2px 12px var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 24px;
        }
        
        .quick-action:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px var(--shadow-hover);
        }
        
        /* Floating GPS Indicator - Updated */
        .gps-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            z-index: 1000;
            display: none; /* Hidden by default in new design */
            align-items: center;
            gap: 8px;
            font-size: 12px;
            box-shadow: 0 2px 8px var(--shadow);
        }

        /* Switch View (Ergebnis-Modus) - L-förmiges Layout */
        .switch-view {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            z-index: 2000;
        }
        
        .switch-view.active {
            display: grid;
            grid-template-columns: 1fr 450px;
            grid-template-rows: 1fr 300px;
            grid-template-areas: 
                "map sidebar"
                "bottom sidebar";
        }
        
        .switch-view-map {
            grid-area: map;
            position: relative;
            border-right: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        
        .switch-view-panel {
            grid-area: sidebar;
            background: var(--primary);
            overflow-y: auto;
            padding: var(--spacing-lg);
            box-shadow: -2px 0 10px var(--shadow);
        }
        
        .switch-view-bottom {
            grid-area: bottom;
            background: var(--primary);
            border-right: 1px solid var(--border);
            padding: var(--spacing-lg);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }
        
        .switch-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }
        
        .switch-view-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .switch-view-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--secondary);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .switch-view-close:hover {
            background: var(--border);
            transform: scale(1.1);
        }
        
        .switch-section {
            margin-bottom: var(--spacing-xl);
        }
        
        .switch-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        
        .switch-toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--secondary);
        }
        
        .switch-toggle-label {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .switch-toggle {
            width: 51px;
            height: 31px;
            background: var(--border);
            border-radius: 31px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .switch-toggle.active {
            background: var(--success);
        }
        
        .switch-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 27px;
            height: 27px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .switch-toggle.active::after {
            transform: translateX(20px);
        }
        
        .view-mode-selector {
            display: flex;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            background: var(--secondary);
            border-radius: var(--radius-md);
        }
        
        .view-mode-button {
            flex: 1;
            padding: var(--spacing-sm) var(--spacing-md);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .view-mode-button.active {
            background: var(--primary);
            color: var(--accent);
            box-shadow: 0 1px 3px var(--shadow);
        }
        
        /* Search Box - In Bottom Bar */
        .bottom-search-container {
            position: relative;
            flex: 1;
            max-width: 300px;
            margin-left: 15px;
        }
        
        .bottom-search-input {
            width: 100%;
            padding: 8px 12px 8px 35px;
            background: var(--secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .bottom-search-input::placeholder {
            color: var(--text-secondary);
        }
        
        .bottom-search-input:focus {
            outline: none;
            border-color: var(--accent);
            background: var(--primary);
            box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.1);
        }
        
        .bottom-search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
        }
        
        .bottom-search-results {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 8px;
            max-height: 300px;
            overflow-y: auto;
            background: var(--primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: 0 -4px 12px var(--shadow);
            display: none;
            z-index: 2000;
        }
        
        .search-result-item {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--primary);
        }
        
        .search-result-item:hover {
            background: var(--secondary);
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-category {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--accent);
            color: var(--primary);
            border-radius: 4px;
            font-weight: bold;
            margin-left: auto;
        }
        
        /* Old Search Box - Hidden */
        .search-box {
            display: none;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }

        .search-results {
            margin-top: 8px;
            max-height: 400px;
            overflow-y: auto;
            background: var(--glass-bg);
            border-radius: 8px;
            display: none;
        }

        .search-result-item {
            padding: 10px;
            border-bottom: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-result-item:hover {
            background: rgba(0,255,255,0.2);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-category {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--accent);
            color: var(--primary);
            border-radius: 4px;
            font-weight: bold;
        }

        /* Begehungs-Modus Indicator */
        .begehung-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff4060, #ff8000);
            backdrop-filter: blur(20px);
            border: 1px solid white;
            border-radius: 12px;
            padding: 8px 12px;
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(255,64,96,0.3);
        }

        @media (min-width: 1024px) {
            .begehung-indicator {
                left: auto;
                right: 340px;
                transform: none;
            }
        }

        .begehung-indicator.active {
            display: flex;
        }

        .begehung-timer {
            font-family: monospace;
            font-size: 13px;
            color: white;
        }

        .begehung-distance {
            padding: 2px 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 11px;
        }

        .begehung-stop-btn {
            padding: 4px 8px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .begehung-stop-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .quick-action-bar {
            position: absolute;
            bottom: 210px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 6px;
            z-index: 999;
            display: none;
            gap: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .quick-action-bar.active {
            display: flex;
            flex-direction: column;
        }

        .quick-action-btn {
            width: 48px;
            height: 48px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: all 0.2s ease;
        }

        .quick-action-btn:hover {
            background: var(--accent);
            color: var(--primary);
            transform: scale(1.1);
        }

        .quick-action-btn .icon {
            font-size: 20px;
        }

        .quick-action-btn .label {
            font-size: 8px;
            font-weight: bold;
        }

        .gps-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Popup styling */
        .popup-content {
            background: var(--primary);
            color: white;
            padding: 16px;
            border-radius: 12px;
            min-width: 250px;
            max-width: 300px;
        }

        .popup-content h3 {
            color: var(--accent);
            margin-bottom: 12px;
            font-size: 16px;
        }

        .popup-content .info-grid {
            display: grid;
            gap: 6px;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .popup-content .info-row {
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .popup-btn {
            width: 100%;
            padding: 8px;
            background: var(--accent);
            color: var(--primary);
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 8px;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal {
            background: var(--secondary);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .modal h2 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 20px;
            text-align: center;
        }

        /* Loading */
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 30px rgba(0, 255, 255, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(0, 255, 255, 0);
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Desktop specific adjustments */
        @media (min-width: 1024px) {
            .sidebar {
                max-height: 35vh; /* Smaller on desktop */
                overflow-y: auto;
                overflow-x: auto;
            }
            
            .map-container {
                bottom: 0; /* Map fills screen */
            }
            
            .sidebar-section {
                min-width: 320px; /* Wider sections on desktop */
            }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .bottom-control-bar {
                padding: 8px;
                gap: 8px;
                overflow-x: auto;
                justify-content: flex-start;
            }
            
            .control-button {
                min-width: 60px;
                height: 50px;
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .control-button-icon {
                font-size: 16px;
            }
            
            .control-divider {
                display: none;
            }
            
            .bottom-search-container {
                min-width: 150px;
                flex-shrink: 1;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 480px) {
            .bottom-control-bar {
                padding: 6px;
                gap: 6px;
            }
            
            .control-button {
                min-width: 50px;
                height: 45px;
                padding: 3px 4px;
                font-size: 9px;
            }
            
            .control-button-icon {
                font-size: 14px;
            }
            
            .control-button-label {
                font-size: 8px;
            }
            
            .bottom-search-container {
                min-width: 120px;
            }
            
            .switch-view-panel {
                width: 100%;
                position: absolute;
                bottom: 0;
                height: 50vh;
                border-top: 1px solid var(--border);
                border-left: none;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            }
            
            .switch-view.active {
                flex-direction: column;
            }
            
            .switch-view-map {
                height: 50vh;
            }
            
            .begehung-actions {
                bottom: 120px;
                right: 10px;
            }
            
            .quick-action {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .map-container {
                height: 55vh; /* Even smaller map on very small screens */
            }
            
            .sidebar {
                max-height: 45vh;
                min-height: 160px;
                padding: 10px 12px;
                gap: 12px;
            }
            
            .sidebar-section {
                min-width: 200px;
            }
            
            .layer-option {
                padding: 6px 8px;
                font-size: 11px;
            }
            
            .tool-btn {
                padding: 8px;
                font-size: 11px;
            }
            
            .gps-indicator {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .search-box {
                width: 200px;
                top: 80px;
                left: 10px;
            }
            
            .begehung-indicator {
                font-size: 11px;
                padding: 6px 10px;
                top: 55px;
            }
        }
        
        /* ============ KINDERPERSPEKTIVE PAPER STYLE ============ */
        .kinderperspektive-mode #map {
            filter: 
                sepia(0.15)
                contrast(1.1)
                brightness(1.05)
                saturate(0.85);
            position: relative;
        }
        
        /* Water animation overlay for better visibility */
        .kinderperspektive-mode .water-animated::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* background-image: url('./assets/textures/water/water-animation.svg'); */
            background-size: 1000px 1000px; /* Large scale for visibility */
            opacity: 0.2;
            mix-blend-mode: overlay;
            animation: waterFlow 30s linear infinite;
        }
        
        @keyframes waterFlow {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-1000px, -1000px); }
        }
        
        /* Paper texture overlay */
        .paper-texture {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            mix-blend-mode: multiply;
            opacity: 0.35; /* Increased visibility */
            /* background-image: url('./assets/textures/paper/papiernormal.png'); */
            background-repeat: repeat;
            background-size: 2048px 2048px; /* Much larger scale for visibility */
            animation: paperDrift 60s linear infinite; /* Subtle movement */
        }
        
        @keyframes paperDrift {
            0% { background-position: 0 0; }
            100% { background-position: 2048px 2048px; }
        }
        
        /* Fallback if texture not found */
        .paper-texture.fallback {
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 90, 43, 0.03) 2px,
                    rgba(139, 90, 43, 0.03) 4px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 90, 43, 0.02) 2px,
                    rgba(139, 90, 43, 0.02) 4px
                );
        }
        
        /* Vignette effect for paper edges */
        .vignette-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            background: radial-gradient(
                circle at center,
                transparent 40%,
                rgba(139, 90, 43, 0.1) 70%,
                rgba(101, 67, 33, 0.2) 100%
            );
        }
        
        /* Canvas noise overlay */
        #paperCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 12;
            mix-blend-mode: multiply;
            opacity: 0.08;
        }
        
        /* Animated character placeholder */
        .character-marker {
            width: 48px;
            height: 48px;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.8), rgba(200, 150, 50, 0.6));
            border-radius: 50%;
            border: 3px solid #8B5A2B;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: characterBounce 0.8s ease-in-out infinite;
            position: relative;
        }
        
        .character-marker::after {
            content: '👤';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }
        
        @keyframes characterBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-4px) scale(1.05); }
        }
        
        /* Custom colors for Kinderperspektive mode */
        .kinderperspektive-mode .mapboxgl-ctrl-group {
            background: rgba(245, 222, 179, 0.9);
            border: 2px solid #8B5A2B;
        }
        
        .kinderperspektive-mode .mapboxgl-ctrl-group button {
            color: #5D4E37;
        }
        
        .kinderperspektive-mode .sidebar {
            background: rgba(26, 27, 58, 0.98); /* Keep dark solid background even in Kinderperspektive mode */
            border-color: rgba(139, 90, 43, 0.3);
        }
        
        .kinderperspektive-mode .tool-btn {
            background: rgba(139, 90, 43, 0.2);
            border-color: rgba(139, 90, 43, 0.4);
        }
        
        .kinderperspektive-mode .tool-btn:hover {
            background: rgba(139, 90, 43, 0.35);
            border-color: #8B5A2B;
        }
    </style>
    <!-- JSZip for creating real ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <!-- Setup Screen -->
    <div id="setup-screen" class="setup-screen">
        <div class="setup-content">
            <h1>🚀 <strong>Raumstation</strong></h1>
            <p style="color: var(--text-secondary); margin-bottom: 30px;">Kinderperspektivenprojekt: Wünschestadt</p>
            
            <!-- Main Content - No Tabs anymore -->
                <div class="setup-layout">
                    <div class="setup-left">
                        <div class="input-group">
                            <label for="project-name-input">Projektname *</label>
                            <input type="text" id="project-name-input" placeholder="z.B. Kinderfreundlichkeit Wachtendonk 2024" autocomplete="off">
                        </div>
                        
                        <div class="input-group">
                            <label for="kommune-input">Kommune/Stadt eingeben *</label>
                            <div style="display: flex; gap: 10px;">
                                <input type="text" id="kommune-input" placeholder="z.B. Wachtendonk, Jüchen, Bedburg..." autocomplete="address-level2" style="flex: 1;">
                                <button class="btn secondary" onclick="if(window.searchAndShowLocation) window.searchAndShowLocation(document.getElementById('kommune-input').value)" title="Auf Karte anzeigen" style="padding: 10px 15px;">
                                    🗺️
                                </button>
                            </div>
                        </div>
                        
                        <div class="input-group" style="display: none;">
                            <label for="radius-input">Analyseradius (km)</label>
                            <input type="number" id="radius-input" value="3" min="1" max="10" step="0.5">
                        </div>
                        
                        <div class="input-group">
                            <label>Gebietsmanagement</label>
                            <button class="area-btn" onclick="defineAreaBounds('stadt')">
                                🏙️ Stadtgebiet festlegen
                            </button>
                            <button class="area-btn" onclick="manageOrtsteile()">
                                🏘️ Ortsteile definieren
                            </button>
                            <button class="area-btn" onclick="defineAreaBounds('begehung')">
                                🚶 Begehungsgebiet markieren
                            </button>
                        </div>
                        
                        <div id="area-info" class="area-list" style="display: none;">
                            <!-- Dynamically populated -->
                        </div>
                        
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 20px;">
                            <button id="download-btn" class="btn primary">
                                📥 Projekt erstellen
                            </button>
                            <button id="load-projects-btn" class="btn secondary" onclick="showProjectsList()">
                                📂 Projekt laden
                            </button>
                        </div>
                    </div>
                    
                    <div class="setup-right">
                        <div class="map-preview-container">
                            <div id="map-preview"></div>
                            <div class="area-selection-controls" style="display: none;">
                                <div style="font-size: 12px; font-weight: bold; margin-bottom: 8px;">
                                    📍 Gebiet auswählen
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                                    Ziehen Sie ein Rechteck über das gewünschte Gebiet
                                </div>
                                <button class="area-btn" id="confirm-area-btn" onclick="confirmAreaSelection()">
                                    ✅ Auswahl bestätigen
                                </button>
                                <button class="area-btn" onclick="cancelAreaSelection()">
                                    ❌ Abbrechen
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            
            <div id="progress-section" class="progress" style="display: none;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div id="progress-text" class="progress-text">Bereit zum Download...</div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="app-container">
        <!-- GPS Indicator -->
        <div class="gps-indicator">
            <div class="gps-dot"></div>
            <span id="gps-text">GPS</span>
            <span>|</span>
            <span id="header-location" style="font-size: 11px;">📍 Lade...</span>
            <span>|</span>
            <span id="project-name-display" style="font-size: 11px;">📂 Projekt</span>
            <span>|</span>
            <span id="total-score" style="font-weight: bold;">Score: --</span>
        </div>

        <!-- Search Box -->
        <div class="search-box">
            <input type="text" id="search-input" class="search-input" placeholder="🔍 Suche nach Orten, Straßen, Markern..." autocomplete="off">
            <div id="search-results" class="search-results"></div>
        </div>

        <!-- Begehungs-Indikator -->
        <div id="begehung-indicator" class="begehung-indicator">
            <span style="color: white; font-size: 11px;">🚶 BEGEHUNG</span>
            <span class="begehung-timer" id="begehung-timer">00:00</span>
            <span class="begehung-distance" id="begehung-distance">0m</span>
            <button class="begehung-stop-btn" onclick="stopBegehung()">⏹ Stop</button>
        </div>

        <!-- Quick Action Bar (während Begehung) -->
        <div id="quick-action-bar" class="quick-action-bar">
            <button class="quick-action-btn" onclick="quickPhoto()" title="Foto aufnehmen">
                <span class="icon">📸</span>
            </button>
            <button class="quick-action-btn" onclick="quickNote()" title="Notiz hinzufügen">
                <span class="icon">📝</span>
            </button>
            <button class="quick-action-btn" onclick="quickMarker()" title="Marker setzen">
                <span class="icon">📍</span>
            </button>
            <button class="quick-action-btn" onclick="quickDanger()" title="Gefahr markieren">
                <span class="icon">⚠️</span>
            </button>
        </div>

        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
        </div>

        <!-- New Bottom Control Bar -->
        <div class="bottom-control-bar" id="bottomControlBar">
            <!-- Main Menu Button (NEW) -->
            <button class="control-button" onclick="goToMainMenu()" style="background: var(--warning); color: var(--primary);">
                <span class="control-button-icon">🏠</span>
                <span class="control-button-label">Menü</span>
            </button>
            
            <div class="control-divider"></div>
            
            <!-- Begehung Section -->
            <button class="control-button professional" onclick="startBegehungProfessional()" id="begehungProBtn">
                <span class="control-button-icon">👔</span>
                <span class="control-button-label">Fachkräfte</span>
            </button>
            
            <button class="control-button children" onclick="startBegehungChildren()" id="begehungChildBtn">
                <span class="control-button-icon">👶</span>
                <span class="control-button-label">Kinder</span>
            </button>
            
            <div class="control-divider"></div>
            
            <!-- Quick Actions (always visible) -->
            <button class="control-button quick-action-btn" onclick="quickPhoto()" id="quickPhotoBtn">
                <span class="control-button-icon">📸</span>
                <span class="control-button-label">Foto</span>
            </button>
            
            <button class="control-button quick-action-btn" onclick="quickVoiceNote()" id="quickVoiceBtn">
                <span class="control-button-icon">🎤</span>
                <span class="control-button-label">Audio</span>
            </button>
            
            <button class="control-button quick-action-btn" onclick="quickTextNote()" id="quickTextBtn">
                <span class="control-button-icon">📝</span>
                <span class="control-button-label">Notiz</span>
            </button>
            
            <button class="control-button quick-action-btn" onclick="activateMarkerTool()" id="markerBtn">
                <span class="control-button-icon">📍</span>
                <span class="control-button-label">Marker</span>
            </button>
            
            <button class="control-button quick-action-btn" onclick="toggleDrawingMode()" id="drawingBtn">
                <span class="control-button-icon">🖌️</span>
                <span class="control-button-label">Zeichnen</span>
            </button>
            
            <div class="control-divider"></div>
            
            <!-- Tools Section -->
            
            <button class="control-button" onclick="activateMeasureTool()">
                <span class="control-button-icon">📏</span>
                <span class="control-button-label">Messen</span>
            </button>
            
            <button class="control-button" onclick="findMyLocation()">
                <span class="control-button-icon">🧭</span>
                <span class="control-button-label">GPS</span>
            </button>
            
            <div class="control-divider"></div>
            
            <!-- View Mode Section -->
            <button class="control-button" onclick="toggleMapStyle()" id="styleToggleBtn">
                <span class="control-button-icon">🏞️</span>
                <span class="control-button-label" id="styleLabel">Standard</span>
            </button>
            
            <div class="control-divider"></div>
            
            <!-- Actions Section -->
            <button class="control-button" onclick="exportProject()">
                <span class="control-button-icon">📦</span>
                <span class="control-button-label">Export</span>
            </button>
            
            <!-- Projekt Button (moved here between Export and Ergebnis) -->
            <button class="control-button" onclick="showProjectMenu()" id="projectMenuBtn">
                <span class="control-button-icon">📂</span>
                <span class="control-button-label">Projekte</span>
            </button>
            
            <button class="control-button" onclick="openSwitchView()" style="background: var(--accent); color: white;">
                <span class="control-button-icon">🔄</span>
                <span class="control-button-label">Ergebnis</span>
            </button>
            
            <!-- Search Box in Bottom Bar -->
            <div class="bottom-search-container">
                <span class="bottom-search-icon">🔍</span>
                <input type="text" id="bottom-search-input" class="bottom-search-input" placeholder="Suche Orte, Straßen..." autocomplete="off">
                <div id="bottom-search-results" class="bottom-search-results"></div>
            </div>
        </div>

        <!-- Switch View (Ergebnis-Ansicht) - L-förmiges Layout -->
        <div class="switch-view" id="switchView">
            <div class="switch-view-map">
                <!-- Map will be moved here when switch view is active -->
            </div>
            
            <!-- Bottom Panel (L-Form) -->
            <div class="switch-view-bottom">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-md);">
                    <h3 style="color: var(--text-primary); font-size: 18px;">📊 Projekt-Übersicht</h3>
                    <button class="control-button" onclick="closeSwitchView()" style="background: var(--secondary);">
                        <span class="control-button-icon">↩️</span>
                        <span class="control-button-label">Zurück</span>
                    </button>
                </div>
                
                <!-- Statistics Grid -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                    <div style="background: var(--secondary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 600; color: var(--accent);" id="stat-schools">0</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">🏫 Schulen</div>
                    </div>
                    <div style="background: var(--secondary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 600; color: var(--accent);" id="stat-playgrounds">0</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">🎮 Spielplätze</div>
                    </div>
                    <div style="background: var(--secondary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 600; color: var(--warning);" id="stat-dangers">0</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">⚠️ Gefahren</div>
                    </div>
                    <div style="background: var(--secondary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 600; color: var(--success);" id="stat-score">--</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">✨ Score</div>
                    </div>
                </div>
                
                <!-- Additional Info -->
                <div style="margin-top: var(--spacing-md); padding: var(--spacing-md); background: var(--secondary); border-radius: 12px;">
                    <h4 style="color: var(--text-primary); margin-bottom: 8px;">📝 Projekt-Details</h4>
                    <div style="display: flex; gap: 20px; font-size: 13px; color: var(--text-secondary);">
                        <span>Kommune: <strong id="stat-kommune" style="color: var(--text-primary);">--</strong></span>
                        <span>Begehungen: <strong id="stat-begehungen" style="color: var(--text-primary);">0</strong></span>
                        <span>Fotos: <strong id="stat-photos" style="color: var(--text-primary);">0</strong></span>
                    </div>
                </div>
            </div>
            
            <div class="switch-view-panel">
                <div class="switch-view-header">
                    <h2 class="switch-view-title">Layer-Kontrolle</h2>
                </div>
                
                <!-- Kinder-Orte Section -->
                <div class="switch-section">
                    <h3 class="switch-section-title">🏫 Kinder-Orte</h3>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #ff69b4; border-radius: 2px;"></span>
                            🏫 Schulen
                        </span>
                        <div class="switch-toggle active" data-layer="schools"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #ff1493; border-radius: 2px;"></span>
                            🍼 Kitas
                        </span>
                        <div class="switch-toggle active" data-layer="kitas"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #00ff80; border-radius: 2px;"></span>
                            🎮 Spielplätze
                        </span>
                        <div class="switch-toggle active" data-layer="playgrounds"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #32cd32; border-radius: 2px;"></span>
                            🌳 Parks
                        </span>
                        <div class="switch-toggle active" data-layer="parks"></div>
                    </div>
                </div>
                
                <!-- Infrastruktur Section -->
                <div class="switch-section">
                    <h3 class="switch-section-title">🏥 Infrastruktur</h3>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #ff6b6b; border-radius: 2px;"></span>
                            🏥 Medizin
                        </span>
                        <div class="switch-toggle active" data-layer="medical"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #4ecdc4; border-radius: 2px;"></span>
                            🛒 Einkaufen
                        </span>
                        <div class="switch-toggle" data-layer="shopping"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #96ceb4; border-radius: 2px;"></span>
                            🚌 ÖPNV
                        </span>
                        <div class="switch-toggle" data-layer="transport"></div>
                    </div>
                </div>
                
                <!-- Verkehr & Sicherheit -->
                <div class="switch-section">
                    <h3 class="switch-section-title">🚦 Verkehr & Sicherheit</h3>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #ff4444; border-radius: 2px;"></span>
                            🚗 Hauptstraßen
                        </span>
                        <div class="switch-toggle" data-layer="highways"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #ff4060; border-radius: 2px;"></span>
                            ⚠️ Gefahrenzonen
                        </span>
                        <div class="switch-toggle" data-layer="danger-zones"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #00ff80; border-radius: 2px;"></span>
                            🚸 Sichere Übergänge
                        </span>
                        <div class="switch-toggle" data-layer="safe-crossings"></div>
                    </div>
                </div>
                
                <!-- Begehungen -->
                <div class="switch-section">
                    <h3 class="switch-section-title">🚶 Begehungen</h3>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #FF3B30; border-radius: 2px;"></span>
                            👔 Fachkräfte-Route
                        </span>
                        <div class="switch-toggle active" data-layer="route-professional"></div>
                    </div>
                    <div class="switch-toggle-item">
                        <span class="switch-toggle-label">
                            <span style="width: 12px; height: 12px; background: #FFCC00; border-radius: 2px;"></span>
                            👶 Kinder-Route
                        </span>
                        <div class="switch-toggle active" data-layer="route-children"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Horizontal Sidebar -->
        <div class="sidebar" id="sidebar">
            <!-- Toggle Button -->
            <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">
                <span id="toggleIcon">▼</span>
            </button>
            <!-- Status Section -->
            <div class="sidebar-section">
                <h3>📊 Status</h3>
                <div class="status-bar">
                    <div class="status-item">
                        <span>📶</span>
                        <span id="connection-status" class="status-offline">Offline</span>
                    </div>
                    <div class="status-item" id="cloud-status-container" style="display: none;">
                        <span>☁️</span>
                        <span id="cloud-status" class="status-offline">Nicht synchronisiert</span>
                    </div>
                    <div class="status-item">
                        <span>💾</span>
                        <span id="cached-count">0</span>
                    </div>
                    <div class="status-item">
                        <span>📍</span>
                        <span id="custom-count">0</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="school-count">0</div>
                        <div class="stat-label">🏫 Schulen</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="kitas-count">0</div>
                        <div class="stat-label">🍼 Kitas</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="playground-count">0</div>
                        <div class="stat-label">🎮 Spielplätze</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="park-count">0</div>
                        <div class="stat-label">🌳 Parks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="medical-count">0</div>
                        <div class="stat-label">🏥 Medizin</div>
                    </div>
                </div>
            </div>

            <!-- Kinder-Orte Section -->
            <div class="sidebar-section">
                <h3>🏫 Kinder-Orte</h3>
                <div class="layer-option active" data-layer="schools">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ff69b4;"></div>
                        <span>🏫 Schulen</span>
                    </div>
                    <div class="toggle-switch active"></div>
                </div>
                <div class="layer-option active" data-layer="kitas">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ff1493;"></div>
                        <span>🍼 Kitas</span>
                    </div>
                    <div class="toggle-switch active"></div>
                </div>
                <div class="layer-option active" data-layer="playgrounds">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #00ff80;"></div>
                        <span>🎮 Spielplätze</span>
                    </div>
                    <div class="toggle-switch active"></div>
                </div>
                <div class="layer-option active" data-layer="parks">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #32cd32;"></div>
                        <span>🌳 Parks & Grünflächen</span>
                    </div>
                    <div class="toggle-switch active"></div>
                </div>
                <div class="layer-option" data-layer="sports">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #45b7d1;"></div>
                        <span>⚽ Sportplätze</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
            </div>

            <!-- Infrastruktur Section -->
            <div class="sidebar-section">
                <h3>🏥 Infrastruktur</h3>
                <div class="layer-option active" data-layer="medical">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ff6b6b;"></div>
                        <span>🏥 Medizin</span>
                    </div>
                    <div class="toggle-switch active"></div>
                </div>
                <div class="layer-option" data-layer="shopping">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #4ecdc4;"></div>
                        <span>🛒 Einkaufen</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="transport">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #96ceb4;"></div>
                        <span>🚌 ÖPNV</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
            </div>

            <!-- Straßen Section -->
            <div class="sidebar-section">
                <h3>🛣️ Straßen</h3>
                <div class="layer-option" data-layer="highways">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ff4444;"></div>
                        <span>🚗 Hauptstraßen</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="residential">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ffdd00;"></div>
                        <span>🏘️ Wohnstraßen</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="footways">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #44ff44;"></div>
                        <span>🚶 Gehwege</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="cycleways">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #4488ff;"></div>
                        <span>🚲 Fahrradwege</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
            </div>

            <!-- Sicherheit Section -->
            <div class="sidebar-section">
                <h3>⚠️ Sicherheit</h3>
                <div class="layer-option" data-layer="danger-zones">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #ff4060;"></div>
                        <span>⚠️ Gefahrenzonen</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="safe-crossings">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #00ff80;"></div>
                        <span>🚸 Sichere Übergänge</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
                <div class="layer-option" data-layer="gps-track">
                    <div class="layer-info">
                        <div class="color-indicator" style="background: #00ffff;"></div>
                        <span>👣 Meine Route</span>
                    </div>
                    <div class="toggle-switch"></div>
                </div>
            </div>

            <!-- Tools Section -->
            <div class="sidebar-section">
                <h3>🛠️ Werkzeuge</h3>
                <div class="tool-section">
                    <div class="tool-grid">
                        <div class="tool-btn" onclick="activateMarkerTool()">
                            <span class="tool-icon">📍</span>
                            <span>Marker</span>
                        </div>
                        <div class="tool-btn" onclick="activatePhotoTool()">
                            <span class="tool-icon">📸</span>
                            <span>Foto</span>
                        </div>
                        <div class="tool-btn" onclick="activateMeasureTool()">
                            <span class="tool-icon">📏</span>
                            <span>Messen</span>
                        </div>
                        <div class="tool-btn" onclick="startBegehung()" id="begehung-btn">
                            <span class="tool-icon">🚶</span>
                            <span>Begehung</span>
                        </div>
                        <div class="tool-btn" onclick="findMyLocation()">
                            <span class="tool-icon">🧭</span>
                            <span>GPS</span>
                        </div>
                        <div class="tool-btn" onclick="openProjectMenu()">
                            <span class="tool-icon">📂</span>
                            <span>Projekt</span>
                        </div>
                        <div class="tool-btn" onclick="generateReport()">
                            <span class="tool-icon">📊</span>
                            <span>Report</span>
                        </div>
                        <div class="tool-btn" onclick="exportPhotosAsZip()">
                            <span class="tool-icon">📦</span>
                            <span>Export</span>
                        </div>
                    </div>
                    
                    <div id="measure-display" class="measure-display" style="display: none;">
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                                <button id="mode-click" class="measure-mode-btn active" onclick="setMeasureMode('click')">📍 Klicken</button>
                                <button id="mode-address" class="measure-mode-btn" onclick="setMeasureMode('address')">🏠 Adresse</button>
                            </div>
                            
                            <div id="click-mode" class="measure-input-section">
                                <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                                    <button id="route-walk" class="route-type-btn active" onclick="setRouteType('walking')">🚶 Zu Fuß</button>
                                    <button id="route-drive" class="route-type-btn" onclick="setRouteType('driving')">🚗 Auto</button>
                                </div>
                            </div>
                            
                            <div id="address-mode" class="measure-input-section" style="display: none;">
                                <input type="text" id="start-address" placeholder="Start (z.B. Schulstraße 5)" style="width: 100%; margin-bottom: 5px; padding: 5px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 4px; color: white; font-size: 11px;">
                                <input type="text" id="end-address" placeholder="Ziel (z.B. Grundschule)" style="width: 100%; margin-bottom: 5px; padding: 5px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 4px; color: white; font-size: 11px;">
                                <div style="display: flex; gap: 5px;">
                                    <button class="route-type-btn" onclick="calculateAddressRoute('walking')">🚶 Route</button>
                                    <button class="route-type-btn" onclick="calculateAddressRoute('driving')">🚗 Route</button>
                                </div>
                            </div>
                        </div>
                        
                        <div id="measure-result">Klicke zwei Punkte zum Messen</div>
                        
                        <div id="route-actions" style="display: none; margin-top: 8px; border-top: 1px solid var(--glass-border); padding-top: 8px;">
                            <div style="display: flex; gap: 5px;">
                                <button class="route-action-btn" onclick="saveCurrentRoute()">💾 Route speichern</button>
                                <button class="route-action-btn" onclick="clearCurrentRoute()">🗑️ Löschen</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* global mapboxgl, turf, firebase */
        /* eslint-disable no-undef, no-unused-vars */
        
        // ================ GLOBAL VARIABLES DECLARATION ================
        // Declare ALL global variables at the beginning to avoid VS Code errors
        
        // Core app variables
        let map = null;
        let db = null; // IndexedDB
        let firebaseDb = null; // Firebase Firestore
        let currentKommune = '';
        let currentProjectId = null;
        let currentProjectName = '';
        let isOnline = navigator.onLine;
        
        // Begehung (route tracking) variables
        let begehungActive = false;
        let begehungType = null;
        let begehungStartTime = null;
        let begehungTrack = [];
        let begehungDistance = 0;
        let begehungMarkers = [];
        let begehungTimer = null;
        let begehungWatchId = null;
        let lastBegehungPosition = null;
        let begehungTracks = { professional: [], children: [] };
        
        // GPS tracking variables
        let gpsTrack = [];
        let gpsWatchId = null;
        let userLocation = null;
        let userMarker = null;
        
        // Map data variables
        let osmData = {};
        let customMarkers = [];
        let searchIndex = [];
        let savedRoutes = [];
        
        // Measurement tool variables
        let measurePoints = [];
        let measureMarkers = [];
        let measureLine = null;
        let currentTool = null;
        let noteToPlace = null; // Store note text for manual placement
        
        // UI state variables
        let setupComplete = false;
        let activeProject = null;
        let currentMeasureMode = 'click'; // 'click' or 'address'
        let currentRouteType = 'walking'; // 'walking' or 'driving'
        let currentRoute = null;
        
        // Map styles
        let currentMapStyle = 'Standard';
        
        // NOTE: All begehung, GPS, and search variables are already declared above

        // IndexedDB setup with improved error handling
        function initDatabase() {
            return new Promise((resolve, reject) => {
                console.log('🗄️ Initialisiere IndexedDB...');
                
                const request = indexedDB.open('KinderfreundlichDB', 3); // Version erhöht für Debugging
                
                request.onerror = () => {
                    console.error('❌ IndexedDB Fehler:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('✅ IndexedDB erfolgreich geöffnet');
                    console.log('📋 Verfügbare Object Stores:', Array.from(db.objectStoreNames));
                    
                    // Verify all required stores exist
                    const requiredStores = ['osmData', 'customMarkers', 'gpsTracks', 'photos', 'routes', 'projects', 'customDrawings'];
                    const missingStores = requiredStores.filter(store => !db.objectStoreNames.contains(store));
                    
                    if (missingStores.length > 0) {
                        console.warn('⚠️ Fehlende Object Stores:', missingStores);
                        reject(new Error(`Missing object stores: ${missingStores.join(', ')}`));
                        return;
                    }
                    
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    console.log('🔄 Database Upgrade erforderlich...');
                    const db = event.target.result;
                    
                    // Store for OSM data
                    if (!db.objectStoreNames.contains('osmData')) {
                        console.log('➕ Erstelle osmData Store');
                        const osmStore = db.createObjectStore('osmData', { keyPath: 'id' });
                        osmStore.createIndex('type', 'type', { unique: false });
                        osmStore.createIndex('kommune', 'kommune', { unique: false });
                    }
                    
                    // Store for custom markers
                    if (!db.objectStoreNames.contains('customMarkers')) {
                        console.log('➕ Erstelle customMarkers Store');
                        const markerStore = db.createObjectStore('customMarkers', { keyPath: 'id' });
                        markerStore.createIndex('kommune', 'kommune', { unique: false });
                        markerStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    
                    // Store for GPS tracks
                    if (!db.objectStoreNames.contains('gpsTracks')) {
                        console.log('➕ Erstelle gpsTracks Store');
                        const trackStore = db.createObjectStore('gpsTracks', { keyPath: 'id' });
                        trackStore.createIndex('kommune', 'kommune', { unique: false });
                        trackStore.createIndex('projectId', 'projectId', { unique: false });
                    }
                    
                    // Store for photos
                    if (!db.objectStoreNames.contains('photos')) {
                        console.log('➕ Erstelle photos Store');
                        const photoStore = db.createObjectStore('photos', { keyPath: 'id' });
                        photoStore.createIndex('markerId', 'markerId', { unique: false });
                    }
                    
                    // Store for saved routes
                    if (!db.objectStoreNames.contains('routes')) {
                        console.log('➕ Erstelle routes Store');
                        const routeStore = db.createObjectStore('routes', { keyPath: 'id' });
                        routeStore.createIndex('kommune', 'kommune', { unique: false });
                        routeStore.createIndex('projectId', 'projectId', { unique: false });
                        routeStore.createIndex('routeType', 'routeType', { unique: false });
                    }
                    
                    // Store for projects
                    if (!db.objectStoreNames.contains('projects')) {
                        console.log('➕ Erstelle projects Store');
                        const projectStore = db.createObjectStore('projects', { keyPath: 'id' });
                        projectStore.createIndex('name', 'name', { unique: false });
                        projectStore.createIndex('kommune', 'kommune', { unique: false });
                        projectStore.createIndex('lastModified', 'lastModified', { unique: false });
                    }
                    
                    // Store for custom drawings (Pinsel-Tool)
                    if (!db.objectStoreNames.contains('customDrawings')) {
                        console.log('➕ Erstelle customDrawings Store');
                        const drawingStore = db.createObjectStore('customDrawings', { keyPath: 'id' });
                        drawingStore.createIndex('kommune', 'kommune', { unique: false });
                        drawingStore.createIndex('projectId', 'projectId', { unique: false });
                        drawingStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    
                    console.log('✅ Database Upgrade abgeschlossen');
                };
                
                request.onblocked = () => {
                    console.warn('⚠️ Database blocked - möglicherweise ist sie in einem anderen Tab geöffnet');
                    reject(new Error('Database blocked'));
                };
            });
        }

        // Geocoding function
        async function geocodeKommune(name) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(name + ', Deutschland')}&limit=1&addressdetails=1&accept-language=de`
                );
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const result = data[0];
                    return {
                        lat: parseFloat(result.lat),
                        lng: parseFloat(result.lon),
                        name: result.display_name.split(',')[0],
                        fullName: result.display_name,
                        boundingBox: result.boundingbox
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding failed:', error);
                return null;
            }
        }

        // Clear old data for a kommune before downloading new data
        async function clearOldKommuneData(kommune) {
            if (!db) return;
            
            console.log(`🗑️ Clearing old data for ${kommune}...`);
            
            const transaction = db.transaction(['osmData'], 'readwrite');
            const store = transaction.objectStore('osmData');
            
            // Get all data
            const request = store.getAll();
            
            return new Promise((resolve) => {
                request.onsuccess = () => {
                    const allData = request.result;
                    let deleteCount = 0;
                    
                    // Delete all entries for this kommune
                    allData.forEach(item => {
                        if (item.kommune === kommune) {
                            store.delete(item.id);
                            deleteCount++;
                        }
                    });
                    
                    console.log(`✅ Deleted ${deleteCount} old entries for ${kommune}`);
                    resolve();
                };
            });
        }

        // OSM Data fetching with enhanced polygon support and debugging
        async function fetchOSMData(lat, lng, radius) {
            // Clear old data for this kommune first
            await clearOldKommuneData(currentKommune);
            
            // Use defined bounds if available, otherwise use radius
            let bbox;
            if (areaBounds.stadt) {
                bbox = areaBounds.stadt;
            } else {
                const radiusInDegrees = radius / 111;
                bbox = [
                    lng - radiusInDegrees,
                    lat - radiusInDegrees,
                    lng + radiusInDegrees,
                    lat + radiusInDegrees
                ];
            }

            console.log('🔍 Fetching OSM data for bbox:', bbox);

            const queries = {
                schools: `
                    [out:json][timeout:45];
                    (
                        node["amenity"~"^(school|kindergarten)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["amenity"~"^(school|kindergarten)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["amenity"~"^(school|kindergarten)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["building"="school"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["building"="kindergarten"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                playgrounds: `
                    [out:json][timeout:45];
                    (
                        node["leisure"="playground"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["leisure"="playground"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["leisure"="playground"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                parks: `
                    [out:json][timeout:45];
                    (
                        way["leisure"~"^(park|garden|recreation_ground)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["landuse"~"^(forest|grass|recreation_ground|village_green)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["leisure"~"^(park|garden)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        multipolygon["leisure"~"^(park|garden)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                medical: `
                    [out:json][timeout:45];
                    (
                        node["amenity"~"^(hospital|pharmacy|doctors|clinic)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["amenity"~"^(hospital|pharmacy|doctors|clinic)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["building"~"^(hospital|clinic)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["amenity"~"^(hospital|clinic)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                shopping: `
                    [out:json][timeout:45];
                    (
                        node["shop"~"^(supermarket|convenience|bakery|mall)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["shop"~"^(supermarket|convenience|bakery|mall)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["building"="retail"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["shop"~"^(supermarket|mall)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                sports: `
                    [out:json][timeout:45];
                    (
                        node["leisure"~"^(sports_centre|pitch|stadium|fitness_centre)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["leisure"~"^(sports_centre|pitch|stadium|fitness_centre)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["building"="sports_hall"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        relation["leisure"~"^(sports_centre|stadium)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                transport: `
                    [out:json][timeout:45];
                    (
                        node["public_transport"~"^(stop_position|platform)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        node["highway"="bus_stop"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        node["railway"~"^(station|halt)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["public_transport"="platform"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["railway"="platform"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                highways: `
                    [out:json][timeout:45];
                    (
                        way["highway"~"^(motorway|trunk|primary|secondary)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                residential: `
                    [out:json][timeout:45];
                    (
                        way["highway"~"^(residential|living_street|unclassified|tertiary)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                footways: `
                    [out:json][timeout:45];
                    (
                        way["highway"="footway"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["highway"="path"]["foot"!="no"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["highway"="steps"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["highway"="pedestrian"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `,
                cycleways: `
                    [out:json][timeout:45];
                    (
                        way["highway"="cycleway"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["highway"~"^(path|track)$"]["bicycle"="yes"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                        way["cycleway"~"^(lane|track)$"](${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]});
                    );
                    out geom meta;
                `
            };

            const results = {};
            let completed = 0;
            const total = Object.keys(queries).length;

            for (const [type, query] of Object.entries(queries)) {
                try {
                    updateProgress(completed / total * 100, `Lade ${type}...`);
                    console.log(`🔄 Fetching ${type}...`);
                    
                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        body: query,
                        headers: { 'Content-Type': 'text/plain' }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        results[type] = data.elements || [];
                        
                        console.log(`✅ ${type}: ${results[type].length} elements found`);
                        
                        // Debug: Log first element of each type
                        if (results[type].length > 0) {
                            console.log(`📍 First ${type} element:`, results[type][0]);
                        }
                        
                        // Store in IndexedDB with enhanced metadata
                        const transaction = db.transaction(['osmData'], 'readwrite');
                        const store = transaction.objectStore('osmData');
                        
                        for (const element of results[type]) {
                            // Extract coordinates properly
                            let lat, lng, geometry = null;
                            
                            if (element.type === 'node') {
                                lat = element.lat;
                                lng = element.lon;
                            } else if (element.type === 'way' && element.geometry) {
                                geometry = element.geometry;
                                // Get center point
                                if (geometry.length > 0) {
                                    lat = geometry[Math.floor(geometry.length/2)].lat;
                                    lng = geometry[Math.floor(geometry.length/2)].lon;
                                }
                            } else if (element.center) {
                                lat = element.center.lat;
                                lng = element.center.lon;
                            }
                            
                            const record = {
                                id: `${currentKommune}_${type}_${element.id}`,
                                type: type,
                                kommune: currentKommune,
                                element: element,
                                geometry: geometry,
                                geometryType: element.type, // node, way, relation
                                lat: lat,
                                lng: lng,
                                name: element.tags?.name || getDefaultName(type, element.tags),
                                tags: element.tags || {}
                            };
                            
                            if (lat && lng) {
                                store.put(record);
                            }
                        }
                    } else {
                        console.error(`❌ Failed to fetch ${type}:`, response.status, response.statusText);
                        results[type] = [];
                    }
                    
                    completed++;
                    await new Promise(resolve => setTimeout(resolve, 800)); // Rate limiting - increased delay
                    
                } catch (error) {
                    console.error(`💥 Error fetching ${type}:`, error);
                    results[type] = [];
                    completed++;
                }
            }

            console.log('📊 Final OSM results summary:', Object.entries(results).map(([type, data]) => `${type}: ${data.length}`));
            return results;
        }

        // Get default name for OSM elements
        function getDefaultName(type, tags) {
            const typeNames = {
                schools: tags?.amenity === 'kindergarten' ? 'Kindergarten' : 'Schule',
                playgrounds: 'Spielplatz',
                parks: tags?.leisure === 'garden' ? 'Garten' : 'Park',
                medical: tags?.amenity === 'pharmacy' ? 'Apotheke' : tags?.amenity === 'hospital' ? 'Krankenhaus' : 'Arztpraxis',
                shopping: tags?.shop === 'supermarket' ? 'Supermarkt' : 'Geschäft',
                sports: 'Sportanlage',
                transport: tags?.railway ? 'Bahnhof' : 'Haltestelle'
            };
            return typeNames[type] || type;
        }

        // Project Management Functions will be defined later

        async function saveCurrentProject() {
            if (!currentProjectId || !db) return;
            
            try {
                // Collect all project data
                const projectData = await gatherProjectData();
                
                // Update project in database
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                
                const updatedProject = {
                    ...projectData,
                    id: currentProjectId,
                    lastModified: new Date().toISOString()
                };
                
                store.put(updatedProject);
                
                transaction.oncomplete = () => {
                    console.log('✅ Projekt automatisch gespeichert');
                };
            } catch (error) {
                console.error('❌ Fehler beim Speichern des Projekts:', error);
            }
        }

        async function gatherProjectData() {
            try {
                const transactions = db.transaction(['osmData', 'customMarkers', 'routes', 'gpsTracks'], 'readonly');
                
                // Get all data for current project with proper error handling
                const osmData = await getStoreData(transactions.objectStore('osmData'), 'kommune', currentKommune);
                const customMarkers = await getStoreData(transactions.objectStore('customMarkers'), 'kommune', currentKommune);
                const routes = await getStoreData(transactions.objectStore('routes'), 'projectId', currentProjectId);
                
                // Try to get GPS tracks - handle missing index gracefully
                let gpsTracks = [];
                try {
                    const gpsStore = transactions.objectStore('gpsTracks');
                    // Try projectId index first, fall back to kommune if needed
                    if (gpsStore.indexNames.contains('projectId')) {
                        gpsTracks = await getStoreData(gpsStore, 'projectId', currentProjectId);
                    } else if (gpsStore.indexNames.contains('kommune')) {
                        gpsTracks = await getStoreData(gpsStore, 'kommune', currentKommune);
                    } else {
                        // If no index, get all and filter
                        const allTracks = await getAllFromStore(gpsStore);
                        gpsTracks = allTracks.filter(t => t.projectId === currentProjectId || t.kommune === currentKommune);
                    }
                } catch (err) {
                    console.warn('GPS Tracks konnten nicht geladen werden:', err);
                }
                
                // Get custom drawings (Pinsel-Tool)
                let customDrawings = [];
                try {
                    const drawingStore = transactions.objectStore('customDrawings');
                    if (drawingStore.indexNames.contains('kommune')) {
                        customDrawings = await getStoreData(drawingStore, 'kommune', currentKommune);
                    } else {
                        const allDrawings = await getAllFromStore(drawingStore);
                        customDrawings = allDrawings.filter(d => d.kommune === currentKommune);
                    }
                } catch (err) {
                    console.warn('Custom Drawings konnten nicht geladen werden:', err);
                }
                
                // Include begehung tracks (professional and children routes) - SANITIZED
                const begehungData = sanitizeBegehungTracks(begehungTracks);
                
                return {
                    name: currentProjectName,
                    kommune: currentKommune,
                    created: new Date().toISOString(),
                    osmData: osmData || [],
                    customMarkers: customMarkers || [],
                    routes: routes || [],
                    gpsTracks: gpsTracks || [],
                    customDrawings: customDrawings || [],
                    gpsTrack: gpsTrack || [],
                    begehungTracks: begehungData, // NEU: Begehungsrouten
                    mapCenter: map ? [map.getCenter().lng, map.getCenter().lat] : null,
                    mapZoom: map ? map.getZoom() : null,
                    stats: {
                        totalPOIs: (osmData || []).length,
                        customMarkers: (customMarkers || []).length,
                        savedRoutes: (routes || []).length,
                        gpsTrackPoints: (gpsTrack || []).length,
                        begehungRoutesCount: begehungData.professional.length + begehungData.children.length
                    }
                };
            } catch (error) {
                console.error('Fehler beim Sammeln der Projektdaten:', error);
                // Return minimal data structure
                return {
                    name: currentProjectName,
                    kommune: currentKommune,
                    created: new Date().toISOString(),
                    osmData: [],
                    customMarkers: [],
                    routes: [],
                    gpsTracks: [],
                    gpsTrack: gpsTrack || [],
                    begehungTracks: sanitizeBegehungTracks({ professional: [], children: [] }),
                    mapCenter: map ? [map.getCenter().lng, map.getCenter().lat] : null,
                    mapZoom: map ? map.getZoom() : null,
                    stats: {
                        totalPOIs: 0,
                        customMarkers: 0,
                        savedRoutes: 0,
                        gpsTrackPoints: (gpsTrack || []).length,
                        begehungRoutesCount: 0
                    }
                };
            }
        }
        
        function getAllFromStore(store) {
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        function getStoreData(store, indexName, value) {
            return new Promise((resolve) => {
                const index = store.index(indexName);
                const request = index.getAll(value);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve([]);
            });
        }

        async function loadProject(projectId) {
            try {
                updateProgress(0, 'Lade Projekt...');
                document.getElementById('progress-section').style.display = 'block';
                
                // Reset GPS track and Begehung tracks when loading a project
                gpsTrack = [];
                begehungTracks = { professional: [], children: [] };
                console.log('🔄 GPS Track und Begehung-Tracks beim Projekt-Wechsel zurückgesetzt');
                
                // Get project data
                const transaction = db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                const request = store.get(projectId);
                
                request.onsuccess = () => {
                    const project = request.result;
                    if (!project) {
                        alert('Projekt nicht gefunden!');
                        return;
                    }
                    
                    // Set current project
                    currentProjectId = project.id;
                    currentProjectName = project.name;
                    currentKommune = project.kommune;
                    currentRadius = project.radius || 3;
                    
                    // Restore area bounds if available
                    if (project.areaBounds) {
                        areaBounds = project.areaBounds;
                        console.log('📍 Area bounds restored:', areaBounds);
                    }
                    
                    // Save to localStorage for session persistence
                    localStorage.setItem('lastProject', JSON.stringify({
                        id: project.id,
                        name: project.name,
                        kommune: project.kommune,
                        radius: project.radius,
                        areaBounds: project.areaBounds
                    }));
                    
                    updateProgress(50, 'Starte App...');
                    
                    // Initialize map with project location (we'll geocode it)
                    geocodeKommune(project.kommune).then(location => {
                        if (location) {
                            updateProgress(100, 'Projekt geladen!');
                            
                            setTimeout(() => {
                                // Remove all modal overlays
                                document.querySelectorAll('.modal-overlay').forEach(modal => {
                                    modal.remove();
                                });
                                
                                document.getElementById('setup-screen').style.display = 'none';
                                document.getElementById('app-container').style.display = 'block';
                                
                                initMap(location.lat, location.lng, project.kommune);
                                showToast(`📂 Projekt "${project.name}" geladen!`, 'success');
                            }, 1000);
                        }
                    });
                };
                
            } catch (error) {
                console.error('Fehler beim Laden des Projekts:', error);
                alert(`Fehler beim Laden: ${error.message}`);
            }
        }

        async function exportProject(projectId) {
            try {
                // Get project and all related data
                const projectData = await getFullProjectData(projectId);
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `projekt-${projectData.name.replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('📤 Projekt exportiert!', 'success');
            } catch (error) {
                showToast('❌ Export-Fehler', 'error');
            }
        }

        async function getFullProjectData(projectId) {
            const transaction = db.transaction(['projects', 'osmData', 'customMarkers', 'routes'], 'readonly');
            
            const project = await new Promise(resolve => {
                const request = transaction.objectStore('projects').get(projectId);
                request.onsuccess = () => resolve(request.result);
            });
            
            const osmData = await getStoreData(transaction.objectStore('osmData'), 'kommune', project.kommune);
            const customMarkers = await getStoreData(transaction.objectStore('customMarkers'), 'kommune', project.kommune);
            const routes = await getStoreData(transaction.objectStore('routes'), 'projectId', projectId);
            
            return {
                ...project,
                osmData,
                customMarkers,
                routes,
                exportDate: new Date().toISOString()
            };
        }

        function deleteProject(projectId) {
            if (!confirm('Projekt wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden!')) {
                return;
            }
            
            // Delete project and all related data
            const transaction = db.transaction(['projects', 'customMarkers', 'routes'], 'readwrite');
            
            // Delete project
            transaction.objectStore('projects').delete(projectId);
            
            // Delete related markers (we'll need to find them by projectId if we had that field)
            // For now, we'll keep markers as they might be useful for other analysis
            
            transaction.oncomplete = () => {
                showToast('🗑️ Projekt gelöscht', 'success');
                loadProjectsList();
            };
        }

        // Progress update
        function updateProgress(percent, text) {
            const fill = document.getElementById('progress-fill');
            const textEl = document.getElementById('progress-text');
            
            if (fill) fill.style.width = `${percent}%`;
            if (textEl) textEl.textContent = text;
        }

        // Map styles configuration
        const mapStyles = {
            'Standard': 'mapbox://styles/mapbox/outdoors-v12',
            'Kinderperspektive': 'mapbox://styles/mapbox/streets-v12' // Using streets as base for better 3D buildings
        };
        
        currentMapStyle = localStorage.getItem('preferredMapStyle') || 'Standard';

        // Initialize map with Mapbox
        function initMap(lat, lng, name) {
            mapboxgl.accessToken = 'pk.eyJ1IjoidGlsbGl2YW5pbGxpNDQ0IiwiYSI6ImNtZHhsb3h4cDFqaTgyanF3YWQxa3Uybm0ifQ.oKAuIpFBkhS1ltzLvyN85w';

            // Reset GPS track when loading new map
            gpsTrack = [];
            console.log('🔄 GPS Track zurückgesetzt');

            // Special settings for Kinderperspektive style
            const isKinderperspektive = currentMapStyle === 'Kinderperspektive';
            
            map = new mapboxgl.Map({
                container: 'map',
                style: mapStyles[currentMapStyle],
                center: [lng, lat],
                zoom: isKinderperspektive ? 16 : 14,
                pitch: isKinderperspektive ? 45 : 0, // 2.5D perspective
                bearing: isKinderperspektive ? 35 : 0, // Isometric-like angle
                antialias: true // Better rendering for 3D
            });

            map.on('load', () => {
                // Style switcher is now in bottom bar, no need for the old one
                // addStyleSwitcher(); - Removed
                
                // Apply Kinderperspektive effects if active
                if (isKinderperspektive) {
                    applyKinderperspektiveEffects();
                }
                // Update project name display
                document.getElementById('project-name-display').textContent = `📂 ${currentProjectName || currentKommune}`;
                
                loadOSMDataToMap();
                loadCustomMarkers();
                loadSavedRoutes();
                loadDrawnPaths(); // Load saved drawings
                updateStats();
                startGPSTracking();
                setupMapClickHandlers();
                
                // CRITICAL FIX: Check for previous Begehung session BEFORE loading saved tracks
                // This prevents race conditions where IndexedDB data overwrites session data
                checkForPreviousSession();
                
                // Load saved begehungen AFTER session restore (will append, not overwrite)
                setTimeout(() => {
                    loadSavedBegehungen();
                    console.log('📊 Session restore + IndexedDB load completed');
                }, 100); // Small delay to ensure session restore completes first
                
                // Initialize search after data is loaded
                setTimeout(() => {
                    buildSearchIndex();
                    initializeSearch();
                }, 1000);
            });
        }

        // Load OSM data to map with proper polygon rendering
        async function loadOSMDataToMap() {
            if (!db || !currentKommune) return;
            
            // Wait for style to be loaded
            if (!map.isStyleLoaded()) {
                setTimeout(() => loadOSMDataToMap(), 100);
                return;
            }
            
            const transaction = db.transaction(['osmData'], 'readonly');
            const store = transaction.objectStore('osmData');
            const request = store.getAll();

            request.onsuccess = () => {
                const allData = request.result;
                // FILTER: Only load data for current kommune
                const data = allData.filter(item => item.kommune === currentKommune);
                
                console.log(`📍 Loading ${data.length} items for ${currentKommune}`);
                
                // Group by type
                const groupedData = {};
                data.forEach(item => {
                    if (!groupedData[item.type]) groupedData[item.type] = [];
                    groupedData[item.type].push(item);
                });

                // Add each type as a source and layer
                Object.entries(groupedData).forEach(([type, items]) => {
                    if (items.length === 0) return;

                    const polygons = [];
                    const lines = [];
                    const points = [];

                    items.forEach(item => {
                        if (item.geometry && item.geometry.length > 0) {
                            const coordinates = item.geometry.map(node => [node.lon, node.lat]);
                            
                            // Handle different geometry types
                            if (['highways', 'residential', 'footways', 'cycleways'].includes(type)) {
                                // Street/path data as lines
                                lines.push({
                                    type: 'Feature',
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: coordinates
                                    },
                                    properties: {
                                        ...item,
                                        color: getColorForType(type),
                                        width: getWidthForType(type, item.tags),
                                        style: getStyleForType(type)
                                    }
                                });
                            } else if (coordinates.length > 2) {
                                // Building/area data as polygons
                                // Close polygon if not closed
                                if (coordinates[0][0] !== coordinates[coordinates.length-1][0] || 
                                    coordinates[0][1] !== coordinates[coordinates.length-1][1]) {
                                    coordinates.push(coordinates[0]);
                                }
                                
                                polygons.push({
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [coordinates]
                                    },
                                    properties: {
                                        ...item,
                                        color: getColorForType(type),
                                        fillColor: getFillColorForType(type)
                                    }
                                });
                            }
                        } else if (item.lat && item.lng) {
                            // Point geometry
                            points.push({
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [item.lng, item.lat]
                                },
                                properties: {
                                    ...item,
                                    color: getColorForType(type)
                                }
                            });
                        }
                    });

                    // Add polygon layer if we have polygons
                    if (polygons.length > 0) {
                        map.addSource(`${type}-polygons`, {
                            type: 'geojson',
                            data: {
                                type: 'FeatureCollection',
                                features: polygons
                            }
                        });

                        map.addLayer({
                            id: `${type}-fill`,
                            type: 'fill',
                            source: `${type}-polygons`,
                            paint: {
                                'fill-color': ['get', 'fillColor'],
                                'fill-opacity': 0.7
                            },
                            layout: {
                                'visibility': getInitialVisibility(type)
                            }
                        });

                        map.addLayer({
                            id: `${type}-line`,
                            type: 'line',
                            source: `${type}-polygons`,
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': 2,
                                'line-opacity': 0.9
                            },
                            layout: {
                                'visibility': getInitialVisibility(type)
                            }
                        });

                        // Click handler for polygons
                        map.on('click', `${type}-fill`, (e) => {
                            showOSMPopup(e.features[0], e.lngLat);
                        });
                    }

                    // Add line layer if we have lines (streets)
                    if (lines.length > 0) {
                        // Check if layer/source already exists - remove layer first, then source
                        if (map.getLayer(`${type}-streets`)) {
                            map.removeLayer(`${type}-streets`);
                        }
                        if (map.getSource(`${type}-lines`)) {
                            map.removeSource(`${type}-lines`);
                        }
                        
                        map.addSource(`${type}-lines`, {
                            type: 'geojson',
                            data: {
                                type: 'FeatureCollection',
                                features: lines
                            }
                        });

                        map.addLayer({
                            id: `${type}-streets`,
                            type: 'line',
                            source: `${type}-lines`,
                            paint: {
                                'line-color': ['get', 'color'],
                                'line-width': ['get', 'width'],
                                'line-opacity': 0.8
                            },
                            layout: {
                                'line-cap': 'round',
                                'line-join': 'round',
                                'visibility': getInitialVisibility(type)
                            }
                        });

                        // Click handler for streets
                        map.on('click', `${type}-streets`, (e) => {
                            showStreetPopup(e.features[0], e.lngLat);
                        });
                    }

                    // Add point layer if we have points
                    if (points.length > 0) {
                        map.addSource(`${type}-points`, {
                            type: 'geojson',
                            data: {
                                type: 'FeatureCollection',
                                features: points
                            }
                        });

                        map.addLayer({
                            id: `${type}-circles`,
                            type: 'circle',
                            source: `${type}-points`,
                            paint: {
                                'circle-radius': getRadiusForType(type),
                                'circle-color': ['get', 'color'],
                                'circle-stroke-width': 2,
                                'circle-stroke-color': '#ffffff',
                                'circle-opacity': 0.8
                            },
                            layout: {
                                'visibility': getInitialVisibility(type)
                            }
                        });

                        // Click handler for points
                        map.on('click', `${type}-circles`, (e) => {
                            showOSMPopup(e.features[0], e.lngLat);
                        });
                    }

                    // Mouse cursor handling
                    [`${type}-fill`, `${type}-circles`, `${type}-streets`].forEach(layerId => {
                        if (map.getLayer(layerId)) {
                            map.on('mouseenter', layerId, () => {
                                map.getCanvas().style.cursor = 'pointer';
                            });

                            map.on('mouseleave', layerId, () => {
                                map.getCanvas().style.cursor = '';
                            });
                        }
                    });
                });

                updateStats();
                
                // Rebuild search index after loading new data
                setTimeout(() => {
                    buildSearchIndex();
                    console.log('🔍 Search index updated after loading OSM data');
                }, 500);
            };
        }

        // Get colors for different types
        function getColorForType(type) {
            const colors = {
                schools: '#ff69b4',
                playgrounds: '#00ff80',
                parks: '#32cd32',
                medical: '#ff6b6b',
                shopping: '#4ecdc4',
                sports: '#45b7d1',
                transport: '#96ceb4',
                highways: '#ff4444',
                residential: '#ffdd00',
                footways: '#44ff44',
                cycleways: '#4488ff'
            };
            return colors[type] || '#ffffff';
        }

        function getFillColorForType(type) {
            const colors = {
                schools: 'rgba(255, 105, 180, 0.4)',
                playgrounds: 'rgba(0, 255, 128, 0.4)',
                parks: 'rgba(50, 205, 50, 0.4)',
                medical: 'rgba(255, 107, 107, 0.4)',
                shopping: 'rgba(78, 205, 196, 0.4)',
                sports: 'rgba(69, 183, 209, 0.4)',
                transport: 'rgba(150, 206, 180, 0.4)'
            };
            return colors[type] || 'rgba(255, 255, 255, 0.25)';
        }

        function getRadiusForType(type) {
            const radii = {
                schools: 10,
                playgrounds: 8,
                parks: 6,
                medical: 8,
                shopping: 6,
                sports: 8,
                transport: 5
            };
            return radii[type] || 6;
        }

        function getWidthForType(type, tags) {
            const baseWidths = {
                highways: 6,
                residential: 3,
                footways: 2,
                cycleways: 2
            };
            
            let width = baseWidths[type] || 2;
            
            // Adjust based on lanes
            if (tags && tags.lanes) {
                const lanes = parseInt(tags.lanes);
                if (lanes > 2) width += (lanes - 2) * 1.5;
            }
            
            return width;
        }

        function getStyleForType(type) {
            const styles = {
                highways: 'solid',
                residential: 'solid', 
                footways: 'dotted',
                cycleways: 'dashed'
            };
            return styles[type] || 'solid';
        }

        function getInitialVisibility(type) {
            // Set initial visibility based on UI state
            const activeByDefault = ['schools', 'playgrounds', 'parks', 'medical'];
            return activeByDefault.includes(type) ? 'visible' : 'none';
        }

        // Show street popup with traffic information
        function showStreetPopup(feature, lngLat) {
            const props = feature.properties;
            const streetType = getStreetTypeName(props.type, props.tags);
            const dangerLevel = getDangerLevel(props.type, props.tags);
            
            const popupContent = `
                <div class="popup-content">
                    <h3>🛣️ ${props.name || streetType}</h3>
                    <div class="info-grid">
                        <div class="info-row">
                            <span class="info-label">Typ:</span>
                            <span>${streetType}</span>
                        </div>
                        ${props.tags.maxspeed ? `
                        <div class="info-row">
                            <span class="info-label">Tempolimit:</span>
                            <span>${props.tags.maxspeed} km/h</span>
                        </div>` : ''}
                        ${props.tags.lanes ? `
                        <div class="info-row">
                            <span class="info-label">Spuren:</span>
                            <span>${props.tags.lanes}</span>
                        </div>` : ''}
                        ${props.tags.sidewalk ? `
                        <div class="info-row">
                            <span class="info-label">Gehwege:</span>
                            <span>${getSidewalkInfo(props.tags.sidewalk)}</span>
                        </div>` : ''}
                        ${props.tags.lit ? `
                        <div class="info-row">
                            <span class="info-label">Beleuchtung:</span>
                            <span>${props.tags.lit === 'yes' ? '✅ Vorhanden' : '❌ Keine'}</span>
                        </div>` : ''}
                        <div class="info-row">
                            <span class="info-label">Kinder-Sicherheit:</span>
                            <span style="color: ${dangerLevel.color}">${dangerLevel.text}</span>
                        </div>
                    </div>
                    <button class="popup-btn" onclick="reportStreetProblem('${props.id}')">
                        ⚠️ Problem melden
                    </button>
                </div>
            `;
            
            new mapboxgl.Popup()
                .setLngLat(lngLat)
                .setHTML(popupContent)
                .addTo(map);
        }

        function getStreetTypeName(type, tags) {
            const typeNames = {
                highways: tags?.highway === 'primary' ? 'Hauptstraße' : tags?.highway === 'secondary' ? 'Landstraße' : 'Schnellstraße',
                residential: tags?.highway === 'living_street' ? 'Spielstraße' : 'Wohnstraße',
                footways: tags?.highway === 'steps' ? 'Treppe' : 'Gehweg',
                cycleways: 'Fahrradweg'
            };
            return typeNames[type] || 'Straße';
        }

        function getDangerLevel(type, tags) {
            const maxspeed = tags?.maxspeed ? parseInt(tags.maxspeed) : null;
            
            if (type === 'footways') {
                return { color: '#44ff44', text: '✅ Sehr sicher' };
            } else if (type === 'cycleways') {
                return { color: '#4488ff', text: '✅ Sicher für ältere Kinder' };
            } else if (type === 'residential') {
                if (maxspeed && maxspeed <= 30) {
                    return { color: '#ffdd00', text: '⚠️ Tempo-30-Zone' };
                }
                return { color: '#ff8800', text: '⚠️ Vorsicht' };
            } else if (type === 'highways') {
                return { color: '#ff4444', text: '❌ Gefährlich für Kinder' };
            }
            
            return { color: '#ffffff', text: 'Unbekannt' };
        }

        function getSidewalkInfo(sidewalk) {
            const info = {
                'both': 'Beide Seiten',
                'left': 'Nur links',
                'right': 'Nur rechts',
                'no': 'Keine Gehwege',
                'none': 'Keine Gehwege'
            };
            return info[sidewalk] || sidewalk;
        }

        // Show OSM popup with better information
        function showOSMPopup(feature, lngLat) {
            const props = feature.properties;
            
            const popupContent = `
                <div class="popup-content">
                    <h3>${getIconForType(props.type)} ${props.name}</h3>
                    <div class="info-grid">
                        <div class="info-row">
                            <span class="info-label">Typ:</span>
                            <span>${getTypeDisplayName(props.type, props.tags)}</span>
                        </div>
                        ${props.tags.opening_hours ? `
                        <div class="info-row">
                            <span class="info-label">Öffnungszeiten:</span>
                            <span>${props.tags.opening_hours}</span>
                        </div>` : ''}
                        ${props.tags.phone ? `
                        <div class="info-row">
                            <span class="info-label">Telefon:</span>
                            <span>${props.tags.phone}</span>
                        </div>` : ''}
                        ${props.tags.website ? `
                        <div class="info-row">
                            <span class="info-label">Website:</span>
                            <span><a href="${props.tags.website}" target="_blank">Link</a></span>
                        </div>` : ''}
                    </div>
                    <button class="popup-btn" onclick="addReviewToPlace('${props.id}')">
                        ⭐ Bewerten & Kommentieren
                    </button>
                </div>
            `;
            
            new mapboxgl.Popup()
                .setLngLat(lngLat)
                .setHTML(popupContent)
                .addTo(map);
        }

        function getTypeDisplayName(type, tags) {
            const typeNames = {
                schools: tags?.amenity === 'kindergarten' ? 'Kindergarten' : 'Schule',
                playgrounds: 'Spielplatz',
                parks: tags?.leisure === 'garden' ? 'Garten' : tags?.landuse === 'forest' ? 'Wald' : 'Park',
                medical: tags?.amenity === 'pharmacy' ? 'Apotheke' : tags?.amenity === 'hospital' ? 'Krankenhaus' : 'Arztpraxis',
                shopping: tags?.shop === 'supermarket' ? 'Supermarkt' : tags?.shop === 'bakery' ? 'Bäckerei' : 'Geschäft',
                sports: tags?.leisure === 'pitch' ? 'Sportplatz' : 'Sportzentrum',
                transport: tags?.railway ? 'Bahnhof' : 'Bushaltestelle'
            };
            return typeNames[type] || type;
        }

        // Get icon for type
        function getIconForType(type) {
            const icons = {
                schools: '🏫',
                playgrounds: '🎮',
                parks: '🌳',
                medical: '🏥',
                shopping: '🛒',
                sports: '⚽',
                transport: '🚌'
            };
            return icons[type] || '📍';
        }
        
        function getIconForOSMType(type) {
            const icons = {
                // Places
                'city': '🏙️',
                'town': '🏘️',
                'village': '🏡',
                'hamlet': '🏚️',
                'suburb': '🏘️',
                'neighbourhood': '🏘️',
                
                // Buildings
                'house': '🏠',
                'residential': '🏢',
                'apartments': '🏢',
                'commercial': '🏪',
                'industrial': '🏭',
                'retail': '🛍️',
                
                // Amenities
                'restaurant': '🍽️',
                'cafe': '☕',
                'fast_food': '🍔',
                'bar': '🍺',
                'pub': '🍻',
                'school': '🏫',
                'kindergarten': '🎒',
                'university': '🎓',
                'hospital': '🏥',
                'pharmacy': '💊',
                'bank': '🏦',
                'atm': '💳',
                'fuel': '⛽',
                'parking': '🅿️',
                'police': '👮',
                'fire_station': '🚒',
                'post_office': '📮',
                'library': '📚',
                'cinema': '🎬',
                'theatre': '🎭',
                'museum': '🏛️',
                
                // Shopping
                'supermarket': '🛒',
                'convenience': '🏪',
                'bakery': '🥖',
                'butcher': '🥩',
                'clothes': '👕',
                'hairdresser': '💇',
                
                // Transport
                'bus_stop': '🚏',
                'railway_station': '🚉',
                'tram_stop': '🚋',
                'airport': '✈️',
                'ferry_terminal': '⛴️',
                
                // Leisure
                'park': '🌳',
                'playground': '🎮',
                'sports_centre': '🏟️',
                'swimming_pool': '🏊',
                'stadium': '🏟️',
                
                // Natural
                'forest': '🌲',
                'water': '💧',
                'peak': '🏔️',
                'beach': '🏖️',
                
                // Roads
                'motorway': '🛣️',
                'primary': '🛣️',
                'secondary': '🛤️',
                'road': '🛤️',
                'footway': '🚶',
                'cycleway': '🚴',
                'path': '🥾'
            };
            return icons[type] || icons[type?.split('_')[0]] || '📍';
        }

        // GPS tracking with trail - iOS/Android optimized
        function startGPSTracking() {
            // Check if page is served over HTTPS (required for geolocation on iOS)
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                console.warn('⚠️ GPS requires HTTPS! Current protocol:', location.protocol);
                showToast('⚠️ GPS benötigt HTTPS-Verbindung!', 'warning');
            }

            if (!navigator.geolocation) {
                console.error('❌ Geolocation API not available');
                showToast('❌ GPS nicht verfügbar auf diesem Gerät', 'error');
                document.getElementById('gps-text').textContent = 'GPS fehlt';
                return;
            }

            // Only show GPS as available, don't request position automatically
            console.log('📍 GPS available, waiting for user action...');
            document.getElementById('gps-text').textContent = 'GPS bereit';
            document.querySelector('.gps-dot').style.background = '#ffdd00';
            
            // GPS will be activated when user clicks position button
        }

        function handleGPSSuccess(position) {
            console.log('✅ GPS permission granted, position received');
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            // Update initial position
            updateUserLocation(lat, lng);
            document.getElementById('header-location').textContent = 
                `📍 ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            document.getElementById('gps-text').textContent = 'GPS ✓';
            document.querySelector('.gps-dot').style.background = '#00ff80';
            
            // NO general GPS track - only track during Begehung
            
            // Now start continuous tracking
            startContinuousTracking();
            
            // Don't fly to location automatically - only when user clicks position button
        }

        function startContinuousTracking() {
            // Different options for iOS vs Android
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            
            const watchOptions = {
                enableHighAccuracy: true,
                timeout: isIOS ? 20000 : 20000, // Increased Android timeout to 20s
                maximumAge: isAndroid ? 5000 : 1000 // Allow older positions on Android for faster response
            };

            console.log('🔄 Starting continuous GPS tracking (Platform: ' + (isIOS ? 'iOS' : isAndroid ? 'Android' : 'Other') + ')');

            const watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    console.log(`📍 GPS Update: ${lat.toFixed(6)}, ${lng.toFixed(6)} (±${accuracy.toFixed(0)}m)`);
                    
                    // Store current position for Begehung use
                    userLocation = { lat, lng, accuracy };
                    
                    // Update user marker
                    updateUserLocation(lat, lng);
                    
                    // NO GPS trail unless begehung is active
                    // GPS trail is drawn only during Begehung (red/yellow)
                    
                    // Update header
                    document.getElementById('header-location').textContent = 
                        `📍 ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
                    
                    // Show GPS as active
                    document.getElementById('gps-text').textContent = 'GPS ✓';
                    document.querySelector('.gps-dot').style.background = '#00ff80';
                },
                (error) => {
                    console.warn('Watch position error:', error);
                    // Don't call full error handler for watch errors
                    // Just log them as GPS might recover
                },
                watchOptions
            );

            // Store watch ID globally for cleanup
            gpsWatchId = watchId;
        }

        function handleGPSError(error) {
            console.error('❌ GPS Error:', error.code, error.message);
            
            let errorMessage = 'GPS-Fehler';
            let toastMessage = '';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = 'GPS verweigert';
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    const isAndroid = /Android/.test(navigator.userAgent);
                    
                    if (isIOS) {
                        toastMessage = '❌ Standortzugriff verweigert. Einstellungen → Chrome → Standort aktivieren';
                        showIOSPermissionInstructions();
                    } else if (isAndroid) {
                        toastMessage = '❌ Standortzugriff verweigert. Browser-Einstellungen → Berechtigungen → Standort aktivieren';
                        showAndroidPermissionInstructions();
                    } else {
                        toastMessage = '❌ Bitte Standortzugriff in Browser-Einstellungen erlauben';
                    }
                    break;
                    
                case error.POSITION_UNAVAILABLE:
                    errorMessage = 'GPS aus';
                    toastMessage = '⚠️ GPS nicht verfügbar. Bitte Standortdienste aktivieren.';
                    break;
                    
                case error.TIMEOUT:
                    errorMessage = 'GPS Timeout';
                    toastMessage = '⏱️ GPS-Timeout. Versuche es erneut...';
                    // Retry with lower accuracy
                    retryGPSWithLowerAccuracy();
                    break;
                    
                default:
                    errorMessage = 'GPS-Fehler';
                    toastMessage = '❌ GPS-Fehler: ' + error.message;
            }
            
            document.getElementById('gps-text').textContent = errorMessage;
            document.querySelector('.gps-dot').style.background = '#ff4060';
            
            if (toastMessage) {
                showToast(toastMessage, 'error');
            }
        }

        function showAndroidPermissionInstructions() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal">
                    <h2>📍 GPS-Berechtigung erforderlich</h2>
                    <div style="text-align: left; margin: 20px 0;">
                        <p style="margin-bottom: 15px;"><strong>Für Android:</strong></p>
                        
                        <ol style="line-height: 1.8; color: #ccc;">
                            <li>Tippe auf das <strong>🔒 Schloss-Symbol</strong> in der Adressleiste</li>
                            <li>Wähle <strong>Berechtigungen</strong></li>
                            <li>Aktiviere <strong>Standort</strong></li>
                            <li>Lade die Seite neu</li>
                        </ol>
                        
                        <p style="margin-top: 15px;"><strong>Alternative:</strong></p>
                        <ol style="line-height: 1.8; color: #ccc;">
                            <li>Android <strong>Einstellungen</strong> öffnen</li>
                            <li><strong>Apps</strong> → <strong>Chrome</strong></li>
                            <li><strong>Berechtigungen</strong> → <strong>Standort</strong></li>
                            <li>Wähle <strong>"Nur während App-Nutzung zulassen"</strong></li>
                        </ol>
                        
                        <p style="font-size: 13px; color: #888; margin-top: 15px;">
                            Stelle sicher dass:
                            <br>• GPS/Standort in Android aktiviert ist
                            <br>• Flugmodus deaktiviert ist
                            <br>• Du draußen oder am Fenster bist (für GPS-Signal)
                        </p>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn primary" onclick="this.closest('.modal-overlay').remove(); location.reload();">
                            🔄 Seite neu laden
                        </button>
                        <button class="btn secondary" onclick="this.closest('.modal-overlay').remove()">
                            Später
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function retryGPSWithLowerAccuracy() {
            console.log('🔄 Retrying GPS with lower accuracy...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('✅ GPS working with lower accuracy');
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    updateUserLocation(lat, lng);
                    document.getElementById('header-location').textContent = 
                        `📍 ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
                    document.getElementById('gps-text').textContent = 'GPS aktiv (niedrige Genauigkeit)';
                    document.querySelector('.gps-dot').style.background = '#ffdd00';
                },
                (error) => {
                    console.error('❌ GPS still failing:', error);
                },
                {
                    enableHighAccuracy: false,
                    timeout: 30000,
                    maximumAge: 60000
                }
            );
        }

        function showIOSPermissionInstructions() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal">
                    <h2>📍 GPS-Berechtigung erforderlich</h2>
                    <div style="text-align: left; margin: 20px 0;">
                        <p style="margin-bottom: 15px;"><strong>Für iPad/iPhone in Chrome:</strong></p>
                        
                        <ol style="line-height: 1.8; color: #ccc;">
                            <li>Öffne die <strong>Einstellungen</strong> App</li>
                            <li>Scrolle zu <strong>Chrome</strong></li>
                            <li>Tippe auf <strong>Standort</strong></li>
                            <li>Wähle <strong>"Beim Verwenden der App"</strong></li>
                            <li>Kehre zu Chrome zurück und lade die Seite neu</li>
                        </ol>
                        
                        <div style="background: rgba(255,128,0,0.2); border: 1px solid var(--warning); border-radius: 8px; padding: 12px; margin: 20px 0;">
                            <p style="margin: 0; font-size: 13px;">
                                <strong>⚠️ Wichtig:</strong> Die Seite muss über HTTPS geladen werden, 
                                damit GPS auf iOS funktioniert. Verwende https:// in der URL.
                            </p>
                        </div>
                        
                        <p style="font-size: 13px; color: #888;">
                            Falls GPS weiterhin nicht funktioniert, prüfe ob:
                            <br>• Ortungsdienste generell aktiviert sind
                            <br>• Flugmodus deaktiviert ist
                            <br>• Die Seite über HTTPS geladen wird
                        </p>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn primary" onclick="this.closest('.modal-overlay').remove(); retryGPSAfterSettings();">
                            🔄 Erneut versuchen
                        </button>
                        <button class="btn secondary" onclick="this.closest('.modal-overlay').remove()">
                            Später
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function retryGPSAfterSettings() {
            console.log('🔄 Retrying GPS after settings change...');
            // Clear any existing watch
            if (gpsWatchId) {
                navigator.geolocation.clearWatch(gpsWatchId);
                gpsWatchId = null;
            }
            // Start fresh
            startGPSTracking();
        }

        // Enhanced Begehungs-GPS for iOS
        function startBegehung() {
            if (begehungActive) {
                stopBegehung();
                return;
            }

            if (!navigator.geolocation) {
                showToast('❌ GPS nicht verfügbar!', 'error');
                return;
            }

            // Check HTTPS
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                if (!confirm('⚠️ GPS funktioniert möglicherweise nicht über HTTP. Trotzdem fortfahren?')) {
                    return;
                }
            }

            begehungActive = true;
            begehungStartTime = Date.now();
            begehungTrack = [];
            begehungDistance = 0;
            begehungMarkers = [];
            lastBegehungPosition = null;

            // UI Updates
            document.getElementById('begehung-indicator').classList.add('active');
            document.getElementById('quick-action-bar').classList.add('active');
            document.getElementById('begehung-btn').classList.add('active');
            
            // Start Timer
            updateBegehungTimer();
            begehungTimer = setInterval(updateBegehungTimer, 1000);

            // iOS-optimized GPS tracking for Begehung
            console.log('🚶 Starting Begehung GPS tracking...');
            
            // First get current position
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('✅ Begehung GPS initialized');
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    begehungTrack.push({
                        lat: lat,
                        lng: lng,
                        timestamp: Date.now(),
                        accuracy: position.coords.accuracy
                    });
                    
                    lastBegehungPosition = { lat, lng };
                    updateBegehungTrack();
                    
                    // Now start continuous tracking
                    startBegehungContinuousTracking();
                },
                (error) => {
                    console.error('❌ Begehung GPS initialization failed:', error);
                    showToast('❌ GPS nicht verfügbar. Bitte GPS aktivieren!', 'error');
                    stopBegehung();
                    return;
                },
                {
                    enableHighAccuracy: false,
                    timeout: 10000,
                    maximumAge: 0
                }
            );

            showToast('🚶 Begehung gestartet! GPS-Tracking aktiv.', 'success');
        }

        function startBegehungContinuousTracking() {
            // iOS-friendly options with fallbacks
            const options = [
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 },
                { enableHighAccuracy: false, timeout: 10000, maximumAge: 1000 },
                { enableHighAccuracy: false, timeout: 20000, maximumAge: 5000 }
            ];
            
            let optionIndex = 0;
            
            function tryNextOption() {
                if (optionIndex >= options.length) {
                    console.error('❌ All GPS options failed');
                    showToast('⚠️ GPS nicht verfügbar. Positionen müssen manuell gesetzt werden.', 'warning');
                    return;
                }
                
                const currentOptions = options[optionIndex];
                console.log('🔄 Trying GPS options:', currentOptions);
                
                begehungWatchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        const accuracy = position.coords.accuracy;
                        const currentTime = Date.now();

                        // Only record if accuracy is reasonable (< 100 meters for iOS/iPad indoor)
                        // Increased from 50m to 100m for better iPad indoor tracking
                        if (accuracy < 100) {
                            let isJump = false;
                            
                            // Check for GPS jump (>100m or >30 seconds gap)
                            if (lastBegehungPosition) {
                                const distance = calculateDistanceBetweenPoints(
                                    lastBegehungPosition.lat,
                                    lastBegehungPosition.lng,
                                    lat,
                                    lng
                                );
                                const timeDiff = currentTime - (lastBegehungPosition.timestamp || currentTime);
                                
                                // GPS jump detected
                                if (distance > 0.1 || timeDiff > 30000) { // 100m or 30 seconds
                                    isJump = true;
                                    console.log(`⚠️ GPS jump detected: ${distance.toFixed(3)}km, ${timeDiff}ms`);
                                }
                                
                                // Only add to distance if not a jump
                                if (!isJump && distance <= 0.1) {
                                    begehungDistance += distance;
                                    document.getElementById('begehung-distance').textContent = formatDistance(begehungDistance);
                                }
                            }
                            
                            // Always add point to preserve complete route
                            begehungTrack.push({
                                lat: lat,
                                lng: lng,
                                timestamp: currentTime,
                                accuracy: accuracy,
                                isJump: isJump // Mark if this was a jump
                            });
                            
                            lastBegehungPosition = { lat, lng, timestamp: currentTime };
                            
                            // Log for debugging iPad issues
                            console.log(`📍 GPS Update - Accuracy: ${accuracy.toFixed(1)}m, Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`);

                            // Update track on map
                            updateBegehungTrack();
                            
                            // Auto-save every 10 points
                            if (begehungTrack.length % 10 === 0) {
                                autoSaveBegehung();
                            }
                        } else {
                            // Log rejected positions for debugging
                            console.log(`⚠️ GPS position rejected - Accuracy too low: ${accuracy.toFixed(1)}m (threshold: 100m)`);
                        }
                    },
                    (error) => {
                        console.error(`❌ GPS Error with option ${optionIndex}:`, error);
                        navigator.geolocation.clearWatch(begehungWatchId);
                        optionIndex++;
                        
                        // Try next option after a short delay
                        setTimeout(tryNextOption, 1000);
                    },
                    currentOptions
                );
            }
            
            tryNextOption();
        }

        // REMOVED: updateGPSTrack function - GPS trails are now only drawn during Begehung
        // GPS trail colors: Red for Fachkräfte, Yellow for Kinder
        // No general GPS tracking trail anymore
        
        // Toggle Sidebar function
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mapContainer = document.querySelector('.map-container');
            const toggleIcon = document.getElementById('toggleIcon');
            
            sidebar.classList.toggle('collapsed');
            mapContainer.classList.toggle('expanded');
            
            if (sidebar.classList.contains('collapsed')) {
                toggleIcon.textContent = '▲';
            } else {
                toggleIcon.textContent = '▼';
            }
            
            // Resize map after animation
            setTimeout(() => {
                if (window.map) {
                    map.resize();
                }
            }, 300);
        }
        
        // Auto-collapse on mobile on load
        document.addEventListener('DOMContentLoaded', () => {
            if (window.innerWidth <= 768) {
                setTimeout(() => {
                    const sidebar = document.getElementById('sidebar');
                    const mapContainer = document.querySelector('.map-container');
                    const toggleIcon = document.getElementById('toggleIcon');
                    
                    if (sidebar) {
                        sidebar.classList.add('collapsed');
                        mapContainer.classList.add('expanded');
                        toggleIcon.textContent = '▲';
                    }
                }, 100);
            }
        });


        // Map click handlers for tools
        function setupMapClickHandlers() {
            map.on('click', (e) => {
                // Only handle tool clicks if a tool is active
                if (currentTool) {
                    switch (currentTool) {
                        case 'marker':
                            showAddMarkerModal(e.lngLat.lat, e.lngLat.lng);
                            break;
                        case 'photo':
                            showPhotoModal(e.lngLat.lat, e.lngLat.lng);
                            break;
                        case 'note':
                            showNoteModal(e.lngLat.lat, e.lngLat.lng, noteToPlace);
                            break;
                    case 'measure':
                        handleMeasureClick(e.lngLat);
                        break;
                    case 'street':
                        handleStreetClick(e.lngLat);
                        break;
                    }
                    // Reset cursor and tool after handling
                    currentTool = null;
                    noteToPlace = null;
                    map.getCanvas().style.cursor = '';
                }
            });
        }

        // Note modal function
        function showNoteModal(lat, lng) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal">
                    <h2>📝 Neue Notiz</h2>
                    <form id="note-form">
                        <div class="input-group">
                            <label for="note-title">Titel *</label>
                            <input type="text" id="note-title" required placeholder="z.B. Wichtige Beobachtung">
                        </div>
                        
                        <div class="input-group">
                            <label for="note-text">Notiz *</label>
                            <textarea id="note-text" required placeholder="Beschreibe deine Beobachtungen..." rows="5" style="width: 100%; padding: 10px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; color: white; resize: vertical;"></textarea>
                        </div>
                        
                        <div class="input-group">
                            <label for="note-priority">Priorität</label>
                            <select id="note-priority" style="width: 100%; padding: 10px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; color: white;">
                                <option value="low">📗 Niedrig</option>
                                <option value="medium" selected>📙 Mittel</option>
                                <option value="high">📕 Hoch</option>
                                <option value="urgent">🚨 Dringend</option>
                            </select>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px;">
                            <button type="submit" class="btn primary">📝 Notiz speichern</button>
                            <button type="button" class="btn secondary" onclick="this.closest('.modal-overlay').remove()">Abbrechen</button>
                        </div>
                    </form>
                </div>
            `;

            document.body.appendChild(modal);

            modal.querySelector('#note-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const title = modal.querySelector('#note-title').value.trim();
                const text = modal.querySelector('#note-text').value.trim();
                const priority = modal.querySelector('#note-priority').value;
                
                const marker = {
                    id: 'note_' + Date.now(),
                    type: 'note',
                    title,
                    category: 'note',
                    description: text,
                    priority,
                    lat,
                    lng,
                    timestamp: new Date().toISOString(),
                    kommune: currentKommune,
                    projectId: currentProjectId,
                    synced: false
                };
                
                // Save to IndexedDB
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.add(marker);
                
                transaction.oncomplete = () => {
                    loadCustomMarkers();
                    updateStats();
                    buildSearchIndex(); // Update search index
                    modal.remove();
                    currentTool = null;
                    updateToolButtons();
                    map.getCanvas().style.cursor = '';
                    
                    // Auto-save project
                    saveCurrentProject();
                    
                    showToast('📝 Notiz gespeichert!', 'success');
                };
            });
        }

        // Update statistics
        function updateStats() {
            if (!db || !currentKommune) return;

            const transaction = db.transaction(['osmData', 'customMarkers'], 'readonly');
            
            // Count OSM data - ONLY for current kommune
            const osmStore = transaction.objectStore('osmData');
            const osmRequest = osmStore.getAll();
            
            osmRequest.onsuccess = () => {
                const allData = osmRequest.result;
                // FILTER: Only count data for current kommune
                const data = allData.filter(item => item.kommune === currentKommune);
                const counts = {};
                
                data.forEach(item => {
                    counts[item.type] = (counts[item.type] || 0) + 1;
                    
                    // Separate schools and kitas
                    if (item.type === 'schools') {
                        const tags = item.tags || {};
                        if (tags.amenity === 'kindergarten' || tags.name?.toLowerCase().includes('kita') || 
                            tags.name?.toLowerCase().includes('kindergarten')) {
                            counts.kitas = (counts.kitas || 0) + 1;
                            counts.schools = (counts.schools || 1) - 1;
                        }
                    }
                });
                
                console.log(`📊 Stats for ${currentKommune}:`, counts);

                // Update separate school and kita counts
                if (document.getElementById('school-count')) {
                    document.getElementById('school-count').textContent = counts.schools || 0;
                }
                if (document.getElementById('kitas-count')) {
                    document.getElementById('kitas-count').textContent = counts.kitas || 0;
                }
                document.getElementById('playground-count').textContent = counts.playgrounds || 0;
                document.getElementById('park-count').textContent = counts.parks || 0;
                document.getElementById('medical-count').textContent = counts.medical || 0;
                document.getElementById('cached-count').textContent = data.length;

                // Calculate overall score
                const schoolScore = Math.min(10, (counts.schools || 0) * 2);
                const playScore = Math.min(10, (counts.playgrounds || 0) * 1.5);
                const parkScore = Math.min(10, (counts.parks || 0) * 0.5);
                const medicalScore = Math.min(10, (counts.medical || 0) * 1);
                
                const totalScore = ((schoolScore + playScore + parkScore + medicalScore) / 4).toFixed(1);
                document.getElementById('total-score').textContent = `Score: ${totalScore}`;
            };

            // Count custom markers - ONLY for current kommune
            const customStore = transaction.objectStore('customMarkers');
            const customRequest = customStore.getAll();
            
            customRequest.onsuccess = () => {
                const allMarkers = customRequest.result;
                const currentMarkers = allMarkers.filter(m => m.kommune === currentKommune);
                document.getElementById('custom-count').textContent = currentMarkers.length;
            };
        }

        // Layer toggle functionality
        document.addEventListener('click', (e) => {
            const layerOption = e.target.closest('.layer-option');
            if (!layerOption) return;

            const toggle = layerOption.querySelector('.toggle-switch');
            const layerId = layerOption.dataset.layer;
            
            if (toggle) {
                toggle.classList.toggle('active');
                layerOption.classList.toggle('active');
                const isActive = toggle.classList.contains('active');
                
                // Handle different layer types - comprehensive layer management
                const layerIds = [
                    `${layerId}-fill`,      // Polygon fill
                    `${layerId}-line`,      // Polygon outline  
                    `${layerId}-circles`,   // Point circles
                    `${layerId}-points`,    // Point markers
                    `${layerId}-streets`,   // Street lines
                    layerId                 // Direct layer name
                ];
                
                layerIds.forEach(id => {
                    if (map && map.getLayer(id)) {
                        map.setLayoutProperty(id, 'visibility', isActive ? 'visible' : 'none');
                    }
                });
            }
        });

        // Tool activation functions
        function activateMarkerTool() {
            currentTool = currentTool === 'marker' ? null : 'marker';
            updateToolButtons();
            
            // Update cursor
            map.getCanvas().style.cursor = currentTool === 'marker' ? 'crosshair' : '';
            
            // Visual feedback on button
            const btn = document.getElementById('markerBtn');
            if (currentTool === 'marker') {
                btn.classList.add('active');
                showToast('📍 Klicke auf die Karte um einen Marker zu setzen', 'info');
            } else {
                btn.classList.remove('active');
            }
        }

        function activatePhotoTool() {
            currentTool = currentTool === 'photo' ? null : 'photo';
            updateToolButtons();
            map.getCanvas().style.cursor = currentTool === 'photo' ? 'crosshair' : '';
        }

        function activateNoteTool() {
            currentTool = currentTool === 'note' ? null : 'note';
            updateToolButtons();
            map.getCanvas().style.cursor = currentTool === 'note' ? 'crosshair' : '';
        }

        function activateStreetTool() {
            currentTool = currentTool === 'street' ? null : 'street';
            updateToolButtons();
            map.getCanvas().style.cursor = currentTool === 'street' ? 'crosshair' : '';
        }

        // ============ DRAWING/PINSEL TOOL IMPLEMENTATION ============
        let isDrawingMode = false;
        let isDrawingActive = false;
        let currentDrawingPath = [];
        let drawingEventHandlers = {};
        let savedDrawings = [];
        
        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('drawingBtn');
            
            if (isDrawingMode) {
                // Activate drawing mode
                btn.classList.add('active');
                btn.style.background = '#00B4D8'; // Light blue
                btn.style.color = 'white';
                map.getCanvas().style.cursor = 'crosshair';
                
                // Show toast
                showToast('🖌️ Zeichenmodus aktiviert! Tippe/Klicke und ziehe zum Zeichnen.', 'info');
                
                // Add event listeners
                setupDrawingEventListeners();
                
                // Load existing drawings for this kommune
                loadDrawnPaths();
            } else {
                // Deactivate drawing mode
                btn.classList.remove('active');
                btn.style.background = '';
                btn.style.color = '';
                map.getCanvas().style.cursor = '';
                
                // Remove event listeners
                removeDrawingEventListeners();
                
                showToast('✏️ Zeichenmodus deaktiviert', 'info');
            }
        }
        
        function setupDrawingEventListeners() {
            const canvas = map.getCanvas();
            
            // Mouse events
            drawingEventHandlers.mousedown = (e) => startDrawing(e);
            drawingEventHandlers.mousemove = (e) => continueDrawing(e);
            drawingEventHandlers.mouseup = (e) => endDrawing(e);
            drawingEventHandlers.mouseleave = (e) => endDrawing(e);
            
            // Touch events (CRITICAL for mobile/tablet!)
            drawingEventHandlers.touchstart = (e) => {
                e.preventDefault(); // Prevent scrolling while drawing
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mockEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    point: {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    }
                };
                startDrawing(mockEvent);
            };
            
            drawingEventHandlers.touchmove = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mockEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    point: {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    }
                };
                continueDrawing(mockEvent);
            };
            
            drawingEventHandlers.touchend = (e) => {
                e.preventDefault();
                endDrawing();
            };
            
            // Add all event listeners
            canvas.addEventListener('mousedown', drawingEventHandlers.mousedown);
            canvas.addEventListener('mousemove', drawingEventHandlers.mousemove);
            canvas.addEventListener('mouseup', drawingEventHandlers.mouseup);
            canvas.addEventListener('mouseleave', drawingEventHandlers.mouseleave);
            
            canvas.addEventListener('touchstart', drawingEventHandlers.touchstart, { passive: false });
            canvas.addEventListener('touchmove', drawingEventHandlers.touchmove, { passive: false });
            canvas.addEventListener('touchend', drawingEventHandlers.touchend, { passive: false });
        }
        
        function removeDrawingEventListeners() {
            const canvas = map.getCanvas();
            
            // Remove all event listeners
            if (drawingEventHandlers.mousedown) {
                canvas.removeEventListener('mousedown', drawingEventHandlers.mousedown);
                canvas.removeEventListener('mousemove', drawingEventHandlers.mousemove);
                canvas.removeEventListener('mouseup', drawingEventHandlers.mouseup);
                canvas.removeEventListener('mouseleave', drawingEventHandlers.mouseleave);
                
                canvas.removeEventListener('touchstart', drawingEventHandlers.touchstart);
                canvas.removeEventListener('touchmove', drawingEventHandlers.touchmove);
                canvas.removeEventListener('touchend', drawingEventHandlers.touchend);
            }
        }
        
        function startDrawing(e) {
            if (!isDrawingMode) return;
            
            isDrawingActive = true;
            currentDrawingPath = [];
            
            // Get coordinates from map
            const point = e.point || { x: e.clientX, y: e.clientY };
            const lngLat = map.unproject([point.x, point.y]);
            currentDrawingPath.push([lngLat.lng, lngLat.lat]);
            
            // Start drawing the line on map
            updateDrawingLayer();
        }
        
        function continueDrawing(e) {
            if (!isDrawingMode || !isDrawingActive) return;
            
            // Get coordinates
            const point = e.point || { x: e.clientX, y: e.clientY };
            const lngLat = map.unproject([point.x, point.y]);
            
            // Add point to path (with some smoothing by limiting points)
            const lastPoint = currentDrawingPath[currentDrawingPath.length - 1];
            if (lastPoint) {
                const distance = Math.sqrt(
                    Math.pow(lngLat.lng - lastPoint[0], 2) + 
                    Math.pow(lngLat.lat - lastPoint[1], 2)
                );
                // Only add point if it's far enough from the last one
                if (distance > 0.00001) { // Adjust threshold as needed
                    currentDrawingPath.push([lngLat.lng, lngLat.lat]);
                    updateDrawingLayer();
                }
            }
        }
        
        function endDrawing(e) {
            if (!isDrawingActive || currentDrawingPath.length < 2) {
                isDrawingActive = false;
                return;
            }
            
            isDrawingActive = false;
            
            // Save the drawing
            saveDrawnPath(currentDrawingPath);
            
            // Reset current path
            currentDrawingPath = [];
        }
        
        function updateDrawingLayer() {
            // Remove existing temporary drawing layer
            if (map.getLayer('temp-drawing')) {
                map.removeLayer('temp-drawing');
            }
            if (map.getSource('temp-drawing')) {
                map.removeSource('temp-drawing');
            }
            
            if (currentDrawingPath.length < 2) return;
            
            // Add temporary drawing layer
            map.addSource('temp-drawing', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: currentDrawingPath
                    }
                }
            });
            
            map.addLayer({
                id: 'temp-drawing',
                type: 'line',
                source: 'temp-drawing',
                paint: {
                    'line-color': '#00B4D8', // Light blue
                    'line-width': 4,
                    'line-opacity': 0.8
                }
            });
        }
        
        function saveDrawnPath(path) {
            if (!db || path.length < 2) return;
            
            const drawingId = `drawing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const drawing = {
                id: drawingId,
                kommune: currentKommune,
                projectId: currentProjectId,
                path: path,
                timestamp: Date.now(),
                color: '#00B4D8', // Light blue
                width: 4
            };
            
            // Save to IndexedDB
            const transaction = db.transaction(['customDrawings'], 'readwrite');
            const store = transaction.objectStore('customDrawings');
            const request = store.add(drawing);
            
            request.onsuccess = () => {
                console.log('✅ Zeichnung gespeichert:', drawingId);
                savedDrawings.push(drawing);
                displaySavedDrawings();
                
                // Also save to session storage for quick restore
                const sessionKey = `drawings_${currentKommune}`;
                const sessionDrawings = JSON.parse(sessionStorage.getItem(sessionKey) || '[]');
                sessionDrawings.push(drawing);
                sessionStorage.setItem(sessionKey, JSON.stringify(sessionDrawings));
            };
            
            request.onerror = () => {
                console.error('❌ Fehler beim Speichern der Zeichnung');
                showToast('⚠️ Fehler beim Speichern der Zeichnung', 'error');
            };
        }
        
        function loadDrawnPaths() {
            if (!db) return;
            
            const transaction = db.transaction(['customDrawings'], 'readonly');
            const store = transaction.objectStore('customDrawings');
            const index = store.index('kommune');
            const request = index.getAll(currentKommune);
            
            request.onsuccess = () => {
                savedDrawings = request.result || [];
                console.log(`📝 ${savedDrawings.length} Zeichnungen geladen für Kommune ${currentKommune}`);
                displaySavedDrawings();
            };
        }
        
        function displaySavedDrawings() {
            // Remove existing drawing layers
            savedDrawings.forEach((drawing, index) => {
                const layerId = `drawing-${index}`;
                if (map.getLayer(layerId)) map.removeLayer(layerId);
                if (map.getSource(layerId)) map.removeSource(layerId);
            });
            
            // Add all saved drawings
            savedDrawings.forEach((drawing, index) => {
                if (!drawing.path || drawing.path.length < 2) return;
                
                const layerId = `drawing-${index}`;
                
                map.addSource(layerId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: drawing.path
                        }
                    }
                });
                
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: layerId,
                    paint: {
                        'line-color': drawing.color || '#00B4D8',
                        'line-width': drawing.width || 4,
                        'line-opacity': 0.7
                    }
                });
            });
        }
        // ============ END DRAWING TOOL ============

        function activateMeasureTool() {
            currentTool = currentTool === 'measure' ? null : 'measure';
            measurePoints = [];
            currentRoute = null;
            updateToolButtons();
            
            if (currentTool === 'measure') {
                // Initialize measure mode
                setMeasureMode('click');
                setRouteType('walking');
            }
            
            updateMeasureDisplay();
            map.getCanvas().style.cursor = currentTool === 'measure' ? 'crosshair' : '';
        }

        function activateAreaTool() {
            currentTool = currentTool === 'area' ? null : 'area';
            updateToolButtons();
            map.getCanvas().style.cursor = currentTool === 'area' ? 'crosshair' : '';
        }

        // Begehungs-Modus Funktionen
        function startBegehung() {
            if (begehungActive) {
                stopBegehung();
                return;
            }

            if (!navigator.geolocation) {
                showToast('❌ GPS nicht verfügbar!', 'error');
                return;
            }

            begehungActive = true;
            begehungStartTime = Date.now();
            begehungTrack = [];
            begehungDistance = 0;
            begehungMarkers = [];
            lastBegehungPosition = null;

            // UI Updates
            document.getElementById('begehung-indicator').classList.add('active');
            document.getElementById('quick-action-bar').classList.add('active');
            document.getElementById('begehung-btn').classList.add('active');
            
            // Start Timer
            updateBegehungTimer();
            begehungTimer = setInterval(updateBegehungTimer, 1000);

            // Enhanced GPS Tracking for Begehung
            begehungWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;

                    // Only record if accuracy is good enough (< 80 meters for indoor)
                    // Increased from 20m to 80m for better iPad indoor tracking
                    if (accuracy < 80) {
                        begehungTrack.push({
                            lat: lat,
                            lng: lng,
                            timestamp: Date.now(),
                            accuracy: accuracy
                        });

                        // Calculate distance
                        if (lastBegehungPosition) {
                            const distance = calculateDistanceBetweenPoints(
                                lastBegehungPosition.lat,
                                lastBegehungPosition.lng,
                                lat,
                                lng
                            );
                            begehungDistance += distance;
                            document.getElementById('begehung-distance').textContent = formatDistance(begehungDistance);
                        }
                        lastBegehungPosition = { lat, lng };

                        // Update track on map
                        updateBegehungTrack();
                    }
                },
                (error) => {
                    console.error('GPS Error während Begehung:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                }
            );

            showToast('🚶 Begehung gestartet! GPS-Tracking aktiv.', 'success');
        }

        // REMOVED: Duplicate stopBegehung() function
        // Using the better implementation at line ~9106 with proper IndexedDB saving

        function updateBegehungTimer() {
            if (!begehungActive) return;
            
            const elapsed = Date.now() - begehungStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('begehung-timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Smooth path using Catmull-Rom spline interpolation
        function smoothPath(points, tension = 0.5, segments = 5) {
            if (points.length < 3) return points;
            
            const smoothed = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[Math.max(0, i - 1)];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = points[Math.min(points.length - 1, i + 2)];
                
                for (let t = 0; t < segments; t++) {
                    const t2 = (t / segments);
                    const t3 = t2 * t2;
                    const t4 = t3 * t2;
                    
                    const x = 0.5 * (
                        (2 * p1[0]) +
                        (-p0[0] + p2[0]) * t2 +
                        (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t3 +
                        (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t4
                    );
                    
                    const y = 0.5 * (
                        (2 * p1[1]) +
                        (-p0[1] + p2[1]) * t2 +
                        (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t3 +
                        (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t4
                    );
                    
                    smoothed.push([x, y]);
                }
            }
            
            // Add last point
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        function updateBegehungTrack() {
            if (begehungTrack.length < 2) return;

            // Konsistenz-Check: Konvertiere alte Array-Format zu Object-Format
            for (let i = 0; i < begehungTrack.length; i++) {
                const point = begehungTrack[i];
                if (Array.isArray(point)) {
                    // Altes Array-Format [lng, lat] zu Object-Format konvertieren
                    begehungTrack[i] = {
                        lat: point[1],
                        lng: point[0],
                        timestamp: Date.now(),
                        accuracy: 999, // Unknown accuracy
                        isConverted: true
                    };
                    console.warn('🔄 Converted old array format to object format:', point);
                }
            }

            // Split track into segments based on jumps
            const segments = [];
            let currentSegment = [];
            
            for (let i = 0; i < begehungTrack.length; i++) {
                const point = begehungTrack[i];
                
                if (i === 0 || !point.isJump) {
                    // Continue current segment
                    currentSegment.push([point.lng, point.lat]);
                } else {
                    // GPS jump detected - finish current segment and start new one
                    if (currentSegment.length > 0) {
                        segments.push({
                            type: 'solid',
                            coordinates: smoothPath(currentSegment)
                        });
                    }
                    
                    // Add dashed line for the jump
                    if (i > 0) {
                        const prevPoint = begehungTrack[i - 1];
                        segments.push({
                            type: 'dashed',
                            coordinates: [[prevPoint.lng, prevPoint.lat], [point.lng, point.lat]]
                        });
                    }
                    
                    // Start new segment
                    currentSegment = [[point.lng, point.lat]];
                }
            }
            
            // Add last segment
            if (currentSegment.length > 0) {
                segments.push({
                    type: 'solid',
                    coordinates: smoothPath(currentSegment)
                });
            }
            
            // Determine color based on begehung type
            const routeColor = begehungType === 'professional' ? '#FF3B30' : '#FFCC00';
            
            // Draw each segment
            segments.forEach((segment, index) => {
                const layerId = `begehung-track-${begehungType}-${index}`;
                const sourceId = `begehung-source-${begehungType}-${index}`;
                
                // Remove old layer if exists
                if (map.getLayer(layerId)) {
                    map.removeLayer(layerId);
                }
                if (map.getSource(sourceId)) {
                    map.removeSource(sourceId);
                }
                
                // Add source
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: segment.coordinates
                        }
                    }
                });
                
                // Add line layer with appropriate style
                const paintStyle = {
                    'line-color': routeColor,
                    'line-width': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        12, 3,
                        15, 6,
                        18, 10
                    ],
                    'line-opacity': segment.type === 'dashed' ? 0.5 : 0.8,
                    'line-blur': 0.5
                };
                
                // Add dash pattern for jumps
                if (segment.type === 'dashed') {
                    paintStyle['line-dasharray'] = [2, 2];
                }
                
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: paintStyle,
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    }
                });
            });
        }
        
        // Auto-save Begehung to localStorage
        function autoSaveBegehung() {
            if (!begehungActive || !begehungTrack.length) return;
            
            const sessionData = {
                type: begehungType,
                startTime: begehungStartTime,
                track: begehungTrack,
                markers: begehungMarkers,
                distance: begehungDistance,
                lastPosition: lastBegehungPosition,
                timestamp: Date.now()
            };
            
            const key = `begehung_session_${begehungType}_${new Date().toISOString().split('T')[0]}`;
            localStorage.setItem(key, JSON.stringify(sessionData));
            console.log(`💾 Auto-saved Begehung to localStorage: ${begehungTrack.length} points`);
        }
        
        // Periodic auto-save to IndexedDB (every 5 minutes during active begehung)
        let periodicSaveInterval = null;
        
        function startPeriodicSave() {
            if (periodicSaveInterval) clearInterval(periodicSaveInterval);
            
            periodicSaveInterval = setInterval(() => {
                if (begehungActive && begehungTrack.length > 0) {
                    saveBegehungTrack();
                    console.log('🕒 Periodic auto-save to IndexedDB completed');
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        function stopPeriodicSave() {
            if (periodicSaveInterval) {
                clearInterval(periodicSaveInterval);
                periodicSaveInterval = null;
            }
        }
        
        // Check for and restore previous sessions (BOTH types if available)
        function checkForPreviousSession() {
            const today = new Date().toISOString().split('T')[0];
            const professionalKey = `begehung_session_professional_${today}`;
            const childrenKey = `begehung_session_children_${today}`;
            
            const professionalSession = localStorage.getItem(professionalKey);
            const childrenSession = localStorage.getItem(childrenKey);
            
            const availableSessions = [];
            
            // Check professional session
            if (professionalSession) {
                try {
                    const session = JSON.parse(professionalSession);
                    const timeDiff = Date.now() - session.timestamp;
                    const SESSION_DURATION = 10800000; // 3 hours in milliseconds
                    if (timeDiff < SESSION_DURATION) { // Less than 3 hours old
                        availableSessions.push({ type: 'Fachkräfte', data: session, age: timeDiff });
                    }
                } catch (e) {
                    console.warn('Invalid professional session data:', e);
                }
            }
            
            // Check children session  
            if (childrenSession) {
                try {
                    const session = JSON.parse(childrenSession);
                    const timeDiff = Date.now() - session.timestamp;
                    const SESSION_DURATION = 10800000; // 3 hours in milliseconds
                    if (timeDiff < SESSION_DURATION) { // Less than 3 hours old
                        availableSessions.push({ type: 'Kinder', data: session, age: timeDiff });
                    }
                } catch (e) {
                    console.warn('Invalid children session data:', e);
                }
            }
            
            // Handle available sessions
            if (availableSessions.length === 1) {
                // Single session - restore directly
                const session = availableSessions[0];
                const minutes = Math.floor(session.age / 60000);
                if (confirm(`🔄 Unvollständige ${session.type}-Begehung von vor ${minutes} Minuten gefunden. Fortsetzen?`)) {
                    restoreBegehungSession(session.data);
                }
            } else if (availableSessions.length === 2) {
                // Multiple sessions - let user choose or restore all as saved tracks
                const professionalAge = availableSessions.find(s => s.type === 'Fachkräfte')?.age || 0;
                const childrenAge = availableSessions.find(s => s.type === 'Kinder')?.age || 0;
                const profMinutes = Math.floor(professionalAge / 60000);
                const childMinutes = Math.floor(childrenAge / 60000);
                
                const choice = confirm(`🔄 Mehrere unvollständige Begehungen gefunden:\n\n` +
                    `• Fachkräfte-Begehung (vor ${profMinutes} Min)\n` +
                    `• Kinder-Begehung (vor ${childMinutes} Min)\n\n` +
                    `OK = Beide als beendete Begehungen speichern\n` +
                    `Abbrechen = Ignorieren`);
                
                if (choice) {
                    // Save both sessions as completed tracks
                    availableSessions.forEach(session => {
                        if (session.data.track && session.data.track.length > 0) {
                            saveCompletedBegehungFromSession(session.data);
                            console.log(`✅ Saved ${session.type} session as completed track`);
                        }
                    });
                    showToast('✅ Beide Begehungen als abgeschlossene Routen gespeichert', 'success');
                }
            }
        }
        
        // Save a session as completed begehung track (used for multiple session handling)
        function saveCompletedBegehungFromSession(sessionData) {
            if (!db || !sessionData.track || sessionData.track.length === 0) return;
            
            const track = {
                id: `begehung_${sessionData.type}_${Date.now()}`,
                type: sessionData.type,
                track: sessionData.track,
                markers: sessionData.markers || [],
                distance: sessionData.distance || 0,
                duration: (Date.now() - sessionData.startTime) || 0,
                timestamp: Date.now(),
                kommune: currentKommune,
                projectId: currentProjectId,
                restoredFromSession: true // Mark as restored from session
            };
            
            // Save to IndexedDB
            const transaction = db.transaction(['gpsTracks'], 'readwrite');
            const store = transaction.objectStore('gpsTracks');
            store.add(track);
            
            transaction.oncomplete = () => {
                console.log('✅ Session saved as completed begehung:', track.id);
                // Add to memory for immediate display
                const sanitizedTrack = {
                    id: track.id,
                    type: track.type,
                    track: track.track.map(point => {
                        if (Array.isArray(point)) return point;
                        if (point && typeof point === 'object') {
                            return [point.lng || point[0], point.lat || point[1]];
                        }
                        return null;
                    }).filter(p => p),
                    markers: track.markers.map(marker => ({
                        id: marker.id,
                        type: marker.type,
                        title: marker.title,
                        lat: marker.lat,
                        lng: marker.lng,
                        timestamp: marker.timestamp,
                        hasPhoto: !!marker.photo
                    })),
                    distance: track.distance,
                    duration: track.duration,
                    timestamp: track.timestamp,
                    kommune: track.kommune,
                    projectId: track.projectId
                };
                begehungTracks[sessionData.type].push(sanitizedTrack);
                
                // Clear the session data after successful save
                const today = new Date().toISOString().split('T')[0];
                const sessionKey = `begehung_session_${sessionData.type}_${today}`;
                localStorage.removeItem(sessionKey);
                console.log('🗑️ Cleared session after save:', sessionKey);
            };
        }
        
        // Restore a previous Begehung session
        function restoreBegehungSession(session) {
            begehungType = session.type;
            begehungStartTime = session.startTime;
            begehungTrack = session.track || [];
            begehungMarkers = session.markers || [];
            begehungDistance = session.distance || 0;
            lastBegehungPosition = session.lastPosition;
            begehungActive = true;
            
            // CRITICAL: Immediately save restored session to IndexedDB for persistence  
            // This prevents data loss if user doesn't explicitly end the begehung
            if (begehungTrack.length > 0) {
                setTimeout(() => {
                    saveBegehungTrack();
                    console.log('💾 Auto-saved restored session to IndexedDB for safety');
                }, 1000); // Small delay to ensure UI is ready
            }
            
            // Update UI
            const btn = begehungType === 'professional' ? 
                document.getElementById('begehungProBtn') : 
                document.getElementById('begehungChildBtn');
            if (btn) btn.classList.add('active');
            
            // Update UI indicators
            document.getElementById('begehung-indicator')?.classList.add('active');
            document.getElementById('quick-action-bar')?.classList.add('active');
            
            // Redraw track
            updateBegehungTrack();
            
            // Restart tracking
            startBegehungContinuousTracking();
            
            // Restart timer
            begehungTimer = setInterval(updateBegehungTimer, 1000);
            
            // Restart periodic auto-save
            startPeriodicSave();
            
            showToast(`✅ Begehung wiederhergestellt: ${begehungTrack.length} Punkte`, 'success');
        }
        
        // Add visibility change handler for iOS tab switching
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && begehungActive) {
                // Page is hidden (user switched tabs) - save immediately
                autoSaveBegehung();
                console.log('📱 Tab hidden - Begehung auto-saved');
            } else if (!document.hidden && begehungActive) {
                // Page is visible again - check GPS status
                console.log('📱 Tab visible - continuing Begehung');
                // GPS tracking will automatically continue
            }
        });
        
        // Save before page unload - CRITICAL for data persistence
        window.addEventListener('beforeunload', (e) => {
            if (begehungActive && begehungTrack.length > 0) {
                // Auto-save to session storage for restore
                autoSaveBegehung();
                
                // ALSO save to IndexedDB for permanent storage 
                // (synchronous fallback for page unload)
                try {
                    saveBegehungTrack();
                    console.log('💾 Emergency save to IndexedDB before page unload');
                } catch (error) {
                    console.error('Failed to emergency save:', error);
                }
            }
        });
        
        // Additional safety: save on visibility change (tab switching)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && begehungActive && begehungTrack.length > 0) {
                // Page is hidden (user switched tabs) - save to IndexedDB
                saveBegehungTrack();
                console.log('💾 Auto-saved begehung track on tab switch');
            }
        });
        
        // Original updateBegehungTrack continues below
        function updateBegehungTrackOld() {
            // This is the old implementation kept for reference
            if (begehungTrack.length < 2) return;

            const coordinates = begehungTrack.map(p => [p.lng, p.lat]);
            
            // Smooth the path for better visualization
            const smoothedCoordinates = smoothPath(coordinates);
            
            // Determine color based on begehung type
            const routeColor = begehungType === 'professional' ? '#FF3B30' : '#FFCC00';
            const layerId = `begehung-track-${begehungType || 'default'}`;
            const sourceId = `begehung-source-${begehungType || 'default'}`;

            if (map.getSource(sourceId)) {
                map.getSource(sourceId).setData({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: smoothedCoordinates
                    }
                });
            } else {
                // Add source
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: smoothedCoordinates
                        }
                    }
                });

                // Add line layer for the smooth path
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': routeColor,
                        'line-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            12, 3,
                            15, 6,
                            18, 10
                        ],
                        'line-opacity': 0.8,
                        'line-blur': 0.5
                    }
                });

                // Add glow effect layer
                map.addLayer({
                    id: layerId + '-glow',
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': routeColor,
                        'line-width': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            12, 8,
                            15, 15,
                            18, 25
                        ],
                        'line-opacity': 0.2,
                        'line-blur': 3
                    },
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    }
                }, layerId);
            }
            
            // Update street highlighting if on a street
            updateStreetHighlighting(smoothedCoordinates, routeColor);
        }
        
        // Highlight streets along the route
        function updateStreetHighlighting(coordinates, color) {
            if (!coordinates || coordinates.length < 2) return;
            
            try {
                // Validate coordinates are valid numbers
                const validCoords = coordinates.filter(coord => 
                    Array.isArray(coord) && 
                    coord.length === 2 && 
                    !isNaN(coord[0]) && 
                    !isNaN(coord[1]) &&
                    isFinite(coord[0]) &&
                    isFinite(coord[1])
                );
                
                if (validCoords.length < 2) return;
                
                // Create a buffer around the route (50 meter radius)
                const line = turf.lineString(validCoords);
                const buffered = turf.buffer(line, 0.05, {units: 'kilometers'});
                
                const highlightId = `street-highlight-${begehungType || 'default'}`;
                
                // Remove existing highlight
                if (map.getLayer(highlightId)) {
                    map.removeLayer(highlightId);
                }
                if (map.getSource(highlightId)) {
                    map.removeSource(highlightId);
                }
                
                // Add street highlight layer
                map.addSource(highlightId, {
                    type: 'geojson',
                    data: buffered
                });
                
                map.addLayer({
                    id: highlightId,
                    type: 'fill',
                    source: highlightId,
                    paint: {
                        'fill-color': color,
                        'fill-opacity': 0.15
                    }
                }, 'begehung-track-' + (begehungType || 'default'));
                
            } catch (error) {
                console.warn('Street highlighting error:', error);
            }
        }

        // REMOVED: saveBegehungData() function
        // Using saveBegehungTrack() instead with proper begehungType support

        // Quick Action Funktionen während Begehung
        function quickPhoto() {
            // Check if we're in Begehung mode
            if (begehungActive && lastBegehungPosition) {
                // In Begehung: Use current GPS position immediately
                const lat = lastBegehungPosition.lat;
                const lng = lastBegehungPosition.lng;
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.capture = 'environment';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const photo = await fileToBase64(file);
                        
                        const marker = {
                            id: `photo_${Date.now()}`,
                            type: 'photo',
                            title: `Foto ${new Date().toLocaleTimeString('de-DE')}`,
                            category: 'begehung',
                            lat,
                            lng,
                            timestamp: new Date().toISOString(),
                            photo,
                            kommune: currentKommune,
                            projectId: currentProjectId,
                            begehungId: begehungStartTime,
                            begehungType: begehungType
                        };
                        
                        // Save to database
                        const transaction = db.transaction(['customMarkers'], 'readwrite');
                        const store = transaction.objectStore('customMarkers');
                        store.add(marker);
                        
                        begehungMarkers.push(marker);
                        
                        // Add to map immediately
                        addBegehungMarkerToMap(marker);
                        
                        // Auto-save session after adding marker
                        autoSaveBegehung();
                        
                        showToast('📸 Foto gespeichert!', 'success');
                    }
                };
                
                input.click();
            } else {
                // Not in Begehung: Activate tool for manual placement
                currentTool = 'photo';
                map.getCanvas().style.cursor = 'crosshair';
                showToast('📸 Klicke auf die Karte für die Foto-Position', 'info');
            }
        }

        function quickNote() {
            const note = prompt('📝 Notiz eingeben:');
            if (!note) return;
            
            // Check if we're in Begehung mode
            if (begehungActive && lastBegehungPosition) {
                // In Begehung: Use current GPS position immediately
                const lat = lastBegehungPosition.lat;
                const lng = lastBegehungPosition.lng;
                
                const marker = {
                    id: `note_${Date.now()}`,
                    type: 'note',
                    title: `Notiz ${new Date().toLocaleTimeString('de-DE')}`,
                    category: 'begehung',
                    description: note,
                    lat,
                    lng,
                    timestamp: new Date().toISOString(),
                    kommune: currentKommune,
                    projectId: currentProjectId,
                    begehungId: begehungStartTime,
                    begehungType: begehungType
                };
                
                // Save to database
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.add(marker);
                
                begehungMarkers.push(marker);
                
                // Add to map immediately
                addBegehungMarkerToMap(marker);
                
                // Auto-save session after adding marker
                autoSaveBegehung();
                
                showToast('📝 Notiz gespeichert!', 'success');
            } else {
                // Not in Begehung: Activate tool for manual placement
                currentTool = 'note';
                noteToPlace = note; // Store note text temporarily
                map.getCanvas().style.cursor = 'crosshair';
                showToast('📝 Klicke auf die Karte für die Notiz-Position', 'info');
            }
        }

        function quickMarker() {
            // Check if we're in Begehung mode
            if (begehungActive && lastBegehungPosition) {
                // In Begehung: Use current GPS position immediately
                const lat = lastBegehungPosition.lat;
                const lng = lastBegehungPosition.lng;
                showAddMarkerModal(lat, lng, true);
            } else {
                // Not in Begehung: Activate tool for manual placement
                currentTool = 'marker';
                map.getCanvas().style.cursor = 'crosshair';
                showToast('📍 Klicke auf die Karte für die Marker-Position', 'info');
            }
        }

        function quickDanger() {
            if (!begehungActive) {
                showToast('⚠️ Starte erst eine Begehung!', 'warning');
                return;
            }

            const saveDanger = (lat, lng) => {
                const danger = prompt('⚠️ Gefahr beschreiben:');
                if (!danger) return;
                
                const marker = {
                    id: 'begehung_danger_' + Date.now(),
                    type: 'danger',
                    title: `Gefahr ${new Date().toLocaleTimeString('de-DE')}`,
                    category: 'danger',
                    description: danger,
                    lat,
                    lng,
                    timestamp: new Date().toISOString(),
                    kommune: currentKommune,
                    projectId: currentProjectId,
                    begehungId: begehungStartTime
                };
                
                // Save to database
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.add(marker);
                
                begehungMarkers.push(marker);
                
                // Add to map immediately
                addBegehungMarkerToMap(marker);
                
                showToast('⚠️ Gefahrenstelle markiert!', 'success');
            };

            // GPS Position abrufen
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        saveDanger(position.coords.latitude, position.coords.longitude);
                    },
                    (error) => {
                        showToast('❌ GPS nicht verfügbar! Gefahrenstelle kann nicht markiert werden.', 'error');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            } else {
                showToast('❌ GPS nicht verfügbar!', 'error');
            }
        }

        function addBegehungMarkerToMap(marker) {
            // Add marker to map with special styling for begehung markers
            const el = document.createElement('div');
            el.className = 'begehung-marker';
            
            const icon = marker.type === 'photo' ? '📸' : 
                         marker.type === 'note' ? '📝' : 
                         marker.type === 'danger' ? '⚠️' : '📍';
            
            el.innerHTML = `
                <div style="
                    background: ${marker.type === 'danger' ? '#ff4060' : '#00ff80'};
                    border: 2px solid white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 16px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                ">
                    ${icon}
                </div>
            `;
            
            const mapMarker = new mapboxgl.Marker(el)
                .setLngLat([marker.lng, marker.lat])
                .setPopup(new mapboxgl.Popup().setHTML(`
                    <div class="popup-content">
                        <h3>${icon} ${marker.title}</h3>
                        ${marker.description ? `<p>${marker.description}</p>` : ''}
                        ${marker.photo ? `<img src="${marker.photo}" style="max-width: 100%; border-radius: 5px;">` : ''}
                        <div style="font-size: 11px; color: #ccc; margin-top: 8px;">
                            ${new Date(marker.timestamp).toLocaleString('de-DE')}
                        </div>
                    </div>
                `))
                .addTo(map);
        }

        function calculateDistanceBetweenPoints(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Suchfunktionen
        function initializeSearch() {
            // Old search box (hidden)
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            
            // New bottom search
            const bottomSearchInput = document.getElementById('bottom-search-input');
            const bottomSearchResults = document.getElementById('bottom-search-results');
            
            // Setup for bottom search
            if (bottomSearchInput) {
                bottomSearchInput.addEventListener('input', debounce((e) => {
                    const query = e.target.value.trim().toLowerCase();
                    
                    if (query.length < 2) {
                        bottomSearchResults.style.display = 'none';
                        return;
                    }
                    
                    performSearchBottom(query);
                }, 300));
                
                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.bottom-search-container')) {
                        bottomSearchResults.style.display = 'none';
                    }
                });
            }
            
            // Keep old search for compatibility
            if (searchInput) {
                searchInput.addEventListener('input', debounce((e) => {
                    const query = e.target.value.trim().toLowerCase();
                    
                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        return;
                    }
                    
                    performSearch(query);
                }, 300));

                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-box')) {
                        searchResults.style.display = 'none';
                    }
                });
            }
        }

        function buildSearchIndex() {
            searchIndex = [];
            
            // Index from map layers if map exists
            if (map && map.getStyle()) {
                // Get all sources from the map
                const sources = map.getStyle().sources;
                
                // Iterate through each source
                Object.keys(sources).forEach(sourceId => {
                    if (sourceId.includes('osm-')) {
                        const source = map.getSource(sourceId);
                        if (source && source._data && source._data.features) {
                            source._data.features.forEach(feature => {
                                const props = feature.properties || {};
                                const coords = feature.geometry.coordinates;
                                
                                // Extract center point
                                let lat, lng;
                                if (feature.geometry.type === 'Point') {
                                    [lng, lat] = coords;
                                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                                    // Get center of bounds
                                    const bounds = turf.bbox(feature);
                                    lng = (bounds[0] + bounds[2]) / 2;
                                    lat = (bounds[1] + bounds[3]) / 2;
                                } else if (feature.geometry.type === 'LineString') {
                                    // Get midpoint
                                    const midIndex = Math.floor(coords.length / 2);
                                    [lng, lat] = coords[midIndex];
                                }
                                
                                if (lat && lng && (props.name || props.ref || props.addr_street)) {
                                    const type = sourceId.replace('osm-', '');
                                    searchIndex.push({
                                        id: `${sourceId}_${feature.id || Math.random()}`,
                                        name: props.name || props.ref || props['addr:street'] || props.highway || 'Unbenannt',
                                        description: props.description || props['addr:full'] || '',
                                        type: type,
                                        category: 'map',
                                        lat: lat,
                                        lng: lng,
                                        tags: props,
                                        icon: getIconForType(type)
                                    });
                                }
                            });
                        }
                    }
                });
            }
            
            // Also index from IndexedDB
            if (db && currentKommune) {
                const transaction = db.transaction(['osmData', 'customMarkers'], 'readonly');
                
                // OSM Data - ONLY for current kommune
                const osmStore = transaction.objectStore('osmData');
                const osmRequest = osmStore.getAll();
                
                osmRequest.onsuccess = () => {
                    const allData = osmRequest.result;
                    // FILTER: Only index data for current kommune
                    const osmData = allData.filter(item => item.kommune === currentKommune);
                    
                    osmData.forEach(item => {
                        // Check if not already indexed from map
                        if (!searchIndex.find(si => si.lat === item.lat && si.lng === item.lng)) {
                            searchIndex.push({
                                id: item.id,
                                name: item.name || '',
                                type: item.type,
                                category: 'osm',
                                lat: item.lat,
                                lng: item.lng,
                                tags: item.tags || {},
                                icon: getIconForType(item.type)
                            });
                        }
                    });
                };
                
                // Custom Markers - ONLY for current kommune
                const markerStore = transaction.objectStore('customMarkers');
                const markerRequest = markerStore.getAll();
                
                markerRequest.onsuccess = () => {
                    const allMarkers = markerRequest.result;
                    // FILTER: Only index markers for current kommune
                    const markers = allMarkers.filter(m => m.kommune === currentKommune);
                    
                    markers.forEach(marker => {
                        searchIndex.push({
                            id: marker.id,
                            name: marker.title || marker.content || '',
                            description: marker.description || '',
                            type: marker.category || marker.type,
                            category: 'marker',
                            lat: marker.lat,
                            lng: marker.lng,
                            icon: marker.type === 'photo' ? '📸' : 
                                  marker.type === 'voice' ? '🎤' : 
                                  marker.type === 'note' ? '📝' : '📍'
                        });
                    });
                    
                    console.log(`🔍 Search index built with ${searchIndex.length} items`);
                };
            }
            
            // Also index current markers in memory
            if (customMarkers && customMarkers.length > 0) {
                customMarkers.forEach(marker => {
                    // Avoid duplicates
                    if (!searchIndex.find(si => si.id === marker.id)) {
                        searchIndex.push({
                            id: marker.id,
                            name: marker.title || marker.content || '',
                            description: marker.description || '',
                            type: marker.category || marker.type,
                            category: 'current',
                            lat: marker.lat,
                            lng: marker.lng,
                            icon: marker.type === 'photo' ? '📸' : 
                                  marker.type === 'voice' ? '🎤' : 
                                  marker.type === 'note' ? '📝' : '📍'
                        });
                    }
                });
            }
        }

        function performSearch(query) {
            const results = searchIndex.filter(item => {
                const nameMatch = item.name.toLowerCase().includes(query);
                const descMatch = item.description ? item.description.toLowerCase().includes(query) : false;
                const typeMatch = item.type.toLowerCase().includes(query);
                
                // Check tags
                let tagMatch = false;
                if (item.tags) {
                    Object.values(item.tags).forEach(value => {
                        if (String(value).toLowerCase().includes(query)) {
                            tagMatch = true;
                        }
                    });
                }
                
                return nameMatch || descMatch || typeMatch || tagMatch;
            });

            displaySearchResults(results.slice(0, 20)); // Limit to 20 results
        }
        
        async function performSearchBottom(query) {
            // First search local data
            const localResults = searchIndex.filter(item => {
                const nameMatch = item.name.toLowerCase().includes(query);
                const descMatch = item.description ? item.description.toLowerCase().includes(query) : false;
                const typeMatch = item.type.toLowerCase().includes(query);
                
                // Check tags
                let tagMatch = false;
                if (item.tags) {
                    Object.values(item.tags).forEach(value => {
                        if (String(value).toLowerCase().includes(query)) {
                            tagMatch = true;
                        }
                    });
                }
                
                return nameMatch || descMatch || typeMatch || tagMatch;
            });

            // Then search online via Nominatim
            let onlineResults = [];
            try {
                // Get current map bounds for local search
                const bounds = map.getBounds();
                const viewbox = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
                
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=10&viewbox=${viewbox}&bounded=0&accept-language=de`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    onlineResults = data.map(item => ({
                        id: `osm_${item.osm_id}`,
                        name: item.display_name.split(',')[0],
                        description: item.display_name,
                        type: item.type || item.class,
                        category: 'online',
                        lat: parseFloat(item.lat),
                        lng: parseFloat(item.lon),
                        icon: getIconForOSMType(item.type || item.class),
                        importance: item.importance
                    }));
                }
            } catch (error) {
                console.error('Nominatim search failed:', error);
            }

            // Combine and sort results
            const allResults = [
                ...localResults.map(r => ({...r, source: 'local'})),
                ...onlineResults.map(r => ({...r, source: 'online'}))
            ].sort((a, b) => {
                // Prioritize local results
                if (a.source === 'local' && b.source !== 'local') return -1;
                if (b.source === 'local' && a.source !== 'local') return 1;
                
                // Then sort by importance/relevance
                if (a.importance && b.importance) {
                    return b.importance - a.importance;
                }
                return 0;
            });

            displaySearchResultsBottom(allResults.slice(0, 20)); // Limit to 20 results
        }

        function displaySearchResults(results) {
            const searchResults = document.getElementById('search-results');
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-result-item">Keine Ergebnisse gefunden</div>';
                searchResults.style.display = 'block';
                return;
            }
            
            searchResults.innerHTML = results.map(result => `
                <div class="search-result-item" onclick="goToSearchResult('${result.id}', ${result.lat}, ${result.lng})">
                    <span style="font-size: 18px;">${result.icon}</span>
                    <div style="flex: 1;">
                        <div style="font-weight: bold;">${result.name}</div>
                        ${result.description ? `<div style="font-size: 11px; color: #ccc;">${result.description.substring(0, 50)}...</div>` : ''}
                    </div>
                    <span class="search-category">${result.category === 'osm' ? result.type : 'Marker'}</span>
                </div>
            `).join('');
            
            searchResults.style.display = 'block';
        }

        function displaySearchResultsBottom(results) {
            const bottomSearchResults = document.getElementById('bottom-search-results');
            
            if (!bottomSearchResults) return;
            
            if (results.length === 0) {
                bottomSearchResults.innerHTML = '<div class="search-result-item" style="text-align: center; color: var(--text-secondary);">Keine Ergebnisse gefunden</div>';
                bottomSearchResults.style.display = 'block';
                return;
            }
            
            // Group results by source
            const localResults = results.filter(r => r.source === 'local');
            const onlineResults = results.filter(r => r.source === 'online');
            
            let html = '';
            
            // Show local results first
            if (localResults.length > 0) {
                html += '<div style="padding: 8px 12px; background: var(--secondary); font-size: 11px; font-weight: bold; color: var(--text-secondary); border-bottom: 1px solid var(--border);">📍 Lokale Ergebnisse</div>';
                html += localResults.map(result => `
                    <div class="search-result-item" onclick="goToSearchResultBottom('${result.id}', ${result.lat}, ${result.lng})">
                        <span style="font-size: 18px;">${result.icon || '📍'}</span>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: var(--text-primary);">${escapeHtml(result.name)}</div>
                            ${result.description ? `<div style="font-size: 11px; color: var(--text-secondary);">${escapeHtml(result.description.substring(0, 50))}...</div>` : ''}
                        </div>
                        <span class="search-category" style="background: var(--accent);">${getCategoryLabel(result)}</span>
                    </div>
                `).join('');
            }
            
            // Show online results
            if (onlineResults.length > 0) {
                html += '<div style="padding: 8px 12px; background: var(--secondary); font-size: 11px; font-weight: bold; color: var(--text-secondary); border-bottom: 1px solid var(--border);">🌐 Online-Suche</div>';
                html += onlineResults.map(result => {
                    // Calculate distance if user location is available
                    let distanceText = '';
                    if (userLocation && userLocation.lat && userLocation.lng) {
                        const distance = calculateDistance(userLocation.lat, userLocation.lng, result.lat, result.lng);
                        distanceText = distance < 1 ? `${Math.round(distance * 1000)}m` : `${distance.toFixed(1)}km`;
                    }
                    
                    return `
                        <div class="search-result-item" onclick="goToSearchResultBottom('${result.id}', ${result.lat}, ${result.lng})">
                            <span style="font-size: 18px;">${result.icon || '📍'}</span>
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: var(--text-primary);">${escapeHtml(result.name)}</div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    ${escapeHtml(result.description ? result.description.substring(0, 60) : '')}
                                    ${distanceText ? `<span style="margin-left: 8px; color: var(--accent);">📏 ${distanceText}</span>` : ''}
                                </div>
                            </div>
                            <span class="search-category" style="background: #6B7280;">${getTypeLabel(result.type)}</span>
                        </div>
                    `;
                }).join('');
            }
            
            bottomSearchResults.innerHTML = html;
            bottomSearchResults.style.display = 'block';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        function getCategoryLabel(result) {
            const labels = {
                'map': 'Karte',
                'osm': 'OSM',
                'marker': 'Marker',
                'current': 'Aktuell',
                'online': 'Online',
                'schools': 'Schule',
                'playgrounds': 'Spielplatz',
                'parks': 'Park',
                'medical': 'Medizin',
                'shopping': 'Einkauf',
                'sports': 'Sport',
                'transport': 'ÖPNV'
            };
            return labels[result.category] || labels[result.type] || result.type || 'Ort';
        }
        
        function getTypeLabel(type) {
            const labels = {
                'city': 'Stadt',
                'town': 'Kleinstadt',
                'village': 'Dorf',
                'hamlet': 'Weiler',
                'suburb': 'Vorort',
                'neighbourhood': 'Viertel',
                'house': 'Haus',
                'residential': 'Wohngebiet',
                'commercial': 'Gewerbe',
                'industrial': 'Industrie',
                'restaurant': 'Restaurant',
                'cafe': 'Café',
                'fast_food': 'Schnellimbiss',
                'school': 'Schule',
                'kindergarten': 'Kindergarten',
                'hospital': 'Krankenhaus',
                'pharmacy': 'Apotheke',
                'supermarket': 'Supermarkt',
                'park': 'Park',
                'playground': 'Spielplatz',
                'bus_stop': 'Bushaltestelle',
                'railway_station': 'Bahnhof',
                'road': 'Straße',
                'footway': 'Fußweg',
                'cycleway': 'Radweg'
            };
            return labels[type] || type || 'Ort';
        }
        
        function goToSearchResult(id, lat, lng) {
            // Hide search results
            document.getElementById('search-results').style.display = 'none';
            document.getElementById('search-input').value = '';
            
            // Fly to location
            map.flyTo({
                center: [lng, lat],
                zoom: 18,
                duration: 2000
            });
            
            // Highlight the result (optional animation)
            setTimeout(() => {
                // Create a pulsing circle at the location
                const pulseEl = document.createElement('div');
                pulseEl.style.cssText = `
                    width: 60px;
                    height: 60px;
                    background: radial-gradient(circle, transparent, rgba(0, 255, 255, 0.4));
                    border: 3px solid #00ffff;
                    border-radius: 50%;
                    animation: pulse 2s ease-out;
                `;
                
                new mapboxgl.Marker(pulseEl)
                    .setLngLat([lng, lat])
                    .addTo(map);
                
                // Remove after animation
                setTimeout(() => pulseEl.remove(), 2000);
            }, 2000);
        }
        
        function goToSearchResultBottom(id, lat, lng) {
            // Hide search results
            document.getElementById('bottom-search-results').style.display = 'none';
            document.getElementById('bottom-search-input').value = '';
            
            // Fly to location
            map.flyTo({
                center: [lng, lat],
                zoom: 18,
                duration: 2000
            });
            
            // Highlight the result (optional animation)
            setTimeout(() => {
                // Create a pulsing circle at the location
                const pulseEl = document.createElement('div');
                pulseEl.style.cssText = `
                    width: 60px;
                    height: 60px;
                    background: radial-gradient(circle, transparent, rgba(52, 211, 153, 0.4));
                    border: 3px solid #34D399;
                    border-radius: 50%;
                    animation: pulse 2s ease-out;
                `;
                
                new mapboxgl.Marker(pulseEl)
                    .setLngLat([lng, lat])
                    .addTo(map);
                
                // Remove after animation
                setTimeout(() => pulseEl.remove(), 2000);
            }, 2000);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function updateToolButtons() {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (currentTool) {
                const activeBtn = document.querySelector(`[onclick*="${currentTool}"]`);
                if (activeBtn) activeBtn.classList.add('active');
            }
            
            document.getElementById('measure-display').style.display = 
                currentTool === 'measure' ? 'block' : 'none';
        }

        // Measure tool functions
        function handleMeasureClick(lngLat) {
            // Only handle clicks in click mode
            if (currentMeasureMode !== 'click') return;
            
            measurePoints.push(lngLat);
            
            if (measurePoints.length === 1) {
                // Add first point marker
                addMeasurePoint(lngLat, 'A');
                updateMeasureDisplay('Klicke zweiten Punkt...');
            } else if (measurePoints.length === 2) {
                // Add second point and calculate distance
                addMeasurePoint(lngLat, 'B');
                calculateDistance();
            } else {
                // Reset for new measurement
                clearMeasurePoints();
                measurePoints = [lngLat];
                addMeasurePoint(lngLat, 'A');
                updateMeasureDisplay('Klicke zweiten Punkt...');
            }
        }

        function addMeasurePoint(lngLat, label) {
            const sourceId = `measure-point-${label}`;
            
            if (map.getSource(sourceId)) {
                map.removeLayer(`measure-point-${label}`);
                map.removeSource(sourceId);
            }
            
            map.addSource(sourceId, {
                type: 'geojson',
                data: {
                    type: 'Point',
                    coordinates: [lngLat.lng, lngLat.lat]
                }
            });
            
            map.addLayer({
                id: `measure-point-${label}`,
                type: 'circle',
                source: sourceId,
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#ff4060',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff'
                }
            });
        }

        function calculateDistance() {
            const [point1, point2] = measurePoints;
            
            // Calculate straight line distance using simple formula
            const R = 6371000; // Earth's radius in meters
            const lat1Rad = point1.lat * Math.PI / 180;
            const lat2Rad = point2.lat * Math.PI / 180;
            const deltaLatRad = (point2.lat - point1.lat) * Math.PI / 180;
            const deltaLngRad = (point2.lng - point1.lng) * Math.PI / 180;
            
            const a = Math.sin(deltaLatRad/2) * Math.sin(deltaLatRad/2) +
                    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                    Math.sin(deltaLngRad/2) * Math.sin(deltaLngRad/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const straightDistance = R * c;
            
            // Add line between points with distance label
            if (map.getSource('measure-line')) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            
            map.addSource('measure-line', {
                type: 'geojson',
                data: {
                    type: 'LineString',
                    coordinates: [[point1.lng, point1.lat], [point2.lng, point2.lat]]
                }
            });
            
            map.addLayer({
                id: 'measure-line',
                type: 'line',
                source: 'measure-line',
                paint: {
                    'line-color': '#ff4060',
                    'line-width': 3,
                    'line-dasharray': [2, 2]
                }
            });
            
            // Add distance label at midpoint
            const midPoint = {
                lng: (point1.lng + point2.lng) / 2,
                lat: (point1.lat + point2.lat) / 2
            };
            
            addDistanceLabel(midPoint, formatDistance(straightDistance));
            
            // Update display with straight line distance
            updateMeasureDisplay(`📏 Luftlinie: ${formatDistance(straightDistance)}`);
            
            // Try to get route if online
            if (isOnline && currentRouteType) {
                getRouteDistance(point1, point2, straightDistance);
            }
        }

        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)}m`;
            } else {
                return `${(meters / 1000).toFixed(1)}km`;
            }
        }

        function addDistanceLabel(position, text) {
            // Remove existing label
            if (map.getLayer('distance-label')) {
                map.removeLayer('distance-label');
                map.removeSource('distance-label-source');
            }
            
            map.addSource('distance-label-source', {
                type: 'geojson',
                data: {
                    type: 'Point',
                    coordinates: [position.lng, position.lat]
                }
            });
            
            map.addLayer({
                id: 'distance-label',
                type: 'symbol',
                source: 'distance-label-source',
                layout: {
                    'text-field': text,
                    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                    'text-size': 12,
                    'text-offset': [0, -1]
                },
                paint: {
                    'text-color': '#ffffff',
                    'text-halo-color': '#000000',
                    'text-halo-width': 2
                }
            });
        }

        function updateMeasureDisplay(text = 'Klicke zwei Punkte zum Messen') {
            document.getElementById('measure-result').innerHTML = text;
        }

        function clearMeasurePoints() {
            ['A', 'B'].forEach(label => {
                const sourceId = `measure-point-${label}`;
                if (map.getLayer(`measure-point-${label}`)) {
                    map.removeLayer(`measure-point-${label}`);
                    map.removeSource(sourceId);
                }
            });
            
            // Clear measure line and label
            if (map.getLayer('measure-line')) {
                map.removeLayer('measure-line');
                map.removeSource('measure-line');
            }
            
            if (map.getLayer('distance-label')) {
                map.removeLayer('distance-label');
                map.removeSource('distance-label-source');
            }
            
            // Clear route
            if (map.getLayer('route-line')) {
                map.removeLayer('route-line');
                map.removeSource('route-source');
            }
            
            currentRoute = null;
            document.getElementById('route-actions').style.display = 'none';
        }

        // New measure mode functions
        function setMeasureMode(mode) {
            currentMeasureMode = mode;
            
            // Update button states
            document.querySelectorAll('.measure-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            
            // Show/hide input sections
            document.getElementById('click-mode').style.display = mode === 'click' ? 'block' : 'none';
            document.getElementById('address-mode').style.display = mode === 'address' ? 'block' : 'none';
            
            // Clear current measurement
            measurePoints = [];
            clearMeasurePoints();
            updateMeasureDisplay(mode === 'click' ? 'Klicke zwei Punkte zum Messen' : 'Gib Start- und Zieladresse ein');
        }

        function setRouteType(type) {
            currentRouteType = type;
            
            // Update button states
            document.querySelectorAll('.route-type-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`route-${type}`).classList.add('active');
            
            // Recalculate route if points are set
            if (measurePoints.length === 2 && isOnline) {
                calculateDistance();
            }
        }

        async function calculateAddressRoute(routeType) {
            const startAddress = document.getElementById('start-address').value.trim();
            const endAddress = document.getElementById('end-address').value.trim();
            
            if (!startAddress || !endAddress) {
                showToast('⚠️ Bitte Start- und Zieladresse eingeben', 'warning');
                return;
            }
            
            if (!isOnline) {
                showToast('📶 Internet für Adress-Routing erforderlich', 'warning');
                return;
            }
            
            try {
                updateMeasureDisplay('🔍 Suche Adressen...');
                
                // Geocode both addresses
                const startCoords = await geocodeAddress(startAddress);
                const endCoords = await geocodeAddress(endAddress);
                
                if (!startCoords || !endCoords) {
                    updateMeasureDisplay('❌ Eine oder beide Adressen nicht gefunden');
                    return;
                }
                
                // Set measure points and calculate route
                measurePoints = [
                    { lat: startCoords.lat, lng: startCoords.lng },
                    { lat: endCoords.lat, lng: endCoords.lng }
                ];
                
                currentRouteType = routeType;
                
                // Add markers for start/end
                addMeasurePoint(measurePoints[0], 'A');
                addMeasurePoint(measurePoints[1], 'B');
                
                // Calculate route
                calculateDistance();
                
            } catch (error) {
                updateMeasureDisplay('❌ Fehler beim Adress-Routing');
                console.error('Address routing error:', error);
            }
        }

        async function geocodeAddress(address) {
            try {
                // Add current kommune context for better results
                const query = `${address}, ${currentKommune}, Deutschland`;
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&accept-language=de`
                );
                const data = await response.json();
                
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lng: parseFloat(data[0].lon)
                    };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        function saveCurrentRoute() {
            if (!currentRoute) {
                showToast('❌ Keine Route zum Speichern', 'warning');
                return;
            }
            
            const routeName = prompt('Name für die Route:', `Route ${currentRouteType === 'driving' ? 'Auto' : 'Fuß'} ${new Date().toLocaleTimeString('de-DE')}`);
            if (!routeName) return;
            
            const savedRoute = {
                id: 'route_' + Date.now(),
                name: routeName,
                kommune: currentKommune,
                projectId: currentProjectId,
                ...currentRoute,
                timestamp: new Date().toISOString()
            };
            
            // Save to IndexedDB
            const transaction = db.transaction(['routes'], 'readwrite');
            const store = transaction.objectStore('routes');
            store.add(savedRoute);
            
            transaction.oncomplete = () => {
                showToast('💾 Route gespeichert!', 'success');
                loadSavedRoutes();
                // Auto-save project
                saveCurrentProject();
            };
        }

        function clearCurrentRoute() {
            measurePoints = [];
            clearMeasurePoints();
            updateMeasureDisplay(currentMeasureMode === 'click' ? 'Klicke zwei Punkte zum Messen' : 'Gib Start- und Zieladresse ein');
        }

        function loadSavedRoutes() {
            if (!db) return;
            
            const transaction = db.transaction(['routes'], 'readonly');
            const store = transaction.objectStore('routes');
            const request = store.getAll();
            
            request.onsuccess = () => {
                savedRoutes = request.result;
                // Could display saved routes in UI if needed
            };
        }

        // Removed duplicate loadSavedBegehungen function - using the correct one below

        // Street marking tool
        function handleStreetClick(lngLat) {
            // This would require more complex implementation
            // For now, just show a placeholder
            showToast('🎨 Straßen-Markierung: Feature kommt bald!', 'info');
        }

        // Load custom markers
        function loadCustomMarkers() {
            if (!db || !currentKommune) return;

            const transaction = db.transaction(['customMarkers'], 'readonly');
            const store = transaction.objectStore('customMarkers');
            const request = store.getAll();

            request.onsuccess = () => {
                // FILTER: Only load markers for current kommune
                const allMarkers = request.result;
                customMarkers = allMarkers.filter(m => m.kommune === currentKommune);
                
                if (customMarkers.length > 0) {
                    const geojson = {
                        type: 'FeatureCollection',
                        features: customMarkers.map(marker => ({
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [marker.lng, marker.lat]
                            },
                            properties: marker
                        }))
                    };

                    if (map.getSource('custom-markers')) {
                        map.getSource('custom-markers').setData(geojson);
                    } else {
                        map.addSource('custom-markers', {
                            type: 'geojson',
                            data: geojson
                        });

                        map.addLayer({
                            id: 'custom-markers',
                            type: 'circle',
                            source: 'custom-markers',
                            paint: {
                                'circle-radius': 12,
                                'circle-color': [
                                    'match',
                                    ['get', 'type'],
                                    'note', '#00ffff',
                                    'photo', '#ff69b4',
                                    'danger', '#ff4060',
                                    '#ffff00' // default color
                                ],
                                'circle-stroke-width': 3,
                                'circle-stroke-color': '#000000',
                                'circle-opacity': 0.9
                            }
                        });

                        map.on('click', 'custom-markers', (e) => {
                            showCustomMarkerPopup(e.features[0], e.lngLat);
                        });

                        map.on('mouseenter', 'custom-markers', () => {
                            map.getCanvas().style.cursor = 'pointer';
                        });

                        map.on('mouseleave', 'custom-markers', () => {
                            map.getCanvas().style.cursor = '';
                        });
                    }
                }
            };
        }

        // Show custom marker popup
        function showCustomMarkerPopup(feature, lngLat) {
            const props = feature.properties;
            
            // Different display based on marker type
            const isNote = props.type === 'note';
            const isPhoto = props.type === 'photo';
            const priorityColors = {
                urgent: '#ff4060',
                high: '#ff8000',
                medium: '#ffdd00',
                low: '#00ff80'
            };
            
            const popupContent = `
                <div class="popup-content">
                    <h3>${isNote ? '📝' : isPhoto ? '📸' : '📍'} ${props.title}</h3>
                    <div class="info-grid">
                        <div class="info-row">
                            <span class="info-label">Kategorie:</span>
                            <span>${getCategoryName(props.category)}</span>
                        </div>
                        ${props.priority ? `
                        <div class="info-row">
                            <span class="info-label">Priorität:</span>
                            <span style="color: ${priorityColors[props.priority]}">${props.priority.toUpperCase()}</span>
                        </div>` : ''}
                        ${props.description ? `
                        <div class="info-row">
                            <span class="info-label">${isNote ? 'Notiz' : 'Beschreibung'}:</span>
                            <span>${props.description}</span>
                        </div>` : ''}
                        <div class="info-row">
                            <span class="info-label">Erstellt:</span>
                            <span>${new Date(props.timestamp).toLocaleDateString('de-DE')}</span>
                        </div>
                        ${props.begehungId ? `
                        <div class="info-row">
                            <span class="info-label">Begehung:</span>
                            <span>🚶 ${new Date(props.begehungId).toLocaleDateString('de-DE')}</span>
                        </div>` : ''}
                    </div>
                    ${props.photo ? `<img src="${props.photo}" style="max-width: 100%; border-radius: 5px; margin: 10px 0;">` : ''}
                    <div style="display: flex; gap: 5px;">
                        <button class="popup-btn" onclick="editMarker('${props.id}')" style="flex: 1;">✏️ Bearbeiten</button>
                        <button class="popup-btn" onclick="deleteMarker('${props.id}')" style="flex: 1; background: #ff4060;">🗑️ Löschen</button>
                    </div>
                </div>
            `;
            
            new mapboxgl.Popup()
                .setLngLat(lngLat)
                .setHTML(popupContent)
                .addTo(map);
        }

        function getCategoryName(category) {
            const names = {
                problem: '🚨 Problem',
                suggestion: '💡 Verbesserung',
                positive: '✅ Positiv',
                danger: '⚠️ Gefahr',
                note: '📝 Notiz',
                photo: '📸 Foto',
                begehung: '🚶 Begehung'
            };
            return names[category] || category;
        }

        // Modal functions
        function showAddMarkerModal(lat, lng, isBegehung = false) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal">
                    <h2>📍 Neuer Marker ${isBegehung ? '(Begehung)' : ''}</h2>
                    <form id="marker-form">
                        <div class="input-group">
                            <label for="marker-title">Titel *</label>
                            <input type="text" id="marker-title" required placeholder="z.B. Defekter Spielplatz">
                        </div>
                        
                        <div class="input-group">
                            <label for="marker-category">Kategorie</label>
                            <select id="marker-category" style="width: 100%; padding: 10px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; color: white;">
                                <option value="problem">🚨 Problem</option>
                                <option value="suggestion">💡 Verbesserung</option>
                                <option value="positive">✅ Positiv</option>
                                <option value="danger">⚠️ Gefahr</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="marker-description">Beschreibung</label>
                            <textarea id="marker-description" placeholder="Beschreibe was dir aufgefallen ist..." rows="3" style="width: 100%; padding: 10px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; color: white; resize: vertical;"></textarea>
                        </div>
                        
                        <div class="input-group">
                            <label for="marker-photo">📷 Foto (optional)</label>
                            <input type="file" id="marker-photo" accept="image/*" capture="environment" style="width: 100%; padding: 10px; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; color: white;">
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px;">
                            <button type="submit" class="btn primary">📍 Marker erstellen</button>
                            <button type="button" class="btn secondary" onclick="this.closest('.modal-overlay').remove()">Abbrechen</button>
                        </div>
                    </form>
                </div>
            `;

            document.body.appendChild(modal);

            modal.querySelector('#marker-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const title = modal.querySelector('#marker-title').value.trim();
                const category = modal.querySelector('#marker-category').value;
                const description = modal.querySelector('#marker-description').value.trim();
                const photoFile = modal.querySelector('#marker-photo').files[0];
                
                let photo = null;
                if (photoFile) {
                    photo = await fileToBase64(photoFile);
                }
                
                const marker = {
                    id: 'custom_' + Date.now(),
                    title,
                    category,
                    description,
                    lat,
                    lng,
                    timestamp: new Date().toISOString(),
                    photo,
                    kommune: currentKommune,
                    projectId: currentProjectId,
                    synced: false
                };

                // Add begehung reference if in begehung mode
                if (isBegehung && begehungActive) {
                    marker.begehungId = begehungStartTime;
                    begehungMarkers.push(marker);
                }
                
                // Save to IndexedDB
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.add(marker);
                
                transaction.oncomplete = () => {
                    loadCustomMarkers();
                    updateStats();
                    buildSearchIndex(); // Update search index
                    modal.remove();
                    currentTool = null;
                    updateToolButtons();
                    map.getCanvas().style.cursor = '';
                    
                    // Auto-save project
                    saveCurrentProject();
                    
                    showToast('📍 Marker erstellt und offline gespeichert!', 'success');
                };
            });
        }

        function showPhotoModal(lat, lng) {
            // Similar to marker modal but with photo focus
            showAddMarkerModal(lat, lng);
            setTimeout(() => {
                const photoInput = document.getElementById('marker-photo');
                if (photoInput) photoInput.click();
            }, 100);
        }

        function fileToBase64(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(file);
            });
        }

        // Action functions
        function findMyLocation() {
            if (!navigator.geolocation) {
                showToast('❌ GPS nicht verfügbar!', 'error');
                return;
            }
            
            showToast('🧭 Suche Position...', 'info');
            
            // Start continuous tracking if not already started
            if (!gpsWatchId) {
                startContinuousTracking();
            }
            
            // Set timeout for slow GPS
            const timeout = setTimeout(() => {
                showToast('⏱️ GPS braucht länger... Bitte warten', 'warning');
            }, 3000);
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    clearTimeout(timeout);
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    map.flyTo({
                        center: [lng, lat],
                        zoom: 17,
                        duration: 2000
                    });
                    
                    // Update location display
                    updateUserLocation(lat, lng);
                    document.getElementById('header-location').textContent = 
                        `📍 ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
                    document.getElementById('gps-text').textContent = 'GPS ✓';
                    
                    showToast(`🧭 Position gefunden! (±${accuracy.toFixed(0)}m Genauigkeit)`, 'success');
                },
                (error) => {
                    clearTimeout(timeout);
                    console.error('Position error:', error);
                    
                    // Try with lower accuracy
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lng = position.coords.longitude;
                            
                            map.flyTo({
                                center: [lng, lat],
                                zoom: 16,
                                duration: 2000
                            });
                            
                            updateUserLocation(lat, lng);
                            showToast('🧭 Position gefunden (niedrige Genauigkeit)', 'warning');
                        },
                        (finalError) => {
                            console.error('Final position error:', finalError);
                            
                            if (finalError.code === 1) {
                                const isAndroid = /Android/.test(navigator.userAgent);
                                if (isAndroid) {
                                    showAndroidPermissionInstructions();
                                } else {
                                    showIOSPermissionInstructions();
                                }
                            } else {
                                showToast('❌ Position nicht gefunden. GPS aktivieren!', 'error');
                            }
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 15000,
                            maximumAge: 30000
                        }
                    );
                },
                {
                    enableHighAccuracy: true,
                    timeout: 20000, // Increased timeout for Android
                    maximumAge: 5000 // Allow cached position for faster response
                }
            );
        }

        function exportData() {
            if (!db) return;

            const transaction = db.transaction(['customMarkers', 'gpsTracks'], 'readonly');
            const markerStore = transaction.objectStore('customMarkers');
            const trackStore = transaction.objectStore('gpsTracks');
            
            const markerRequest = markerStore.getAll();
            const trackRequest = trackStore.getAll();

            let exportData = {
                kommune: currentKommune,
                projectName: currentProjectName,
                exportDate: new Date().toISOString(),
                markers: [],
                begehungen: [],
                gpsTrack: gpsTrack
            };

            markerRequest.onsuccess = () => {
                // FILTER: Only export markers for current kommune
                const allMarkers = markerRequest.result;
                exportData.markers = allMarkers.filter(m => m.kommune === currentKommune);
                
                trackRequest.onsuccess = () => {
                    exportData.begehungen = trackRequest.result;
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `kinderfreundlich-${currentKommune}-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    showToast('📤 Daten exportiert!', 'success');
                };
            };
        }

        function openProjectMenu() {
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            // Create modal content
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: linear-gradient(135deg, #1a1b3a 0%, #0a0b1e 100%);
                border: 2px solid var(--accent);
                border-radius: 20px;
                padding: 30px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
                animation: slideUp 0.3s ease;
            `;
            
            modal.innerHTML = `
                <h2 style="color: var(--accent); margin-bottom: 10px; text-align: center; font-size: 24px;">
                    📂 Projekt-Menü
                </h2>
                <p style="color: #ccc; text-align: center; margin-bottom: 25px; font-size: 14px;">
                    ${currentProjectName} • ${currentKommune}
                </p>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button class="project-menu-btn" onclick="saveCurrentProject(); showToast('💾 Projekt lokal gespeichert!', 'success'); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">💾</span>
                        <div>
                            <div style="font-weight: bold;">Projekt speichern</div>
                            <div style="font-size: 11px; opacity: 0.8;">Lokal auf diesem Gerät</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn cloud" onclick="uploadProjectToCloud(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">☁️</span>
                        <div>
                            <div style="font-weight: bold;">In Cloud speichern</div>
                            <div style="font-size: 11px; opacity: 0.8;">Online verfügbar machen</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="showCloudProjectList(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📥</span>
                        <div>
                            <div style="font-weight: bold;">Cloud-Projekte anzeigen</div>
                            <div style="font-size: 11px; opacity: 0.8;">Gespeicherte Projekte laden</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="if(confirm('Zurück zur Projektauswahl? Ungespeicherte Änderungen gehen verloren!')) { saveCurrentProject(); document.getElementById('app-container').style.display = 'none'; document.getElementById('setup-screen').style.display = 'flex'; showTab('load'); } this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📂</span>
                        <div>
                            <div style="font-weight: bold;">Zu Projektauswahl</div>
                            <div style="font-size: 11px; opacity: 0.8;">Anderes Projekt öffnen</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="showExportDialog(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📤</span>
                        <div>
                            <div style="font-weight: bold;">Projekt exportieren</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als Datei herunterladen</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn cancel" onclick="this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">❌</span>
                        <div>
                            <div style="font-weight: bold;">Abbrechen</div>
                            <div style="font-size: 11px; opacity: 0.8;">Menü schließen</div>
                        </div>
                    </button>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });
            
            // Add CSS for buttons if not already present
            if (!document.querySelector('#project-menu-styles')) {
                const style = document.createElement('style');
                style.id = 'project-menu-styles';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    
                    @keyframes slideUp {
                        from { transform: translateY(20px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                    
                    .project-menu-btn {
                        display: flex;
                        align-items: center;
                        gap: 15px;
                        width: 100%;
                        padding: 15px 20px;
                        background: rgba(255, 255, 255, 0.05);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 12px;
                        color: white;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        text-align: left;
                    }
                    
                    .project-menu-btn:hover {
                        background: rgba(0, 255, 255, 0.15);
                        border-color: var(--accent);
                        transform: translateX(5px);
                    }
                    
                    .project-menu-btn.cloud {
                        background: rgba(0, 255, 255, 0.1);
                        border-color: var(--accent);
                    }
                    
                    .project-menu-btn.cancel {
                        background: rgba(255, 64, 96, 0.1);
                        border-color: var(--danger);
                    }
                    
                    .project-menu-btn.cancel:hover {
                        background: rgba(255, 64, 96, 0.2);
                    }
                `;
                document.head.appendChild(style);
            }
        }

        // Project Menu Function
        // Go back to main menu
        function goToMainMenu() {
            if (confirm('Projekt speichern und zum Hauptmenü zurückkehren?\n\nUngespeicherte Änderungen gehen verloren!')) {
                // Save current project first
                saveCurrentProject();
                
                // Stop any active Begehung
                if (begehungActive) {
                    stopBegehung();
                }
                
                // Clear session data
                localStorage.removeItem('currentProjectId');
                localStorage.removeItem('currentProjectName');
                localStorage.removeItem('currentKommune');
                
                // Hide app, show setup screen
                document.getElementById('app-container').style.display = 'none';
                document.getElementById('setup-screen').style.display = 'flex';
                
                // Switch to load tab
                showTab('load');
                
                showToast('💾 Projekt gespeichert. Zurück zum Menü!', 'success');
            }
        }
        
        window.showProjectMenu = function() {
            if (!currentProjectId) {
                showToast('❌ Kein Projekt geladen!', 'error');
                return;
            }
            
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 20px;
                padding: 30px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
                animation: slideUp 0.3s ease;
            `;
            
            modal.innerHTML = `
                <h2 style="color: var(--text-primary); margin-bottom: 10px; text-align: center; font-size: 24px;">
                    📂 Projekt-Menü
                </h2>
                <p style="color: var(--text-secondary); text-align: center; margin-bottom: 25px; font-size: 14px;">
                    ${currentProjectName} • ${currentKommune}
                </p>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button class="project-menu-btn" onclick="saveCurrentProject(); showToast('💾 Projekt lokal gespeichert!', 'success'); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">💾</span>
                        <div>
                            <div style="font-weight: bold;">Projekt speichern</div>
                            <div style="font-size: 11px; opacity: 0.8;">Lokal auf diesem Gerät</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn cloud" onclick="uploadProjectToCloud(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">☁️</span>
                        <div>
                            <div style="font-weight: bold;">In Cloud speichern</div>
                            <div style="font-size: 11px; opacity: 0.8;">Online verfügbar machen</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="showCloudProjectList(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📥</span>
                        <div>
                            <div style="font-weight: bold;">Cloud-Projekte anzeigen</div>
                            <div style="font-size: 11px; opacity: 0.8;">Gespeicherte Projekte laden</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="if(confirm('Zurück zur Projektauswahl? Ungespeicherte Änderungen gehen verloren!')) { saveCurrentProject(); document.getElementById('app-container').style.display = 'none'; document.getElementById('setup-screen').style.display = 'flex'; showTab('load'); } this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📂</span>
                        <div>
                            <div style="font-weight: bold;">Zu Projektauswahl</div>
                            <div style="font-size: 11px; opacity: 0.8;">Anderes Projekt öffnen</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn cancel" onclick="this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">❌</span>
                        <div>
                            <div style="font-weight: bold;">Abbrechen</div>
                            <div style="font-size: 11px; opacity: 0.8;">Menü schließen</div>
                        </div>
                    </button>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });
            
            // Add CSS for buttons if not already present
            if (!document.querySelector('#project-menu-styles')) {
                const style = document.createElement('style');
                style.id = 'project-menu-styles';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    
                    @keyframes slideUp {
                        from { transform: translateY(20px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                    
                    .project-menu-btn {
                        display: flex;
                        align-items: center;
                        gap: 15px;
                        width: 100%;
                        padding: 15px 20px;
                        background: var(--primary);
                        border: 1px solid var(--border);
                        border-radius: 12px;
                        color: var(--text-primary);
                        cursor: pointer;
                        transition: all 0.3s ease;
                        text-align: left;
                    }
                    
                    .project-menu-btn:hover {
                        background: var(--accent);
                        color: white;
                        transform: translateX(5px);
                    }
                    
                    .project-menu-btn.cloud {
                        background: #E8F5FF;
                        border-color: var(--accent);
                    }
                    
                    .project-menu-btn.cancel {
                        background: #FFE8E8;
                        border-color: #FF4444;
                    }
                    
                    .project-menu-btn.cancel:hover {
                        background: #FF4444;
                        color: white;
                    }
                `;
                document.head.appendChild(style);
            }
        };

        // Show Projects List (Local + Cloud)
        window.showProjectsList = async function() {
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
                overflow-y: auto;
                padding: 20px;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 20px;
                padding: 30px;
                max-width: 800px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
                animation: slideUp 0.3s ease;
            `;
            
            modal.innerHTML = `
                <h2 style="color: var(--text-primary); margin-bottom: 20px; text-align: center; font-size: 24px;">
                    📂 Projekte laden
                </h2>
                
                <div style="margin-bottom: 30px;">
                    <h3 style="color: var(--text-primary); margin-bottom: 15px;">💾 Lokale Projekte</h3>
                    <div id="local-projects-container" style="margin-bottom: 30px;">
                        <div style="text-align: center; color: var(--text-secondary);">Lade lokale Projekte...</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 30px;">
                    <h3 style="color: var(--text-primary); margin-bottom: 15px;">☁️ Cloud-Projekte</h3>
                    <div id="cloud-projects-container">
                        <div style="text-align: center; color: var(--text-secondary);">Lade Cloud-Projekte...</div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn secondary" onclick="this.closest('.modal-overlay').remove();">
                        ❌ Schließen
                    </button>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });
            
            // Load local projects
            if (db) {
                try {
                    const transaction = db.transaction(['projects'], 'readonly');
                    const store = transaction.objectStore('projects');
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const projects = request.result.sort((a, b) => new Date(b.lastModified || 0) - new Date(a.lastModified || 0));
                        const container = document.getElementById('local-projects-container');
                        
                        if (projects.length === 0) {
                            container.innerHTML = `
                                <div style="padding: 20px; background: var(--primary); border-radius: 12px; text-align: center; color: var(--text-secondary);">
                                    Keine lokalen Projekte vorhanden
                                </div>
                            `;
                        } else {
                            container.innerHTML = projects.map(project => `
                                <div style="padding: 15px; background: var(--primary); border-radius: 12px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                                     onmouseover="this.style.transform='translateX(5px)'; this.style.background='var(--accent)'; this.style.color='white';"
                                     onmouseout="this.style.transform='translateX(0)'; this.style.background='var(--primary)'; this.style.color='var(--text-primary)';"
                                     onclick="loadProject('${project.id}'); this.closest('.modal-overlay').remove();">
                                    <div style="font-weight: bold;">${project.name}</div>
                                    <div style="font-size: 14px; opacity: 0.8;">📍 ${project.kommune} • ${new Date(project.lastModified || project.created).toLocaleDateString('de-DE')}</div>
                                </div>
                            `).join('');
                        }
                    };
                } catch (error) {
                    console.error('Fehler beim Laden lokaler Projekte:', error);
                    document.getElementById('local-projects-container').innerHTML = `
                        <div style="padding: 20px; background: #FFE8E8; border-radius: 12px; text-align: center; color: #FF4444;">
                            Fehler beim Laden lokaler Projekte
                        </div>
                    `;
                }
            }
            
            // Load cloud projects
            try {
                const projects = await fetchAllCloudProjects();
                const container = document.getElementById('cloud-projects-container');
                
                if (projects.length === 0) {
                    container.innerHTML = `
                        <div style="padding: 20px; background: var(--primary); border-radius: 12px; text-align: center; color: var(--text-secondary);">
                            Keine Cloud-Projekte vorhanden
                        </div>
                    `;
                } else {
                    container.innerHTML = projects.map(project => `
                        <div style="padding: 15px; background: #E8F5FF; border-radius: 12px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                             onmouseover="this.style.transform='translateX(5px)'; this.style.background='var(--accent)'; this.style.color='white';"
                             onmouseout="this.style.transform='translateX(0)'; this.style.background='#E8F5FF'; this.style.color='var(--text-primary)';"
                             onclick="loadProjectFromCloud(${JSON.stringify(project).replace(/"/g, '&quot;')}); this.closest('.modal-overlay').remove();">
                            <div style="font-weight: bold;">☁️ ${project.name}</div>
                            <div style="font-size: 14px; opacity: 0.8;">📍 ${project.kommune} • ${project.uploadedAt ? new Date(project.uploadedAt).toLocaleDateString('de-DE') : 'Unbekannt'}</div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                console.error('Fehler beim Laden der Cloud-Projekte:', error);
                document.getElementById('cloud-projects-container').innerHTML = `
                    <div style="padding: 20px; background: #FFE8E8; border-radius: 12px; text-align: center; color: #FF4444;">
                        Fehler beim Laden der Cloud-Projekte
                    </div>
                `;
            }
        };

        // Cloud Sync Functions
        function generateProjectId() {
            // Generate unique project ID based on kommune, date and timestamp
            const date = new Date();
            const dateStr = date.toISOString().split('T')[0];
            const timestamp = date.getTime();
            const kommune = currentKommune.toLowerCase().replace(/[^a-z0-9]/g, '_');
            return `${kommune}_${dateStr}_${timestamp}`;
        }

        // Compress image to reduce size
        async function compressImage(base64String, maxWidth = 800, maxHeight = 800, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > maxWidth) {
                            height *= maxWidth / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width *= maxHeight / height;
                            height = maxHeight;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to JPEG with quality setting
                    canvas.toBlob((blob) => {
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            resolve(reader.result);
                        };
                        reader.readAsDataURL(blob);
                    }, 'image/jpeg', quality);
                };
                img.onerror = reject;
                img.src = base64String;
            });
        }
        
        // Helper function to upload images to Firebase Storage
        async function uploadImageToStorage(base64Data, path) {
            try {
                // Compress image first
                const compressed = await compressImage(base64Data, 800, 800, 0.7);
                console.log('📸 Image compressed from', Math.round(base64Data.length/1024), 'KB to', Math.round(compressed.length/1024), 'KB');
                
                // Convert base64 to blob
                const response = await fetch(compressed);
                const blob = await response.blob();
                
                // Upload to Storage - use imported functions directly!
                const storage = getStorage();
                const storageRef = ref(storage, path);
                await uploadBytes(storageRef, blob);
                
                // Get download URL
                const downloadURL = await getDownloadURL(storageRef);
                return downloadURL;
            } catch (error) {
                console.error('Image upload error:', error);
                throw error;
            }
        }

        async function fetchAllCloudProjects() {
            if (!window.firebase) {
                showToast('❌ Firebase nicht initialisiert!', 'error');
                return [];
            }

            try {
                const querySnapshot = await window.firebase.getDocs(
                    window.firebase.collection(window.firebase.db, 'projects')
                );
                
                const projects = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    projects.push({
                        id: doc.id,
                        ...data,
                        uploadedAt: data.uploadedAt?.toDate ? data.uploadedAt.toDate() : new Date(data.uploadedAt)
                    });
                });
                
                // Sort by upload date (newest first)
                projects.sort((a, b) => b.uploadedAt - a.uploadedAt);
                
                return projects;
            } catch (error) {
                console.error('Fehler beim Abrufen der Projekte:', error);
                showToast('❌ Projekte konnten nicht geladen werden', 'error');
                return [];
            }
        }

        // Firebase-kompatible Daten-Bereinigung
        function cleanDataForFirebase(data, maxDepth = 10, currentDepth = 0) {
            // Verhindere zu tiefe Verschachtelung
            if (currentDepth > maxDepth) {
                console.warn('🔄 Max depth reached, truncating data');
                return null;
            }
            
            // Handle null/undefined
            if (data === null || data === undefined) {
                return null;
            }
            
            // Handle primitive types
            if (typeof data !== 'object') {
                return data;
            }
            
            // Handle Arrays - FLATTEN nested arrays for Firestore!
            if (Array.isArray(data)) {
                // Check if this is a coordinate array [lng, lat]
                if (data.length === 2 && typeof data[0] === 'number' && typeof data[1] === 'number') {
                    return data; // Keep simple coordinate arrays
                }
                
                // For other arrays, check for nested arrays and flatten if needed
                const cleaned = data
                    .filter(item => item !== null && item !== undefined)
                    .map(item => {
                        // If item is an array of arrays (nested), flatten it
                        if (Array.isArray(item) && item.some(subItem => Array.isArray(subItem))) {
                            console.warn('⚠️ Flattening nested array for Firestore');
                            // Return flattened structure
                            return item.flat(1);
                        }
                        return cleanDataForFirebase(item, maxDepth, currentDepth + 1);
                    })
                    .filter(item => item !== null);
                
                return cleaned;
            }
            
            // Handle Objects
            const cleaned = {};
            for (const [key, value] of Object.entries(data)) {
                // Skip problematic properties
                if (key.startsWith('_') || 
                    typeof value === 'function' || 
                    value instanceof HTMLElement ||
                    value instanceof Event ||
                    (typeof value === 'object' && value?.constructor && 
                     !['Object', 'Array'].includes(value.constructor.name))) {
                    continue;
                }
                
                // Clean the value
                const cleanedValue = cleanDataForFirebase(value, maxDepth, currentDepth + 1);
                if (cleanedValue !== null && cleanedValue !== undefined) {
                    cleaned[key] = cleanedValue;
                }
            }
            
            return cleaned;
        }
        
        // Spezielle Bereinigung für begehungTracks
        function sanitizeBegehungTracks(tracks) {
            if (!tracks || typeof tracks !== 'object') {
                return { professional: [], children: [] };
            }
            
            const sanitized = { professional: [], children: [] };
            
            ['professional', 'children'].forEach(type => {
                if (Array.isArray(tracks[type])) {
                    sanitized[type] = tracks[type].map(track => {
                        if (!track || typeof track !== 'object') return null;
                        
                        return {
                            id: track.id || `track_${Date.now()}`,
                            type: track.type || type,
                            // Vereinfache GPS-Track zu simplen Koordinaten - FLACH, keine nested arrays!
                            track: Array.isArray(track.track) ? 
                                track.track.map(point => {
                                    if (Array.isArray(point)) {
                                        // Flatten nested arrays - nur [lng, lat] als numbers
                                        return [
                                            typeof point[0] === 'number' ? point[0] : parseFloat(point[0]) || 0,
                                            typeof point[1] === 'number' ? point[1] : parseFloat(point[1]) || 0
                                        ];
                                    }
                                    if (point && typeof point === 'object') {
                                        return [
                                            typeof point.lng === 'number' ? point.lng : parseFloat(point.lng) || 0,
                                            typeof point.lat === 'number' ? point.lat : parseFloat(point.lat) || 0
                                        ];
                                    }
                                    return null;
                                }).filter(p => p && p[0] && p[1]) : [],
                            // Marker ohne Base64-Fotos
                            markers: Array.isArray(track.markers) ? 
                                track.markers.map(marker => ({
                                    id: marker.id,
                                    type: marker.type,
                                    title: marker.title,
                                    lat: marker.lat,
                                    lng: marker.lng,
                                    timestamp: marker.timestamp,
                                    // Entferne Base64-Fotos (werden separat hochgeladen)
                                    hasPhoto: !!marker.photo
                                })) : [],
                            distance: track.distance || 0,
                            duration: track.duration || 0,
                            timestamp: track.timestamp || Date.now(),
                            kommune: track.kommune,
                            projectId: track.projectId
                        };
                    }).filter(track => track !== null);
                }
            });
            
            return sanitized;
        }

        async function uploadProjectToCloud() {
            if (!currentProjectId || !window.firebase) {
                showToast('❌ Firebase nicht initialisiert!', 'error');
                return;
            }

            try {
                showToast('☁️ Lade Projekt in die Cloud...', 'info');
                
                // Update cloud status
                const cloudStatusEl = document.getElementById('cloud-status');
                if (cloudStatusEl) {
                    cloudStatusEl.textContent = 'Synchronisiere...';
                    cloudStatusEl.className = 'status-warning';
                }
                
                // Generate unique project ID
                const cloudProjectId = generateProjectId();
                
                // Gather all project data
                const projectData = await gatherProjectData();
                
                // Process images and audio first - upload to Firebase Storage
                const processedMarkers = [];
                for (const marker of projectData.customMarkers) {
                    const processedMarker = { ...marker };
                    
                    // Upload photo if exists
                    if (marker.photo && marker.photo.startsWith('data:image')) {
                        try {
                            const photoUrl = await uploadImageToStorage(marker.photo, `${cloudProjectId}/photos/${marker.id}_${Date.now()}.jpg`);
                            processedMarker.photo = photoUrl;
                            processedMarker.hasPhoto = true;
                        } catch (err) {
                            console.error('Photo upload failed:', err);
                            processedMarker.photo = null; // Remove if upload fails
                        }
                    }
                    
                    // Upload audio if exists
                    if (marker.audio && marker.audio.startsWith('data:audio')) {
                        try {
                            // Convert audio base64 to blob
                            const response = await fetch(marker.audio);
                            const blob = await response.blob();
                            
                            // Upload to Storage - use imported functions directly!
                            const storage = getStorage();
                            const audioRef = ref(storage, `${cloudProjectId}/audio/${marker.id}_${Date.now()}.webm`);
                            await uploadBytes(audioRef, blob);
                            
                            // Get download URL
                            const audioUrl = await getDownloadURL(audioRef);
                            processedMarker.audioUrl = audioUrl;
                            processedMarker.hasAudio = true;
                            delete processedMarker.audio; // Remove base64 data
                        } catch (err) {
                            console.error('Audio upload failed:', err);
                            delete processedMarker.audio; // Remove if upload fails
                        }
                    }
                    
                    processedMarkers.push(processedMarker);
                }
                
                // Prepare ONLY user-created data for cloud (exclude OSM data) - SANITIZED
                let cloudData = {
                    // Basic project info
                    name: projectData.name,
                    kommune: projectData.kommune,
                    created: projectData.created,
                    cloudProjectId: cloudProjectId,
                    localProjectId: currentProjectId,
                    uploadedAt: window.firebase.serverTimestamp(),
                    
                    // User-created content ONLY
                    customMarkers: processedMarkers || [], // User markers with processed photos
                    routes: projectData.routes || [], // User-drawn routes
                    gpsTracks: projectData.gpsTracks || [], // GPS tracking data
                    gpsTrack: projectData.gpsTrack || [], // Current GPS track
                    begehungTracks: projectData.begehungTracks || { professional: [], children: [] }, // NEU: Begehungsrouten (bereits sanitized)
                    
                    // Map state
                    mapCenter: projectData.mapCenter,
                    mapZoom: projectData.mapZoom,
                    
                    // Statistics (without OSM data)
                    stats: {
                        customMarkers: (processedMarkers || []).length,
                        savedRoutes: (projectData.routes || []).length,
                        gpsTrackPoints: (projectData.gpsTrack || []).length,
                        begehungRoutesCount: (projectData.begehungTracks?.professional?.length || 0) + (projectData.begehungTracks?.children?.length || 0)
                    },
                    
                    // Device info
                    deviceInfo: navigator.userAgent,
                    uploaderInfo: navigator.platform
                    
                    // IMPORTANT: NO osmData field - will be reloaded from OSM when needed
                };
                
                // FINAL SANITIZATION: Clean all data for Firebase compatibility
                console.log('🔄 Original data size:', JSON.stringify(cloudData).length, 'characters');
                cloudData = cleanDataForFirebase(cloudData);
                console.log('🔄 Cleaned data size:', JSON.stringify(cloudData).length, 'characters');
                
                // Check document size (Firebase limit: 1MB)
                const dataSize = JSON.stringify(cloudData).length;
                if (dataSize > 1000000) { // 1MB
                    throw new Error(`Document too large: ${Math.round(dataSize/1024)}KB (max 1MB)`);
                }
                
                // Now upload the document (cleaned and size-checked)
                await window.firebase.setDoc(
                    window.firebase.doc(window.firebase.db, 'projects', cloudProjectId),
                    cloudData
                );
                
                showToast(`✅ Projekt in Cloud gespeichert!`, 'success');
                
                // Update cloud status
                const cloudStatusElem = document.getElementById('cloud-status');
                if (cloudStatusElem) {
                    cloudStatusElem.textContent = `Synchronisiert`;
                    cloudStatusElem.className = 'status-online';
                }
                
                // Store cloud project ID locally for reference
                localStorage.setItem(`cloud_${currentProjectId}`, cloudProjectId);
                
                // Show success message
                alert(`Projekt erfolgreich in die Cloud hochgeladen!\n\n${currentProjectName} (${currentKommune})\n\nDu kannst es jederzeit über "Cloud-Projekte anzeigen" wieder laden.`);
                
            } catch (error) {
                console.error('Cloud Upload Fehler:', error);
                
                // Spezifische Fehlermeldungen für bessere Diagnose
                let errorMessage = 'Unbekannter Fehler';
                if (error.message.includes('Invalid nested entity')) {
                    errorMessage = 'Datenstruktur-Problem: Einige Daten konnten nicht verarbeitet werden';
                } else if (error.message.includes('Document too large')) {
                    errorMessage = error.message;
                } else if (error.message.includes('Permission denied')) {
                    errorMessage = 'Keine Berechtigung für Cloud-Upload';
                } else if (error.message.includes('network')) {
                    errorMessage = 'Netzwerkfehler - Internetverbindung prüfen';
                } else {
                    errorMessage = error.message || 'Unbekannter Upload-Fehler';
                }
                
                showToast('❌ Upload fehlgeschlagen: ' + errorMessage, 'error');
                
                // Update cloud status on error
                const cloudStatusElem = document.getElementById('cloud-status');
                if (cloudStatusElem) {
                    cloudStatusElem.textContent = 'Fehler';
                    cloudStatusElem.className = 'status-offline';
                }
                
                // Show detailed error for debugging
                console.log('📊 Debug Info:', {
                    errorType: error.constructor.name,
                    message: error.message,
                    stack: error.stack,
                    projectId: currentProjectId,
                    projectName: currentProjectName
                });
            }
        }

        window.showCloudProjectList = async function() {
            // Use cloud-projects-list if it exists, otherwise fall back to projects-list
            let projectsList = document.getElementById('cloud-projects-list');
            if (!projectsList) {
                projectsList = document.getElementById('projects-list');
            }
            
            if (!window.firebase) {
                showToast('❌ Firebase nicht initialisiert!', 'error');
                if (projectsList) {
                    projectsList.innerHTML = `
                        <div class="no-projects" style="color: #1d1d1f; padding: 20px; text-align: center; background: #f5f5f7; border-radius: 12px; border: 1px solid #d2d2d7;">
                            <p style="font-size: 18px; margin-bottom: 10px;">❌ Firebase nicht initialisiert</p>
                            <p style="font-size: 14px; color: #888;">Bitte laden Sie die Seite neu</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Show loading message in projects list
            if (projectsList) {
                projectsList.innerHTML = '<div class="loading-projects">☁️ Lade Cloud-Projekte...</div>';
            }
            
            showToast('☁️ Lade Cloud-Projekte...', 'info');
            
            // Fetch all projects
            const projects = await fetchAllCloudProjects();
            
            if (projects.length === 0) {
                // Show message in projects list instead of modal
                if (projectsList) {
                    projectsList.innerHTML = `
                        <div class="no-projects" style="color: #1d1d1f; padding: 20px; text-align: center; background: #f5f5f7; border-radius: 12px; border: 1px solid #d2d2d7;">
                            <p style="font-size: 18px; margin-bottom: 10px;">☁️ Keine Cloud-Projekte vorhanden</p>
                            <p style="font-size: 14px; color: #888;">Lade ein Projekt hoch mit "In Cloud speichern"</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Create modal for project selection
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: linear-gradient(135deg, #1a1b3a 0%, #0a0b1e 100%);
                border: 2px solid var(--accent);
                border-radius: 20px;
                padding: 30px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
                animation: slideUp 0.3s ease;
            `;
            
            // Create project cards HTML
            const projectCardsHTML = projects.map(p => {
                const uploadDate = p.uploadedAt ? new Date(p.uploadedAt).toLocaleDateString('de-DE') : 'Unbekannt';
                const uploadTime = p.uploadedAt ? new Date(p.uploadedAt).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : '';
                const markerCount = p.stats?.customMarkers || 0;
                const routeCount = p.stats?.savedRoutes || 0;
                
                return `
                    <div class="cloud-project-card" style="
                        background: rgba(255, 255, 255, 0.05);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 12px;
                        padding: 15px;
                        margin-bottom: 12px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.background='rgba(0, 255, 255, 0.15)'; this.style.borderColor='var(--accent)'; this.style.transform='translateX(5px)';" 
                      onmouseout="this.style.background='rgba(255, 255, 255, 0.05)'; this.style.borderColor='rgba(255, 255, 255, 0.1)'; this.style.transform='translateX(0)';"
                      onclick="loadProjectFromCloud(${JSON.stringify(p).replace(/"/g, '&quot;')}); this.closest('.modal-overlay').remove();">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                            <div>
                                <h3 style="color: var(--accent); margin: 0; font-size: 18px;">
                                    ☁️ ${p.name || 'Unbenannt'}
                                </h3>
                                <p style="color: #ccc; margin: 4px 0; font-size: 14px;">
                                    📍 ${p.kommune || 'Unbekannt'}
                                </p>
                            </div>
                            <div style="text-align: right;">
                                <p style="color: #888; margin: 0; font-size: 12px;">
                                    📅 ${uploadDate}
                                </p>
                                <p style="color: #888; margin: 0; font-size: 12px;">
                                    🕐 ${uploadTime}
                                </p>
                            </div>
                        </div>
                        <div style="display: flex; gap: 15px; font-size: 12px; color: #aaa;">
                            <span>📍 ${markerCount} Marker</span>
                            <span>🛤️ ${routeCount} Routen</span>
                            <span>📸 ${p.customMarkers?.filter(m => m.photo).length || 0} Fotos</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <h2 style="color: var(--accent); margin-bottom: 10px; text-align: center; font-size: 24px;">
                    ☁️ Cloud-Projekte
                </h2>
                <p style="color: #888; text-align: center; margin-bottom: 25px; font-size: 14px;">
                    Wähle ein Projekt zum Laden
                </p>
                
                <div style="margin-bottom: 20px;">
                    ${projectCardsHTML}
                </div>
                
                <button class="btn secondary" onclick="this.closest('.modal-overlay').remove();" style="width: 100%;">
                    ❌ Abbrechen
                </button>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            // Close on overlay click
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.remove();
                }
            });
        }

        async function loadProjectFromCloud(cloudProject) {
            if (!window.firebase) {
                showToast('❌ Firebase nicht initialisiert!', 'error');
                return;
            }
            
            try {
                showToast('📥 Lade Projekt aus der Cloud...', 'info');
                
                // Reset tracks when loading cloud project
                begehungTracks = { professional: [], children: [] };
                gpsTrack = [];
                
                const cloudData = cloudProject;
                
                // Download photos from Storage if any
                if (cloudData.customMarkers) {
                    for (const marker of cloudData.customMarkers) {
                        if (marker.cloudPhotoURL) {
                            try {
                                // Download photo and convert to base64
                                const response = await fetch(marker.cloudPhotoURL);
                                const blob = await response.blob();
                                const reader = new FileReader();
                                const base64 = await new Promise((resolve) => {
                                    reader.onload = () => resolve(reader.result);
                                    reader.readAsDataURL(blob);
                                });
                                marker.photo = base64;
                            } catch (photoError) {
                                console.error('Foto-Download Fehler:', photoError);
                            }
                        }
                    }
                }
                
                // Save to local database
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                
                const localProject = {
                    id: cloudData.localProjectId || 'cloud_' + Date.now(),
                    name: cloudData.name,
                    kommune: cloudData.kommune,
                    created: cloudData.created,
                    lastModified: new Date().toISOString(),
                    cloudProjectId: cloudData.cloudProjectId || cloudData.id,
                    isCloudProject: true,  // Mark as cloud project
                    cloudSyncDate: new Date().toISOString(),
                    stats: {
                        totalPOIs: cloudData.osmData?.length || 0,
                        customMarkers: cloudData.customMarkers?.length || 0,
                        savedRoutes: cloudData.routes?.length || 0,
                        gpsTrackPoints: cloudData.gpsTrack?.length || 0
                    }
                };
                
                store.put(localProject);
                
                // Store user-created data in IndexedDB
                if (cloudData.customMarkers) {
                    const markerTransaction = db.transaction(['customMarkers'], 'readwrite');
                    const markerStore = markerTransaction.objectStore('customMarkers');
                    for (const marker of cloudData.customMarkers) {
                        markerStore.put(marker);
                    }
                }
                
                if (cloudData.routes) {
                    const routeTransaction = db.transaction(['routes'], 'readwrite');
                    const routeStore = routeTransaction.objectStore('routes');
                    for (const route of cloudData.routes) {
                        routeStore.put(route);
                    }
                }
                
                if (cloudData.gpsTracks) {
                    const gpsTransaction = db.transaction(['gpsTracks'], 'readwrite');
                    const gpsStore = gpsTransaction.objectStore('gpsTracks');
                    for (const track of cloudData.gpsTracks) {
                        gpsStore.put(track);
                    }
                }
                
                // Restore GPS track
                if (cloudData.gpsTrack) {
                    gpsTrack = cloudData.gpsTrack;
                }
                
                // WICHTIG: Restore Begehung tracks (professional and children routes)
                if (cloudData.begehungTracks) {
                    begehungTracks.professional = cloudData.begehungTracks.professional || [];
                    begehungTracks.children = cloudData.begehungTracks.children || [];
                    
                    // Save begehung tracks to IndexedDB
                    const begehungTransaction = db.transaction(['gpsTracks'], 'readwrite');
                    const begehungStore = begehungTransaction.objectStore('gpsTracks');
                    
                    // Save professional tracks
                    for (const track of begehungTracks.professional) {
                        const trackData = {
                            ...track,
                            id: track.id || `begehung_professional_${Date.now()}_${Math.random()}`,
                            type: 'professional',
                            kommune: cloudData.kommune,
                            projectId: localProject.id
                        };
                        begehungStore.put(trackData);
                    }
                    
                    // Save children tracks
                    for (const track of begehungTracks.children) {
                        const trackData = {
                            ...track,
                            id: track.id || `begehung_children_${Date.now()}_${Math.random()}`,
                            type: 'children',
                            kommune: cloudData.kommune,
                            projectId: localProject.id
                        };
                        begehungStore.put(trackData);
                    }
                    
                    console.log('✅ Begehungsrouten wiederhergestellt:', {
                        professional: begehungTracks.professional.length,
                        children: begehungTracks.children.length
                    });
                }
                
                // Set project variables
                currentProjectId = localProject.id;
                currentProjectName = localProject.name;
                currentKommune = localProject.kommune;
                
                // Store cloud project ID for future syncing
                localStorage.setItem(`cloud_${currentProjectId}`, cloudData.cloudProjectId || cloudData.id);
                
                // Update UI
                document.getElementById('project-name-display').textContent = `📂 ${currentProjectName}`;
                
                showToast('📥 Projekt geladen, lade OSM-Daten...', 'info');
                
                // Get location and reload OSM data fresh from OpenStreetMap
                const location = await geocodeKommune(currentKommune);
                if (location) {
                    // Hide setup screen and show app
                    document.getElementById('setup-screen').style.display = 'none';
                    document.getElementById('app-container').style.display = 'block';
                    
                    // Initialize map with fresh OSM data
                    await initMap(location.lat, location.lng, currentKommune);
                    
                    // Restore map position if saved
                    if (cloudData.mapCenter && cloudData.mapZoom) {
                        map.setCenter(cloudData.mapCenter);
                        map.setZoom(cloudData.mapZoom);
                    }
                    
                    // Display begehung tracks after map is loaded
                    setTimeout(() => {
                        loadSavedBegehungen();
                        displayBegehungTracks();
                    }, 1500);
                }
                
                showToast('✅ Projekt aus Cloud geladen und lokal gespeichert!', 'success');
                
                // Show success message
                setTimeout(() => {
                    showToast('💡 Das Projekt ist jetzt auch in deiner lokalen Projektliste verfügbar', 'info');
                }, 2000);
                
            } catch (error) {
                console.error('Cloud Download Fehler:', error);
                showToast('❌ Download fehlgeschlagen: ' + error.message, 'error');
            }
        }

        function clearAll() {
            if (confirm('Alle eigenen Markierungen und GPS-Track löschen?')) {
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.clear();
                
                // Clear GPS track
                gpsTrack = [];
                if (map.getSource('gps-track')) {
                    map.getSource('gps-track').setData({
                        type: 'LineString',
                        coordinates: []
                    });
                }
                
                transaction.oncomplete = () => {
                    loadCustomMarkers();
                    updateStats();
                    showToast('🗑️ Alle Daten gelöscht', 'success');
                };
            }
        }

        // Function to capture map as image
        async function captureMapScreenshot() {
            return new Promise((resolve) => {
                map.once('render', () => {
                    const canvas = map.getCanvas();
                    resolve(canvas.toDataURL('image/png'));
                });
                map.triggerRepaint();
            });
        }

        async function generateReport() {
            if (!db || !map) return;
            
            showToast('📸 Erstelle Report mit Karten-Screenshot...', 'info');
            
            // Capture map screenshot
            const mapCanvas = await captureMapScreenshot();
            
            const transaction = db.transaction(['osmData', 'customMarkers', 'gpsTracks'], 'readonly');
            const osmStore = transaction.objectStore('osmData');
            const markerStore = transaction.objectStore('customMarkers');
            const trackStore = transaction.objectStore('gpsTracks');
            
            const osmRequest = osmStore.getAll();
            const markerRequest = markerStore.getAll();
            const trackRequest = trackStore.getAll();
            
            osmRequest.onsuccess = () => {
                markerRequest.onsuccess = () => {
                    trackRequest.onsuccess = () => {
                        // FILTER: Only include data for current kommune
                        const allOsmData = osmRequest.result;
                        const osmData = allOsmData.filter(item => item.kommune === currentKommune);
                        
                        const allMarkers = markerRequest.result;
                        const markers = allMarkers.filter(m => m.kommune === currentKommune);
                        
                        const begehungen = trackRequest.result;
                        
                        // Count categories
                        const counts = {};
                        osmData.forEach(item => {
                            counts[item.type] = (counts[item.type] || 0) + 1;
                        });
                        
                        // Sort markers by timestamp for numbering
                        const photosWithNumbers = markers
                            .filter(m => m.photo)
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                            .map((m, index) => ({ ...m, photoNumber: index + 1 }));
                        
                        // Create report HTML
                        const reportHTML = `
                            <!DOCTYPE html>
                            <html lang="de">
                            <head>
                                <meta charset="UTF-8">
                                <title>Kinderfreundlichkeits-Report ${currentKommune}</title>
                                <style>
                                    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
                                    h1 { color: #0a0b1e; border-bottom: 3px solid #00ffff; padding-bottom: 10px; }
                                    h2 { color: #00ffff; margin-top: 30px; }
                                    .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 20px 0; }
                                    .stat-card { background: #f0f0f0; padding: 15px; border-radius: 8px; border-left: 4px solid #00ffff; }
                                    .stat-value { font-size: 24px; font-weight: bold; color: #0a0b1e; }
                                    .stat-label { color: #666; font-size: 14px; }
                                    .marker-list { margin: 20px 0; }
                                    .marker-item { background: #fff; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
                                    .priority-urgent { border-left: 4px solid #ff4060; }
                                    .priority-high { border-left: 4px solid #ff8000; }
                                    .priority-medium { border-left: 4px solid #ffdd00; }
                                    .priority-low { border-left: 4px solid #00ff80; }
                                    .footer { margin-top: 50px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }
                                </style>
                            </head>
                            <body>
                                <h1>🌟 Kinderfreundlichkeits-Analyse</h1>
                                <p><strong>Kommune:</strong> ${currentKommune}</p>
                                <p><strong>Projekt:</strong> ${currentProjectName}</p>
                                <p><strong>Erstellt:</strong> ${new Date().toLocaleDateString('de-DE')}</p>
                                
                                <h2>🗺️ Übersichtskarte</h2>
                                <div style="text-align: center; margin: 20px 0;">
                                    <img src="${mapCanvas}" style="max-width: 100%; border: 2px solid #ddd; border-radius: 8px;" alt="Karten-Übersicht">
                                </div>
                                
                                <h2>📊 Statistiken</h2>
                                <div class="stat-grid">
                                    <div class="stat-card">
                                        <div class="stat-value">${counts.schools || 0}</div>
                                        <div class="stat-label">🏫 Schulen & Kitas</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value">${counts.playgrounds || 0}</div>
                                        <div class="stat-label">🎮 Spielplätze</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value">${counts.parks || 0}</div>
                                        <div class="stat-label">🌳 Parks & Grünflächen</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value">${counts.medical || 0}</div>
                                        <div class="stat-label">🏥 Medizinische Versorgung</div>
                                    </div>
                                </div>
                                
                                <h2>🚶 Begehungen</h2>
                                <p>${begehungen.length} Begehung(en) durchgeführt</p>
                                ${begehungen.map(b => `
                                    <div class="marker-item">
                                        <strong>${new Date(b.startTime).toLocaleDateString('de-DE')}</strong><br>
                                        Dauer: ${formatDuration(b.duration / 1000)}, 
                                        Distanz: ${formatDistance(b.distance)},
                                        Punkte: ${b.trackPoints}
                                    </div>
                                `).join('')}
                                
                                <h2>📍 Erfasste Marker (${markers.length})</h2>
                                <div class="marker-list">
                                    ${markers.map(m => {
                                        const photoInfo = photosWithNumbers.find(p => p.id === m.id);
                                        return `
                                        <div class="marker-item ${m.priority ? 'priority-' + m.priority : ''}">
                                            <strong>${m.title}</strong> (${getCategoryName(m.category)})
                                            ${photoInfo ? `<span style="background: #00ffff; color: #0a0b1e; padding: 2px 6px; border-radius: 3px; margin-left: 10px;">Foto #${photoInfo.photoNumber}</span>` : ''}<br>
                                            ${m.description ? m.description + '<br>' : ''}
                                            <small>${new Date(m.timestamp).toLocaleDateString('de-DE')}</small>
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                                
                                ${photosWithNumbers.length > 0 ? `
                                <h2>📷 Fotos (${photosWithNumbers.length})</h2>
                                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                                    ${photosWithNumbers.map(photo => `
                                        <div style="text-align: center;">
                                            <img src="${photo.photo}" style="width: 100%; border-radius: 8px; border: 2px solid #ddd;" alt="Foto ${photo.photoNumber}">
                                            <div style="margin-top: 5px;">
                                                <strong>Foto #${photo.photoNumber}</strong><br>
                                                <small>${photo.title}</small><br>
                                                <small style="color: #666;">${new Date(photo.timestamp).toLocaleDateString('de-DE')}</small>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                ` : ''}
                                
                                <div class="footer">
                                    Generiert mit Kinderfreundlichkeits-Analyzer Pro | © 2024
                                </div>
                            </body>
                            </html>
                        `;
                        
                        // Create and download HTML file
                        const blob = new Blob([reportHTML], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `report-${currentKommune}-${new Date().toISOString().split('T')[0]}.html`;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        showToast('📊 Report generiert und heruntergeladen!', 'success');
                    };
                };
            };
        }

        // Helper functions
        function editMarker(markerId) {
            showToast('✏️ Bearbeiten-Feature kommt bald!', 'info');
        }

        function deleteMarker(markerId) {
            if (confirm('Marker wirklich löschen?')) {
                const transaction = db.transaction(['customMarkers'], 'readwrite');
                const store = transaction.objectStore('customMarkers');
                store.delete(markerId);
                
                transaction.oncomplete = () => {
                    loadCustomMarkers();
                    updateStats();
                    showToast('🗑️ Marker gelöscht', 'success');
                };
            }
        }

        function addReviewToPlace(placeId) {
            showToast('⭐ Bewertungs-Feature kommt bald!', 'info');
        }

        function reportStreetProblem(streetId) {
            showToast('🚧 Straßen-Problem-Meldung: Feature kommt bald!', 'info');
        }

        // Show export dialog with multiple options
        function showExportDialog() {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <h2>📤 Export-Optionen</h2>
                <p style="color: var(--text-secondary); text-align: center; margin-bottom: 25px;">
                    ${currentProjectName} • ${currentKommune}
                </p>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button class="project-menu-btn" onclick="exportPhotosAsIndividualFiles(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📸</span>
                        <div>
                            <div style="font-weight: bold;">Fotos exportieren</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als einzelne JPG-Dateien</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="exportAudioAsFiles(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">🎤</span>
                        <div>
                            <div style="font-weight: bold;">Sprachnotizen exportieren</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als MP3/Audio-Dateien</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="exportNotesAsFile(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📝</span>
                        <div>
                            <div style="font-weight: bold;">Text-Notizen exportieren</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als strukturierte Textdatei</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="exportAllAsZip(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">📦</span>
                        <div>
                            <div style="font-weight: bold;">Alles exportieren</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als ZIP-Archiv mit allen Daten</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="exportPhotosAsZip(); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">🖼️</span>
                        <div>
                            <div style="font-weight: bold;">Foto-Galerie (HTML)</div>
                            <div style="font-size: 11px; opacity: 0.8;">Als interaktive Webseite</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn" onclick="exportProject('${currentProjectId}'); this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">💾</span>
                        <div>
                            <div style="font-weight: bold;">Projekt-Backup (JSON)</div>
                            <div style="font-size: 11px; opacity: 0.8;">Komplettes Projekt zum Reimport</div>
                        </div>
                    </button>
                    
                    <button class="project-menu-btn cancel" onclick="this.closest('.modal-overlay').remove();">
                        <span style="font-size: 20px;">❌</span>
                        <div>
                            <div style="font-weight: bold;">Abbrechen</div>
                            <div style="font-size: 11px; opacity: 0.8;">Dialog schließen</div>
                        </div>
                    </button>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
        }

        // Export photos as individual JPG files
        async function exportPhotosAsIndividualFiles() {
            if (!db || !window.JSZip) {
                showToast('❌ Export-Bibliothek nicht geladen!', 'error');
                return;
            }
            
            showToast('📦 Erstelle Foto-Export...', 'info');
            
            const transaction = db.transaction(['customMarkers'], 'readonly');
            const store = transaction.objectStore('customMarkers');
            const index = store.index('kommune');
            const request = index.getAll(currentKommune);
            
            request.onsuccess = async () => {
                const markers = request.result;
                const photos = markers.filter(m => m.photo);
                
                if (photos.length === 0) {
                    showToast('❌ Keine Fotos zum Exportieren vorhanden!', 'error');
                    return;
                }
                
                const zip = new JSZip();
                const photosFolder = zip.folder("fotos");
                
                for (let i = 0; i < photos.length; i++) {
                    const photo = photos[i];
                    const lat = photo.lat ? photo.lat.toFixed(6) : 'unknown';
                    const lng = photo.lng ? photo.lng.toFixed(6) : 'unknown';
                    const date = new Date(photo.timestamp).toISOString().split('T')[0];
                    const time = new Date(photo.timestamp).toTimeString().split(' ')[0].replace(/:/g, '-');
                    
                    // Create filename with location and timestamp
                    const filename = `foto_${lat}_${lng}_${date}_${time}.jpg`;
                    
                    // Convert base64 to binary
                    const base64Data = photo.photo.split(',')[1];
                    photosFolder.file(filename, base64Data, {base64: true});
                }
                
                // Generate and download ZIP
                const content = await zip.generateAsync({type: "blob"});
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fotos-${currentKommune}-${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`📷 ${photos.length} Fotos exportiert!`, 'success');
            };
        }

        // Export audio files
        async function exportAudioAsFiles() {
            if (!db || !window.JSZip) {
                showToast('❌ Export-Bibliothek nicht geladen!', 'error');
                return;
            }
            
            showToast('📦 Erstelle Audio-Export...', 'info');
            
            const transaction = db.transaction(['customMarkers'], 'readonly');
            const store = transaction.objectStore('customMarkers');
            const index = store.index('kommune');
            const request = index.getAll(currentKommune);
            
            request.onsuccess = async () => {
                const markers = request.result;
                const audioMarkers = markers.filter(m => m.audioUrl || m.audio);
                
                if (audioMarkers.length === 0) {
                    showToast('❌ Keine Sprachnotizen zum Exportieren vorhanden!', 'error');
                    return;
                }
                
                const zip = new JSZip();
                const audioFolder = zip.folder("sprachnotizen");
                
                for (let i = 0; i < audioMarkers.length; i++) {
                    const marker = audioMarkers[i];
                    const lat = marker.lat ? marker.lat.toFixed(6) : 'unknown';
                    const lng = marker.lng ? marker.lng.toFixed(6) : 'unknown';
                    const date = new Date(marker.timestamp).toISOString().split('T')[0];
                    const time = new Date(marker.timestamp).toTimeString().split(' ')[0].replace(/:/g, '-');
                    
                    // Create filename with location and timestamp
                    const filename = `audio_${lat}_${lng}_${date}_${time}.webm`;
                    
                    if (marker.audio) {
                        // Convert base64 to binary
                        const base64Data = marker.audio.split(',')[1];
                        audioFolder.file(filename, base64Data, {base64: true});
                    }
                }
                
                // Generate and download ZIP
                const content = await zip.generateAsync({type: "blob"});
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sprachnotizen-${currentKommune}-${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`🎤 ${audioMarkers.length} Sprachnotizen exportiert!`, 'success');
            };
        }

        // Export notes as structured text file
        async function exportNotesAsFile() {
            if (!db) return;
            
            showToast('📦 Erstelle Notizen-Export...', 'info');
            
            const transaction = db.transaction(['customMarkers'], 'readonly');
            const store = transaction.objectStore('customMarkers');
            const index = store.index('kommune');
            const request = index.getAll(currentKommune);
            
            request.onsuccess = () => {
                const markers = request.result;
                const notes = markers.filter(m => m.type === 'note' || m.description);
                
                if (notes.length === 0) {
                    showToast('❌ Keine Notizen zum Exportieren vorhanden!', 'error');
                    return;
                }
                
                // Create structured text content
                let textContent = `NOTIZEN-EXPORT\n`;
                textContent += `==============\n\n`;
                textContent += `Projekt: ${currentProjectName}\n`;
                textContent += `Kommune: ${currentKommune}\n`;
                textContent += `Export-Datum: ${new Date().toLocaleString('de-DE')}\n`;
                textContent += `Anzahl Notizen: ${notes.length}\n\n`;
                textContent += `----------------------------------------\n\n`;
                
                notes.forEach((note, index) => {
                    const lat = note.lat ? note.lat.toFixed(6) : 'unbekannt';
                    const lng = note.lng ? note.lng.toFixed(6) : 'unbekannt';
                    const date = new Date(note.timestamp).toLocaleString('de-DE');
                    
                    textContent += `NOTIZ ${index + 1}\n`;
                    textContent += `--------\n`;
                    textContent += `Titel: ${note.title || 'Ohne Titel'}\n`;
                    textContent += `Datum/Zeit: ${date}\n`;
                    textContent += `GPS-Koordinaten: ${lat}, ${lng}\n`;
                    textContent += `Kategorie: ${note.category || 'Allgemein'}\n`;
                    if (note.begehungType) {
                        textContent += `Begehungstyp: ${note.begehungType === 'children' ? 'Kinder' : 'Fachkräfte'}\n`;
                    }
                    textContent += `\nInhalt:\n${note.description || note.note || 'Kein Inhalt'}\n\n`;
                    textContent += `----------------------------------------\n\n`;
                });
                
                // Download as text file
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `notizen-${currentKommune}-${new Date().toISOString().split('T')[0]}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`📝 ${notes.length} Notizen exportiert!`, 'success');
            };
        }

        // Export everything as ZIP
        async function exportAllAsZip() {
            if (!db || !window.JSZip) {
                showToast('❌ Export-Bibliothek nicht geladen!', 'error');
                return;
            }
            
            showToast('📦 Erstelle Komplett-Export...', 'info');
            
            const transaction = db.transaction(['customMarkers', 'gpsTracks', 'customDrawings'], 'readonly');
            const markersStore = transaction.objectStore('customMarkers');
            const tracksStore = transaction.objectStore('gpsTracks');
            const drawingsStore = transaction.objectStore('customDrawings');
            const index = markersStore.index('kommune');
            
            const markersRequest = index.getAll(currentKommune);
            const tracksRequest = tracksStore.getAll();
            const drawingsRequest = drawingsStore.index('kommune').getAll(currentKommune);
            
            Promise.all([
                new Promise(resolve => { markersRequest.onsuccess = () => resolve(markersRequest.result); }),
                new Promise(resolve => { tracksRequest.onsuccess = () => resolve(tracksRequest.result); }),
                new Promise(resolve => { drawingsRequest.onsuccess = () => resolve(drawingsRequest.result); })
            ]).then(async ([markers, tracks, drawings]) => {
                const zip = new JSZip();
                
                // Add photos
                const photos = markers.filter(m => m.photo);
                if (photos.length > 0) {
                    const photosFolder = zip.folder("fotos");
                    photos.forEach((photo, i) => {
                        const lat = photo.lat ? photo.lat.toFixed(6) : 'unknown';
                        const lng = photo.lng ? photo.lng.toFixed(6) : 'unknown';
                        const date = new Date(photo.timestamp).toISOString().split('T')[0];
                        const time = new Date(photo.timestamp).toTimeString().split(' ')[0].replace(/:/g, '-');
                        const filename = `foto_${lat}_${lng}_${date}_${time}.jpg`;
                        const base64Data = photo.photo.split(',')[1];
                        photosFolder.file(filename, base64Data, {base64: true});
                    });
                }
                
                // Add audio
                const audioMarkers = markers.filter(m => m.audio);
                if (audioMarkers.length > 0) {
                    const audioFolder = zip.folder("sprachnotizen");
                    audioMarkers.forEach((marker, i) => {
                        const lat = marker.lat ? marker.lat.toFixed(6) : 'unknown';
                        const lng = marker.lng ? marker.lng.toFixed(6) : 'unknown';
                        const date = new Date(marker.timestamp).toISOString().split('T')[0];
                        const time = new Date(marker.timestamp).toTimeString().split(' ')[0].replace(/:/g, '-');
                        const filename = `audio_${lat}_${lng}_${date}_${time}.webm`;
                        const base64Data = marker.audio.split(',')[1];
                        audioFolder.file(filename, base64Data, {base64: true});
                    });
                }
                
                // Add notes
                const notes = markers.filter(m => m.type === 'note' || m.description);
                if (notes.length > 0) {
                    let notesContent = `NOTIZEN-EXPORT\n==============\n\n`;
                    notesContent += `Projekt: ${currentProjectName}\n`;
                    notesContent += `Kommune: ${currentKommune}\n\n`;
                    
                    notes.forEach((note, i) => {
                        notesContent += `\nNOTIZ ${i + 1}\n--------\n`;
                        notesContent += `Titel: ${note.title || 'Ohne Titel'}\n`;
                        notesContent += `Datum: ${new Date(note.timestamp).toLocaleString('de-DE')}\n`;
                        notesContent += `GPS: ${note.lat?.toFixed(6) || '?'}, ${note.lng?.toFixed(6) || '?'}\n`;
                        notesContent += `Inhalt: ${note.description || note.note || ''}\n\n`;
                    });
                    
                    zip.file("notizen.txt", notesContent);
                }
                
                // Add GPS tracks as GeoJSON - Kommune-basiert (Feature!)
                const kommuneTracks = tracks.filter(t => t.kommune === currentKommune);
                if (kommuneTracks.length > 0) {
                    const geoJson = {
                        type: "FeatureCollection",
                        features: kommuneTracks.map(track => ({
                            type: "Feature",
                            properties: {
                                type: track.type,
                                startTime: track.timestamp || track.startTime,
                                endTime: track.timestamp + (track.duration || 0),
                                kommune: track.kommune,
                                distance: track.distance || 0,
                                id: track.id
                            },
                            geometry: {
                                type: "LineString",
                                // Use track.track instead of track.coordinates!
                                coordinates: (track.track || []).map(coord => {
                                    if (Array.isArray(coord)) return [coord[0], coord[1]];
                                    if (coord && typeof coord === 'object') return [coord.lng || coord[0], coord.lat || coord[1]];
                                    return [0, 0];
                                })
                            }
                        }))
                    };
                    zip.file("gps-tracks.geojson", JSON.stringify(geoJson, null, 2));
                }
                
                // Add custom drawings as GeoJSON
                if (drawings && drawings.length > 0) {
                    const drawingsGeoJson = {
                        type: "FeatureCollection",
                        features: drawings.map(drawing => ({
                            type: "Feature",
                            properties: {
                                id: drawing.id,
                                timestamp: drawing.timestamp,
                                kommune: drawing.kommune,
                                color: drawing.color,
                                width: drawing.width
                            },
                            geometry: {
                                type: "LineString",
                                coordinates: drawing.path
                            }
                        }))
                    };
                    zip.file("zeichnungen.geojson", JSON.stringify(drawingsGeoJson, null, 2));
                }
                
                // Add project metadata
                const metadata = {
                    projectName: currentProjectName,
                    kommune: currentKommune,
                    exportDate: new Date().toISOString(),
                    statistics: {
                        photos: photos.length,
                        audio: audioMarkers.length,
                        notes: notes.length,
                        tracks: kommuneTracks.length,
                        drawings: drawings ? drawings.length : 0
                    }
                };
                zip.file("metadata.json", JSON.stringify(metadata, null, 2));
                
                // Generate and download ZIP
                const content = await zip.generateAsync({type: "blob"});
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `komplett-export-${currentKommune}-${new Date().toISOString().split('T')[0]}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`📦 Komplett-Export erfolgreich!`, 'success');
            });
        }

        // Export photos as ZIP (legacy HTML gallery)
        async function exportPhotosAsZip() {
            if (!db) return;
            
            showToast('📦 Erstelle Foto-Export...', 'info');
            
            const transaction = db.transaction(['customMarkers'], 'readonly');
            const store = transaction.objectStore('customMarkers');
            const index = store.index('kommune');
            const request = index.getAll(currentKommune);
            
            request.onsuccess = async () => {
                const markers = request.result;
                const photosWithNumbers = markers
                    .filter(m => m.photo)
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                if (photosWithNumbers.length === 0) {
                    showToast('❌ Keine Fotos zum Exportieren vorhanden!', 'error');
                    return;
                }
                
                // Create a simple HTML gallery with all photos
                const galleryHTML = `
                    <!DOCTYPE html>
                    <html lang="de">
                    <head>
                        <meta charset="UTF-8">
                        <title>Foto-Export ${currentKommune}</title>
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                background: #1a1a1a; 
                                color: white; 
                                padding: 20px; 
                            }
                            h1 { 
                                text-align: center; 
                                color: #00ffff; 
                            }
                            .photo-grid {
                                display: grid;
                                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                                gap: 20px;
                                margin-top: 30px;
                            }
                            .photo-card {
                                background: rgba(255,255,255,0.1);
                                border-radius: 10px;
                                padding: 10px;
                                text-align: center;
                            }
                            .photo-card img {
                                width: 100%;
                                border-radius: 8px;
                            }
                            .photo-info {
                                margin-top: 10px;
                                font-size: 14px;
                            }
                            .photo-number {
                                background: #00ffff;
                                color: #0a0b1e;
                                padding: 2px 8px;
                                border-radius: 4px;
                                display: inline-block;
                                margin-bottom: 5px;
                            }
                        </style>
                    </head>
                    <body>
                        <h1>Foto-Export: ${currentKommune}</h1>
                        <p style="text-align: center;">Projekt: ${currentProjectName} | ${photosWithNumbers.length} Fotos | ${new Date().toLocaleDateString('de-DE')}</p>
                        <div class="photo-grid">
                            ${photosWithNumbers.map((photo, index) => `
                                <div class="photo-card">
                                    <img src="${photo.photo}" alt="Foto ${index + 1}">
                                    <div class="photo-info">
                                        <div class="photo-number">Foto #${index + 1}</div><br>
                                        <strong>${photo.title || 'Unbenannt'}</strong><br>
                                        ${photo.description ? `<p>${photo.description}</p>` : ''}
                                        <small>${new Date(photo.timestamp).toLocaleString('de-DE')}</small>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </body>
                    </html>
                `;
                
                // Download as HTML file (since we can't create actual ZIP without library)
                const blob = new Blob([galleryHTML], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fotos-${currentKommune}-${new Date().toISOString().split('T')[0]}.html`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`📷 ${photosWithNumbers.length} Fotos exportiert!`, 'success');
            };
        }

        // Connection status monitoring
        window.addEventListener('online', () => {
            isOnline = true;
            document.getElementById('connection-status').textContent = 'Online';
            document.getElementById('connection-status').className = 'status-online';
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            document.getElementById('connection-status').textContent = 'Offline';
            document.getElementById('connection-status').className = 'status-offline';
        });

        // Toast notification system
        function showToast(message, type = 'info') {
            const colors = {
                success: '#00ff80',
                error: '#ff4060',
                warning: '#ff8000',
                info: '#00ffff'
            };

            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: var(--glass-bg);
                backdrop-filter: blur(20px);
                border: 2px solid ${colors[type]};
                border-radius: 12px;
                padding: 12px 16px;
                color: white;
                font-size: 14px;
                z-index: 10000;
                max-width: 300px;
                box-shadow: 0 0 20px ${colors[type]}40;
                animation: slideInRight 0.3s ease;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), 4000);
        }

        // Main setup process with improved error handling
        // Remove duplicate entries from the database
        async function removeDuplicates() {
            if (!db) return;
            
            console.log('🧹 Checking for duplicate entries...');
            
            const transaction = db.transaction(['osmData'], 'readwrite');
            const store = transaction.objectStore('osmData');
            const request = store.getAll();
            
            return new Promise((resolve) => {
                request.onsuccess = () => {
                    const allData = request.result;
                    const seen = new Set();
                    const toDelete = [];
                    
                    // Find duplicates based on kommune + type + OSM ID
                    allData.forEach(item => {
                        // Create a unique key without the kommune prefix in ID
                        const uniqueKey = `${item.kommune}_${item.type}_${item.element?.id || item.id}`;
                        
                        if (seen.has(uniqueKey)) {
                            // This is a duplicate, mark for deletion
                            toDelete.push(item.id);
                        } else {
                            seen.add(uniqueKey);
                        }
                    });
                    
                    // Delete duplicates
                    if (toDelete.length > 0) {
                        console.log(`🗑️ Removing ${toDelete.length} duplicate entries...`);
                        toDelete.forEach(id => store.delete(id));
                    }
                    
                    console.log('✅ Duplicate removal complete');
                    resolve();
                };
            });
        }

        async function setupApp() {
            console.log('🚀 Setup App gestartet...');
            
            // Initialize database first
            try {
                await initDatabase();
                console.log('✅ Database initialisiert');
                
                // Remove any duplicate entries
                await removeDuplicates();
                
                // Verify database is ready
                if (!db) {
                    throw new Error('Database not initialized');
                }
                
                // Check if all object stores exist
                const requiredStores = ['osmData', 'customMarkers', 'gpsTracks', 'photos', 'routes', 'projects'];
                const missingStores = requiredStores.filter(store => !db.objectStoreNames.contains(store));
                
                if (missingStores.length > 0) {
                    console.warn('⚠️ Missing object stores:', missingStores);
                    // Force database recreation by incrementing version
                    db.close();
                    await initDatabase();
                }
                
            } catch (error) {
                console.error('❌ Database-Fehler:', error);
                alert(`Database-Fehler: ${error.message}. Bitte Seite neu laden.`);
                return;
            }
            
            // ============ DEVELOPMENT MODE CHECK ============
            if (window.DEV_CONFIG && window.DEV_CONFIG.DEV_MODE && window.DEV_CONFIG.SKIP_SETUP) {
                console.log('🚀 DEV MODE: Überspringe Setup-Screen...');
                
                // Hide setup screen
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('app-container').style.display = 'block';
                
                // Set dev project data
                const devConfig = window.DEV_CONFIG.AUTO_LOAD_PROJECT;
                currentKommune = devConfig.kommune;
                currentProjectName = devConfig.projectName;
                currentProjectId = 'dev-' + Date.now();
                
                // Update UI
                document.getElementById('project-name-display').textContent = `📂 ${devConfig.projectName}`;
                document.getElementById('header-location').textContent = `📍 ${devConfig.kommune}`;
                
                // Initialize map with dev settings
                setTimeout(() => {
                    initMap(devConfig.centerLat, devConfig.centerLng, devConfig.kommune);
                    
                    // Show dev mode indicator
                    showToast('🚀 DEV MODE: ' + devConfig.kommune + ' geladen', 'info');
                    
                    // Add dev mode indicator to UI
                    const devIndicator = document.createElement('div');
                    devIndicator.style.cssText = 'position: fixed; top: 5px; right: 5px; background: #ff4060; color: white; padding: 5px 10px; border-radius: 5px; font-size: 11px; z-index: 10000;';
                    devIndicator.textContent = '🚀 DEV MODE';
                    devIndicator.onclick = () => {
                        if (confirm('Dev-Modus deaktivieren?')) {
                            DevHelper.toggle();
                        }
                    };
                    document.body.appendChild(devIndicator);
                    
                    // Load demo data if configured
                    if (window.DEV_CONFIG.LOAD_DEMO_DATA) {
                        console.log('📥 Lade Demo-Daten...');
                        // Demo data will be loaded by map initialization
                    }
                    
                    // Setup auto-save if configured
                    if (window.DEV_CONFIG.AUTO_SAVE_INTERVAL) {
                        setInterval(() => {
                            console.log('💾 Auto-save...');
                            saveCurrentProject();
                        }, window.DEV_CONFIG.AUTO_SAVE_INTERVAL);
                    }
                }, 500);
                
                return; // Skip normal setup
            }
            // ============ END DEVELOPMENT MODE CHECK ============
            
            // Get DOM elements after they're loaded
            const projektNameInput = document.getElementById('project-name-input');
            const kommuneInput = document.getElementById('kommune-input');
            const radiusInput = document.getElementById('radius-input');
            const downloadBtn = document.getElementById('download-btn');
            const demoBtn = document.getElementById('demo-btn');
            const progressSection = document.getElementById('progress-section');

            // Debug: Check if elements exist
            console.log('🔍 DOM Elements gefunden:', { 
                projektNameInput: !!projektNameInput, 
                kommuneInput: !!kommuneInput, 
                downloadBtn: !!downloadBtn,
                demoBtn: !!demoBtn 
            });
            
            if (!projektNameInput || !kommuneInput || !downloadBtn) {
                console.error('❌ Required DOM elements not found!');
                alert('FEHLER: DOM-Elemente nicht gefunden. Seite neu laden!');
                return;
            }

            // Event Listener für Download Button
            downloadBtn.onclick = async function() {
                console.log('🖱️ Download Button geklickt!');
                
                const projektName = projektNameInput.value.trim();
                const kommune = kommuneInput.value.trim();
                const radius = parseFloat(radiusInput.value) || 3;
                
                console.log('📝 Eingaben:', { projektName, kommune, radius });
                
                if (!projektName) {
                    alert('Bitte Projektname eingeben!');
                    return;
                }
                
                if (!kommune) {
                    alert('Bitte Kommune eingeben!');
                    return;
                }

                // Verify database is ready
                if (!db) {
                    console.error('❌ Database nicht verfügbar');
                    alert('Database-Fehler! Bitte Seite neu laden.');
                    return;
                }

                downloadBtn.disabled = true;
                progressSection.style.display = 'block';
                
                try {
                    console.log('🔍 Starte Geocoding...');
                    updateProgress(0, 'Suche Kommune...');
                    
                    const location = await geocodeKommune(kommune);
                    console.log('📍 Geocoding Ergebnis:', location);
                    
                    if (!location) {
                        throw new Error('Kommune nicht gefunden');
                    }
                    
                    // Clear any existing session
                    localStorage.removeItem('lastProject');
                    
                    // Create new project
                    currentProjectId = 'project_' + Date.now();
                    currentProjectName = projektName;
                    currentKommune = location.name;
                    
                    console.log('📂 Projekt erstellt:', { currentProjectId, currentProjectName, currentKommune });
                    
                    updateProgress(20, 'Lade vollständige OSM-Daten...');
                    
                    await fetchOSMData(location.lat, location.lng, radius);
                    
                    // Save initial project
                    const projectData = {
                        id: currentProjectId,
                        name: projektName,
                        kommune: location.name,
                        radius: radius,
                        areaBounds: areaBounds, // Save the defined area bounds
                        created: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        stats: {
                            totalPOIs: 0,
                            customMarkers: 0,
                            savedRoutes: 0
                        }
                    };
                    
                    const transaction = db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    store.add(projectData);
                    
                    updateProgress(100, 'Fertig! App wird gestartet...');
                    
                    setTimeout(() => {
                        // Remove all modal overlays
                        document.querySelectorAll('.modal-overlay').forEach(modal => {
                            modal.remove();
                        });
                        
                        document.getElementById('setup-screen').style.display = 'none';
                        document.getElementById('app-container').style.display = 'block';
                        
                        // Save to localStorage
                        localStorage.setItem('lastProject', JSON.stringify({
                            id: currentProjectId,
                            name: currentProjectName,
                            kommune: currentKommune,
                            radius: radius,
                            areaBounds: areaBounds
                        }));
                        
                        initMap(location.lat, location.lng, currentKommune);
                        showToast(`📂 Projekt "${projektName}" erstellt!`, 'success');
                    }, 1000);
                    
                } catch (error) {
                    console.error('❌ Setup-Fehler:', error);
                    alert(`Fehler: ${error.message}`);
                    downloadBtn.disabled = false;
                    progressSection.style.display = 'none';
                }
            };

            // Event Listener für Demo Button (mit null check)
            if (demoBtn) {
                demoBtn.onclick = async function() {
                console.log('🎮 Demo Button geklickt!');
                
                currentProjectId = 'demo_' + Date.now();
                currentProjectName = 'Wachtendonk Demo';
                currentKommune = 'Wachtendonk (Demo)';
                
                console.log('🎮 Demo-Projekt:', { currentProjectId, currentProjectName });
                
                // Demo coordinates for Wachtendonk
                const demoLat = 51.4088;
                const demoLng = 6.3394;
                
                // Save demo project
                const demoProject = {
                    id: currentProjectId,
                    name: currentProjectName,
                    kommune: currentKommune,
                    radius: 3,
                    created: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    stats: { totalPOIs: 0, customMarkers: 0, savedRoutes: 0 }
                };
                
                if (db) {
                    const transaction = db.transaction(['projects'], 'readwrite');
                    transaction.objectStore('projects').add(demoProject);
                }
                
                // Remove all modal overlays
                document.querySelectorAll('.modal-overlay').forEach(modal => {
                    modal.remove();
                });
                
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('app-container').style.display = 'block';
                
                // Clear session for demo
                localStorage.removeItem('lastProject');
                
                initMap(demoLat, demoLng, 'Wachtendonk');
                
                showToast('🎮 Demo-Projekt gestartet!', 'info');
            };
            } // Close the if (demoBtn) check
            
            console.log('✅ Event Listener angehängt');
        }

        // DEPRECATED - Style switcher is now in bottom bar
        // Keeping function to avoid breaking references
        function addStyleSwitcher() {
            return; // Do nothing - style switcher is now in bottom bar
            // Create control container
            const styleControl = document.createElement('div');
            styleControl.className = 'mapboxgl-ctrl mapboxgl-ctrl-group style-switcher';
            styleControl.style.position = 'absolute';
            styleControl.style.top = '130px';
            styleControl.style.left = '20px';
            styleControl.style.zIndex = '1000';
            
            // Create dropdown
            const select = document.createElement('select');
            select.style.background = 'rgba(26, 27, 58, 0.95)';
            select.style.color = 'white';
            select.style.border = '1px solid rgba(255, 255, 255, 0.2)';
            select.style.borderRadius = '4px';
            select.style.padding = '8px';
            select.style.fontSize = '14px';
            select.style.cursor = 'pointer';
            select.style.minWidth = '120px';
            
            // Add options
            Object.keys(mapStyles).forEach(styleName => {
                const option = document.createElement('option');
                option.value = styleName;
                option.textContent = styleName === 'Standard' ? '🏞️ Standard' :
                                    styleName === 'Kinderperspektive' ? '🎨 Kinderperspektive' : styleName;
                option.selected = styleName === currentMapStyle;
                select.appendChild(option);
            });
            
            // Handle style change
            select.addEventListener('change', (e) => {
                const newStyle = e.target.value;
                currentMapStyle = newStyle;
                localStorage.setItem('preferredMapStyle', newStyle);
                
                // Store current map state
                const center = map.getCenter();
                const zoom = map.getZoom();
                const bearing = map.getBearing();
                const pitch = map.getPitch();
                
                // Change style
                map.setStyle(mapStyles[newStyle]);
                
                // Restore map state and reload data after style loads
                map.once('style.load', () => {
                    // Apply special settings for Kinderperspektive
                    if (newStyle === 'Kinderperspektive') {
                        map.setPitch(45);
                        map.setBearing(35);
                        map.setZoom(Math.max(zoom, 16));
                        map.setCenter(center);
                        // Delay to ensure map is ready
                        setTimeout(() => {
                            applyKinderperspektiveEffects();
                        }, 100);
                    } else {
                        // Reset to normal view for other styles
                        map.setCenter(center);
                        map.setZoom(zoom);
                        map.setBearing(0);
                        map.setPitch(0);
                        removeKinderperspektiveEffects();
                    }
                    
                    // Reload all map data
                    loadOSMDataToMap();
                    loadCustomMarkers();
                    loadSavedRoutes();
                    loadSavedBegehungen();
                    
                    showToast(`Kartenstil gewechselt zu: ${newStyle}`, 'success');
                });
            });
            
            styleControl.appendChild(select);
            
            // Add to map container
            const mapContainer = document.getElementById('map');
            mapContainer.appendChild(styleControl);
        }

        // Update user location marker
        function updateUserLocation(lat, lng) {
            if (!map) return;
            
            const isKinderperspektive = currentMapStyle === 'Kinderperspektive';
            
            // Remove existing marker if it exists
            if (window.userMarker) {
                window.userMarker.remove();
            }
            
            // Create appropriate marker based on mode
            if (isKinderperspektive) {
                // Character marker for Kinderperspektive
                const el = document.createElement('div');
                el.className = 'character-marker';
                window.userMarker = new mapboxgl.Marker(el)
                    .setLngLat([lng, lat])
                    .addTo(map);
            } else {
                // Standard marker for other modes
                const el = document.createElement('div');
                el.style.width = '20px';
                el.style.height = '20px';
                el.style.background = 'radial-gradient(circle, #00ff80, #00aa55)';
                el.style.borderRadius = '50%';
                el.style.border = '3px solid white';
                el.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                window.userMarker = new mapboxgl.Marker(el)
                    .setLngLat([lng, lat])
                    .addTo(map);
            }
        }
        
        // Available paper textures (add more as you create them)
        const paperTextures = [
            'papiernormal.png',
            // 'papieralt.png',
            // 'papierglatt.png',
            // 'papierzerknittert.png'
        ];
        let currentPaperTexture = 0;
        
        // Kinderperspektive Effects Functions
        function applyKinderperspektiveEffects() {
            console.log('🎨 Applying Kinderperspektive effects...');
            
            // Add kinderperspektive class to body
            document.body.classList.add('kinderperspektive-mode');
            
            // Wait for map to be ready
            setTimeout(() => {
                // First enable 3D buildings
                enable3DBuildings();
                
                // Apply to layers (removed texture creation that was causing errors)
                // applyKinderperspektiveStyles();
                
                // Debug what we have
                debugMapLayers();
            }, 500);
        }
        
        // REMOVED: createKinderperspektiveTextures was causing image size errors
        // The Kinderperspektive mode now just uses 3D perspective without custom textures
        /*
        function createKinderperspektiveTextures() {
            console.log('🎨 Creating Kinderperspektive textures...');
            
            // Check if images already exist to avoid errors
            try {
                // WATER PATTERN - Hand-drawn style with animation effect
                if (!map.hasImage('water-wimmelbild')) {
                    const waterCanvas = document.createElement('canvas');
                    waterCanvas.width = 256; // Power of 2 for WebGL
                    waterCanvas.height = 256;
                    const ctx = waterCanvas.getContext('2d');
                
                // Base water color - muted blue
                ctx.fillStyle = '#7FA8C9';
                ctx.fillRect(0, 0, 256, 256);
                
                // Hand-drawn wave lines
                ctx.strokeStyle = '#A8C8E1';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                for (let y = 20; y < 256; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    for (let x = 0; x < 256; x += 20) {
                        const wobble = Math.sin(x * 0.1) * 10;
                        ctx.lineTo(x, y + wobble + (Math.random() - 0.5) * 5);
                    }
                    ctx.stroke();
                }
                
                // Ripple circles
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * 256;
                    const y = Math.random() * 256;
                    ctx.beginPath();
                    ctx.arc(x, y, 15 + Math.random() * 20, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Darker depth areas
                ctx.fillStyle = 'rgba(50, 80, 120, 0.2)';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.ellipse(
                        Math.random() * 256, 
                        Math.random() * 256,
                        30 + Math.random() * 20,
                        15 + Math.random() * 10,
                        Math.random() * Math.PI,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Add image without pixelRatio to avoid size mismatch
                map.addImage('water-wimmelbild', waterCanvas);
                console.log('✅ Water texture created');
            }
            
            // GROUND/PARK PATTERN - Paper texture style
            if (!map.hasImage('ground-wimmelbild')) {
                const groundCanvas = document.createElement('canvas');
                groundCanvas.width = 256;
                groundCanvas.height = 256;
                const ctx = groundCanvas.getContext('2d');
                
                // Parchment base color
                ctx.fillStyle = '#E8D7B9';
                ctx.fillRect(0, 0, 256, 256);
                
                // Paper texture lines
                ctx.strokeStyle = 'rgba(139, 90, 43, 0.1)';
                ctx.lineWidth = 1;
                
                // Random scratchy lines for texture
                for (let i = 0; i < 100; i++) {
                    ctx.beginPath();
                    const startX = Math.random() * 256;
                    const startY = Math.random() * 256;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(
                        startX + (Math.random() - 0.5) * 30,
                        startY + (Math.random() - 0.5) * 30
                    );
                    ctx.stroke();
                }
                
                // Grass tufts
                ctx.strokeStyle = 'rgba(100, 120, 80, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 256;
                    const y = Math.random() * 256;
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(
                            x + (Math.random() - 0.5) * 10,
                            y - Math.random() * 15
                        );
                    }
                    ctx.stroke();
                }
                
                // Age spots and stains
                ctx.fillStyle = 'rgba(120, 90, 60, 0.05)';
                for (let i = 0; i < 8; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * 256,
                        Math.random() * 256,
                        Math.random() * 30 + 10,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                    // Add image without pixelRatio to avoid size mismatch
                    map.addImage('ground-wimmelbild', groundCanvas);
                    console.log('✅ Ground texture created');
                }
            } catch (error) {
                console.warn('⚠️ Could not create Kinderperspektive textures:', error);
            }
        }
        */
        
        // REMOVED: applyKinderperspektiveStyles was trying to use non-existent textures
        /*
        function applyKinderperspektiveStyles() {
            console.log('🎨 Applying Kinderperspektive styles...');
            
            const layers = map.getStyle().layers;
            let modifiedLayers = [];
            
            layers.forEach(layer => {
                try {
                    // Water layers - apply pattern
                    if (layer.type === 'fill' && 
                        (layer.id.includes('water') || 
                         layer['source-layer'] === 'water' ||
                         layer.id.includes('river') || 
                         layer.id.includes('stream') ||
                         layer.id.includes('lake'))) {
                        
                        map.setPaintProperty(layer.id, 'fill-pattern', 'water-wimmelbild');
                        map.setPaintProperty(layer.id, 'fill-opacity', 0.9);
                        modifiedLayers.push(`water: ${layer.id}`);
                    }
                    
                    // Park/grass layers - apply ground pattern
                    else if (layer.type === 'fill' && 
                             (layer.id.includes('park') || 
                              layer.id.includes('grass') ||
                              layer.id.includes('landuse-park') ||
                              layer.id.includes('landcover'))) {
                        
                        map.setPaintProperty(layer.id, 'fill-pattern', 'ground-wimmelbild');
                        map.setPaintProperty(layer.id, 'fill-opacity', 0.8);
                        modifiedLayers.push(`ground: ${layer.id}`);
                    }
                    
                    // Building footprints - just change color, 3D is handled separately
                    else if (layer.type === 'fill' && 
                             (layer.id.includes('building') && !layer.id.includes('3d'))) {
                        
                        map.setPaintProperty(layer.id, 'fill-color', '#C4A57B');
                        map.setPaintProperty(layer.id, 'fill-opacity', 0.8);
                        modifiedLayers.push(`building-2d: ${layer.id}`);
                    }
                    
                    // 3D Buildings - custom colors
                    else if (layer.type === 'fill-extrusion') {
                        map.setPaintProperty(layer.id, 'fill-extrusion-color', [
                            'interpolate',
                            ['linear'],
                            ['get', 'height'],
                            0, '#D4A76A',
                            20, '#C19A5B',
                            50, '#AE8D4C'
                        ]);
                        map.setPaintProperty(layer.id, 'fill-extrusion-opacity', 0.9);
                        modifiedLayers.push(`building-3d: ${layer.id}`);
                    }
                    
                    // Roads - hand-drawn style
                    else if (layer.type === 'line' && 
                             (layer.id.includes('road') || 
                              layer.id.includes('street') ||
                              layer.id.includes('path'))) {
                        
                        const isPath = layer.id.includes('path') || layer.id.includes('pedestrian');
                        const isMinor = layer.id.includes('minor') || layer.id.includes('service');
                        
                        map.setPaintProperty(layer.id, 'line-color', 
                            isPath ? '#A0826D' : 
                            isMinor ? '#8B7355' : 
                            '#6B5945'
                        );
                        
                        if (isPath) {
                            map.setPaintProperty(layer.id, 'line-dasharray', [2, 2]);
                        }
                        
                        modifiedLayers.push(`road: ${layer.id}`);
                    }
                    
                    // Background
                    else if (layer.type === 'background') {
                        map.setPaintProperty(layer.id, 'background-color', '#F4E4BC');
                        modifiedLayers.push(`background: ${layer.id}`);
                    }
                    
                } catch (e) {
                    console.warn(`Could not modify layer ${layer.id}:`, e.message);
                }
            });
            
            console.log('✅ Modified layers:', modifiedLayers);
        }
        */
        
        // Simplified Kinderperspektive - just 3D view without custom textures
        
        function debugMapLayers() {
            const layers = map.getStyle().layers;
            console.group('🔍 Debugging Map Layers');
            
            const fillLayers = layers.filter(l => l.type === 'fill');
            console.log('Fill layers:', fillLayers.map(l => `${l.id} (source-layer: ${l['source-layer']})`));
            
            const patternLayers = layers.filter(l => {
                return l.paint && (l.paint['fill-pattern'] || l.paint['background-pattern']);
            });
            console.log('Layers with patterns:', patternLayers.map(l => l.id));
            
            console.groupEnd();
        }
        
        function removeKinderperspektiveEffects() {
            console.log('🔄 Removing Kinderperspektive effects...');
            
            // Remove kinderperspektive class
            document.body.classList.remove('kinderperspektive-mode');
            
            // Disable 3D buildings
            disable3DBuildings();
            
            // Reset map pitch and bearing to normal
            map.setPitch(0);
            map.setBearing(0);
        }
        
        // Paper canvas function removed - using Mapbox patterns instead
        
        function enable3DBuildings() {
            if (!map || !map.getStyle()) return;
            
            console.log('🏗️ Enabling 3D buildings...');
            
            // Check if 3D buildings layer already exists
            if (!map.getLayer('3d-buildings-wimmelbild')) {
                const layers = map.getStyle().layers;
                
                // Find the label layer to insert buildings before it
                let labelLayerId;
                for (let i = 0; i < layers.length; i++) {
                    if (layers[i].type === 'symbol' && layers[i].layout && layers[i].layout['text-field']) {
                        labelLayerId = layers[i].id;
                        break;
                    }
                }
                
                // Add the 3D buildings layer
                map.addLayer({
                    'id': '3d-buildings-wimmelbild',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 14,
                    'paint': {
                        // Cardboard/paper color gradient based on height
                        'fill-extrusion-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'height'],
                            0, '#E8D7B3',  // Light paper/cardboard
                            20, '#D4A76A', // Medium cardboard
                            40, '#C19A5B', // Darker cardboard  
                            60, '#AE8D4C', // Even darker
                            100, '#9B8040' // Darkest cardboard
                        ],
                        'fill-extrusion-height': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            14, 0,
                            14.5, ['*', ['get', 'height'], 0.5],
                            16, ['get', 'height']
                        ],
                        'fill-extrusion-base': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            14, 0,
                            14.5, ['*', ['get', 'min_height'], 0.5],
                            16, ['get', 'min_height']
                        ],
                        'fill-extrusion-opacity': 0.95
                    }
                }, labelLayerId);
                
                console.log('✅ 3D buildings layer added');
            } else {
                console.log('ℹ️ 3D buildings layer already exists');
            }
        }
        
        function disable3DBuildings() {
            if (map.getLayer('3d-buildings-wimmelbild')) {
                map.removeLayer('3d-buildings-wimmelbild');
                console.log('🚫 3D buildings disabled');
            }
        }
// Removed duplicate disable3DBuildings function
        
        // Old functions removed - now integrated into new pattern system
        // Functions consolidated into applyPatternsToLayers above
        
        // Additional helper functions for route calculation (optional)
        async function getRouteDistance(point1, point2, straightDistance) {
            if (!isOnline) return;
            
            try {
                const profile = currentRouteType === 'driving' ? 'driving' : 'walking';
                const response = await fetch(
                    `https://api.mapbox.com/directions/v5/mapbox/${profile}/${point1.lng},${point1.lat};${point2.lng},${point2.lat}?geometries=geojson&access_token=${mapboxgl.accessToken}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const route = data.routes[0];
                    
                    if (route) {
                        const routeDistance = route.distance;
                        const routeDuration = route.duration;
                        
                        // Add route to map
                        if (map.getSource('route-source')) {
                            map.removeLayer('route-line');
                            map.removeSource('route-source');
                        }
                        
                        map.addSource('route-source', {
                            type: 'geojson',
                            data: route.geometry
                        });
                        
                        map.addLayer({
                            id: 'route-line',
                            type: 'line',
                            source: 'route-source',
                            paint: {
                                'line-color': currentRouteType === 'driving' ? '#ff8000' : '#00ff80',
                                'line-width': 6,
                                'line-opacity': 0.8
                            }
                        });
                        
                        currentRoute = {
                            distance: routeDistance,
                            duration: routeDuration,
                            geometry: route.geometry,
                            routeType: currentRouteType,
                            points: [point1, point2]
                        };
                        
                        const routeText = `${currentRouteType === 'driving' ? '🚗' : '🚶'} Route: ${formatDistance(routeDistance)} (${formatDuration(routeDuration)})`;
                        updateMeasureDisplay(`📏 Luftlinie: ${formatDistance(straightDistance)}<br>${routeText}`);
                        
                        document.getElementById('route-actions').style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Route calculation failed:', error);
            }
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}min`;
            } else {
                return `${minutes}min`;
            }
        }

        // ================ NEW FUNCTIONS FOR REDESIGN ================
        
        // Begehung functions for different types
        function startBegehungProfessional() {
            startBegehungWithType('professional');
        }
        
        function startBegehungChildren() {
            startBegehungWithType('children');
        }
        
        function startBegehungWithType(type) {
            if (begehungActive) {
                stopBegehung();
                return;
            }
            
            begehungType = type;
            begehungActive = true;
            begehungStartTime = Date.now();
            begehungTrack = [];
            begehungDistance = 0;
            begehungMarkers = [];
            lastBegehungPosition = null;
            
            // Update UI
            const btn = type === 'professional' ? 
                document.getElementById('begehungProBtn') : 
                document.getElementById('begehungChildBtn');
            btn.classList.add('active');
            
            // Highlight quick action buttons based on type
            const highlightClass = type === 'professional' ? 'highlight-professional' : 'highlight-children';
            document.getElementById('quickPhotoBtn').classList.add(highlightClass);
            document.getElementById('quickVoiceBtn').classList.add(highlightClass);
            document.getElementById('quickTextBtn').classList.add(highlightClass);
            document.getElementById('markerBtn').classList.add(highlightClass);
            
            // Start GPS tracking
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        
                        // Add first point with consistent object structure
                        begehungTrack.push({
                            lat: lat,
                            lng: lng,
                            timestamp: Date.now(),
                            accuracy: position.coords.accuracy
                        });
                        updateBegehungTrack();
                        
                        // Start continuous tracking
                        startBegehungContinuousTracking();
                    },
                    (error) => {
                        console.error('GPS Error:', error);
                        showToast('⚠️ GPS nicht verfügbar', 'warning');
                    }
                );
            }
            
            // Start timer
            begehungTimer = setInterval(updateBegehungTimer, 1000);
            
            // Start periodic auto-save to IndexedDB
            startPeriodicSave();
            
            const colorInfo = type === 'professional' ? 'Rot' : 'Gelb';
            showToast(`🚶 Begehung ${type === 'professional' ? 'Fachkräfte' : 'Kinder'} gestartet (${colorInfo})`, 'success');
        }
        
        // Override existing stopBegehung to save tracks
        function stopBegehung() {
            if (!begehungActive) return;
            
            // Save the track before stopping
            if (begehungTrack.length > 0) {
                saveBegehungTrack();
            }
            
            begehungActive = false;
            
            // Stop GPS tracking
            if (begehungWatchId) {
                navigator.geolocation.clearWatch(begehungWatchId);
                begehungWatchId = null;
            }
            
            // Stop timer
            if (begehungTimer) {
                clearInterval(begehungTimer);
                begehungTimer = null;
            }
            
            // Stop periodic auto-save
            stopPeriodicSave();
            
            // UI Updates (restored from old function)
            document.getElementById('begehung-indicator').classList.remove('active');
            document.getElementById('quick-action-bar').classList.remove('active');
            
            // Update begehung buttons
            const proBtn = document.getElementById('begehungProBtn');
            const childBtn = document.getElementById('begehungChildBtn');
            if (proBtn) proBtn.classList.remove('active');
            if (childBtn) childBtn.classList.remove('active');
            
            // Clear session data after successful save
            const today = new Date().toISOString().split('T')[0];
            const sessionKey = `begehung_session_${begehungType}_${today}`;
            localStorage.removeItem(sessionKey);
            console.log('🗑️ Cleared session after stopBegehung:', sessionKey);
            
            // Reset data
            begehungTrack = [];
            begehungMarkers = [];
            begehungDistance = 0;
            lastBegehungPosition = null;
            
            // Success message with stats
            const duration = formatDuration((Date.now() - begehungStartTime) / 1000);
            showToast(`✅ Begehung beendet! Dauer: ${duration}, Distanz: ${formatDistance(begehungDistance)}`, 'success');
            
            // Remove highlighting from quick actions
            document.getElementById('quickPhotoBtn')?.classList.remove('highlight-professional', 'highlight-children');
            document.getElementById('quickVoiceBtn')?.classList.remove('highlight-professional', 'highlight-children');
            document.getElementById('quickTextBtn')?.classList.remove('highlight-professional', 'highlight-children');
            document.getElementById('markerBtn')?.classList.remove('highlight-professional', 'highlight-children');
            
            showToast('⏹ Begehung beendet und gespeichert', 'info');
            begehungType = null;
        }
        
        // Save begehung track to IndexedDB
        function saveBegehungTrack() {
            if (!db || !begehungTrack.length) return;
            
            // IMPORTANT: Convert track to [lng, lat] format for consistency!
            const normalizedTrack = begehungTrack.map(point => {
                if (Array.isArray(point) && point.length === 2) {
                    return point; // Already [lng, lat]
                }
                if (point && typeof point === 'object' && point.lat !== undefined && point.lng !== undefined) {
                    return [point.lng, point.lat]; // Convert {lat, lng} to [lng, lat]
                }
                console.warn('Invalid track point:', point);
                return null;
            }).filter(p => p !== null);
            
            const track = {
                id: `begehung_${begehungType}_${Date.now()}`,
                type: begehungType,
                track: normalizedTrack, // Use normalized [lng, lat] format
                markers: begehungMarkers,
                distance: begehungDistance,
                duration: Date.now() - begehungStartTime,
                timestamp: Date.now(),
                kommune: currentKommune,
                projectId: currentProjectId
            };
            
            // Save to IndexedDB
            const transaction = db.transaction(['gpsTracks'], 'readwrite');
            const store = transaction.objectStore('gpsTracks');
            store.add(track);
            
            transaction.oncomplete = () => {
                console.log('✅ Begehung saved to IndexedDB:', track.id);
                
                // Also keep in memory for current session (sanitized for Firebase compatibility)
                const sanitizedTrack = {
                    id: track.id,
                    type: track.type,
                    track: track.track.map(point => {
                        if (Array.isArray(point)) return point;
                        if (point && typeof point === 'object') {
                            return [point.lng || point[0], point.lat || point[1]];
                        }
                        return null;
                    }).filter(p => p),
                    markers: track.markers.map(marker => ({
                        id: marker.id,
                        type: marker.type,
                        title: marker.title,
                        lat: marker.lat,
                        lng: marker.lng,
                        timestamp: marker.timestamp,
                        hasPhoto: !!marker.photo // Remove base64 photos
                    })),
                    distance: track.distance,
                    duration: track.duration,
                    timestamp: track.timestamp,
                    kommune: track.kommune,
                    projectId: track.projectId
                };
                begehungTracks[begehungType].push(sanitizedTrack);
                
                // CRITICAL: Clear session data after successful IndexedDB save
                // This prevents old sessions from accumulating
                const today = new Date().toISOString().split('T')[0];
                const sessionKey = `begehung_session_${begehungType}_${today}`;
                localStorage.removeItem(sessionKey);
                console.log('🗑️ Cleared session after IndexedDB save:', sessionKey);
                
                loadSavedBegehungen(); // Reload to show on map
            };
            
            transaction.onerror = (error) => {
                console.error('❌ Failed to save begehung to IndexedDB:', error);
                showToast('⚠️ Fehler beim Speichern der Begehung', 'error');
            };
        }
        
        // Flag to prevent duplicate loading
        let isLoadingBegehungen = false;
        let loadedBegehungIds = new Set(); // Track already loaded track IDs
        
        // Load saved begehungen from IndexedDB
        function loadSavedBegehungen() {
            if (!db) return;
            
            // Prevent concurrent loading
            if (isLoadingBegehungen) {
                console.log('⏳ Already loading begehungen, skipping duplicate call');
                return;
            }
            isLoadingBegehungen = true;
            
            try {
                const transaction = db.transaction(['gpsTracks'], 'readonly');
                const store = transaction.objectStore('gpsTracks');
                
                let request;
                // Check if projectId index exists
                if (store.indexNames.contains('projectId')) {
                    const index = store.index('projectId');
                    request = index.getAll(currentProjectId);
                } else {
                    // Fallback: get all tracks and filter manually
                    request = store.getAll();
                }
                
                request.onsuccess = () => {
                    let tracks = request.result;
                    
                    // Filter by kommune - Feature: Kommune-übergreifende Tracks!
                    if (!store.indexNames.contains('projectId')) {
                        tracks = tracks.filter(t => t.kommune === currentKommune);
                    }
                
                // APPEND to existing tracks instead of clearing (preserves active sessions)
                console.log('📊 Loading saved begehungen. Current tracks:', {
                    professional: begehungTracks.professional.length,
                    children: begehungTracks.children.length
                });
                
                // Sort tracks by type and merge with existing (avoid duplicates by ID)
                tracks.forEach(track => {
                    if (track.type === 'professional' || track.type === 'children') {
                        // CRITICAL: Convert track format to [lng, lat] arrays for display!
                        const normalizedTrack = (track.track || []).map(point => {
                            // Handle different formats
                            if (Array.isArray(point) && point.length === 2) {
                                // Already [lng, lat] format
                                return point;
                            }
                            if (point && typeof point === 'object' && 
                                point.lat !== undefined && point.lng !== undefined) {
                                // Convert {lat, lng} to [lng, lat]
                                return [point.lng, point.lat];
                            }
                            if (point && typeof point === 'object' && 
                                point.latitude !== undefined && point.longitude !== undefined) {
                                // Convert {latitude, longitude} to [lng, lat]
                                return [point.longitude, point.latitude];
                            }
                            console.warn('Invalid track point format:', point);
                            return null;
                        }).filter(p => p !== null && !isNaN(p[0]) && !isNaN(p[1]));
                        
                        // Check if track already loaded (avoid duplicates)
                        if (loadedBegehungIds.has(track.id)) {
                            console.log('⏭️ Track already loaded, skipping:', track.id);
                            return; // Skip this track
                        }
                        
                        // Check if track already exists in memory (avoid duplicates)
                        const existingIndex = begehungTracks[track.type].findIndex(t => t.id === track.id);
                        if (existingIndex === -1) {
                            loadedBegehungIds.add(track.id); // Mark as loaded
                            // New track, add it with correct structure for displayBegehungTracks()
                            begehungTracks[track.type].push({
                                id: track.id,
                                track: normalizedTrack, // Normalized array of [lng, lat] coordinates
                                markers: track.markers || [],
                                distance: track.distance || 0,
                                duration: track.duration || 0,
                                timestamp: track.timestamp,
                                startTime: track.timestamp,
                                endTime: track.timestamp + (track.duration || 0)
                            });
                            console.log('✅ Added saved begehung:', track.id, 'with', normalizedTrack.length, 'valid points');
                        } else {
                            // Update existing track (merge data)
                            begehungTracks[track.type][existingIndex] = { 
                                ...begehungTracks[track.type][existingIndex], 
                                ...track,
                                track: normalizedTrack.length > 0 ? normalizedTrack : begehungTracks[track.type][existingIndex].track || []
                            };
                            console.log('🔄 Updated existing begehung:', track.id, 'with', normalizedTrack.length, 'valid points');
                        }
                    }
                });
                
                console.log('📊 After loading. Total tracks:', {
                    professional: begehungTracks.professional.length,
                    children: begehungTracks.children.length
                });
                    
                    // Display on map
                    displayBegehungTracks();
                    
                    // Reset loading flag after successful load
                    isLoadingBegehungen = false;
                };
                
                request.onerror = () => {
                    console.error('❌ Error loading begehungen from IndexedDB');
                    isLoadingBegehungen = false; // Reset flag on error
                };
            } catch (error) {
                console.warn('⚠️ Could not load saved Begehungen:', error);
                isLoadingBegehungen = false; // Reset flag on error
            }
        }
        
        // Display begehung tracks on map
        function displayBegehungTracks() {
            if (!map) return;
            
            // Remove existing track layers
            ['begehung-professional', 'begehung-children'].forEach(layerId => {
                if (map.getLayer(layerId)) map.removeLayer(layerId);
                if (map.getSource(layerId)) map.removeSource(layerId);
            });
            
            // Add professional tracks (red)
            if (begehungTracks.professional.length > 0) {
                const features = begehungTracks.professional
                    .filter(track => track.track && track.track.length > 1) // Need at least 2 points for a line
                    .map(track => {
                        // Validate and filter coordinates
                        const validCoords = track.track.filter(coord => {
                            if (!Array.isArray(coord) || coord.length !== 2) return false;
                            const [lng, lat] = coord;
                            // Basic coordinate validation
                            return !isNaN(lng) && !isNaN(lat) && 
                                   Math.abs(lat) <= 90 && Math.abs(lng) <= 180;
                        });
                        
                        if (validCoords.length < 2) {
                            console.warn('Track has insufficient valid coordinates:', track.id);
                            return null;
                        }
                        
                        return {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: validCoords
                            },
                            properties: {
                                type: 'professional',
                                distance: track.distance,
                                duration: track.duration
                            }
                        };
                    })
                    .filter(f => f !== null);
                
                map.addSource('begehung-professional', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });
                
                map.addLayer({
                    id: 'begehung-professional',
                    type: 'line',
                    source: 'begehung-professional',
                    paint: {
                        'line-color': '#FF3B30',
                        'line-width': 4,
                        'line-opacity': 0.8
                    }
                });
            }
            
            // Add children tracks (yellow)
            if (begehungTracks.children.length > 0) {
                const features = begehungTracks.children
                    .filter(track => track.track && track.track.length > 1) // Need at least 2 points for a line
                    .map(track => {
                        // Validate and filter coordinates
                        const validCoords = track.track.filter(coord => {
                            if (!Array.isArray(coord) || coord.length !== 2) return false;
                            const [lng, lat] = coord;
                            // Basic coordinate validation
                            return !isNaN(lng) && !isNaN(lat) && 
                                   Math.abs(lat) <= 90 && Math.abs(lng) <= 180;
                        });
                        
                        if (validCoords.length < 2) {
                            console.warn('Track has insufficient valid coordinates:', track.id);
                            return null;
                        }
                        
                        return {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: validCoords
                            },
                            properties: {
                                type: 'children',
                                distance: track.distance,
                                duration: track.duration
                            }
                        };
                    })
                    .filter(f => f !== null);
                
                map.addSource('begehung-children', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });
                
                map.addLayer({
                    id: 'begehung-children',
                    type: 'line',
                    source: 'begehung-children',
                    paint: {
                        'line-color': '#FFCC00',
                        'line-width': 4,
                        'line-opacity': 0.8
                    }
                });
            }
        }
        
        // Switch View functions
        function openSwitchView() {
            const switchView = document.getElementById('switchView');
            const mapContainer = document.getElementById('map');
            const switchViewMap = document.querySelector('.switch-view-map');
            
            // Move map to switch view
            switchViewMap.appendChild(mapContainer);
            
            // Show switch view
            switchView.classList.add('active');
            
            // Resize map
            setTimeout(() => {
                if (map) map.resize();
            }, 100);
            
            // Update statistics
            updateSwitchViewStats();
        }
        
        function closeSwitchView() {
            const switchView = document.getElementById('switchView');
            const mapContainer = document.getElementById('map');
            const originalContainer = document.querySelector('.map-container');
            
            // Move map back
            originalContainer.appendChild(mapContainer);
            
            // Hide switch view
            switchView.classList.remove('active');
            
            // Resize map
            setTimeout(() => {
                if (map) map.resize();
            }, 100);
        }
        
        function setViewMode(mode) {
            // Update buttons
            document.querySelectorAll('.view-mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Change map style
            if (mode === 'kinderperspektive') {
                currentMapStyle = 'Kinderperspektive';
                map.setStyle(mapStyles['Kinderperspektive']);
                map.once('style.load', () => {
                    map.setPitch(45);
                    map.setBearing(35);
                    applyKinderperspektiveEffects();
                    loadOSMDataToMap();
                    loadCustomMarkers();
                    displayBegehungTracks();
                });
            } else {
                currentMapStyle = 'Standard';
                map.setStyle(mapStyles['Standard']);
                map.once('style.load', () => {
                    map.setPitch(0);
                    map.setBearing(0);
                    removeKinderperspektiveEffects();
                    loadOSMDataToMap();
                    loadCustomMarkers();
                    displayBegehungTracks();
                });
            }
        }
        
        function updateSwitchViewStats() {
            // Count features
            let schoolCount = 0, playgroundCount = 0, dangerCount = 0, photoCount = 0;
            
            if (osmData.schools) schoolCount = osmData.schools.length;
            if (osmData.playgrounds) playgroundCount = osmData.playgrounds.length;
            if (customMarkers) {
                dangerCount = customMarkers.filter(m => m.category === 'danger').length;
                photoCount = customMarkers.filter(m => m.photo).length;
            }
            
            // Count begehungen
            const begehungCount = begehungTracks.professional.length + begehungTracks.children.length;
            
            // Update UI
            document.getElementById('stat-schools').textContent = schoolCount;
            document.getElementById('stat-playgrounds').textContent = playgroundCount;
            document.getElementById('stat-dangers').textContent = dangerCount;
            
            // Calculate score
            const score = Math.round((schoolCount * 10 + playgroundCount * 15 - dangerCount * 20) / 10);
            document.getElementById('stat-score').textContent = Math.max(0, score);
            
            // Update additional stats
            const kommuneEl = document.getElementById('stat-kommune');
            const begehungenEl = document.getElementById('stat-begehungen');
            const photosEl = document.getElementById('stat-photos');
            
            if (kommuneEl) kommuneEl.textContent = currentKommune || '--';
            if (begehungenEl) begehungenEl.textContent = begehungCount;
            if (photosEl) photosEl.textContent = photoCount;
        }
        
        // Voice note function with real audio recording
        function quickVoiceNote() {
            // Create recording modal
            const modal = document.createElement('div');
            modal.className = 'audio-recording-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 300px;
                text-align: center;
            `;
            
            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">🎤 Audio-Aufnahme</h3>
                <div id="recording-status" style="margin: 20px 0; font-size: 18px; color: #666;">
                    Bereit zum Aufnehmen
                </div>
                <div id="recording-timer" style="font-size: 24px; font-weight: bold; color: #FF3333; display: none;">
                    00:00
                </div>
                <audio id="audio-playback" controls style="display: none; width: 100%; margin: 20px 0;"></audio>
                <div style="margin-top: 20px;">
                    <button id="record-btn" style="padding: 10px 20px; margin: 5px; background: #FF3333; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                        🔴 Aufnahme starten
                    </button>
                    <button id="stop-btn" style="padding: 10px 20px; margin: 5px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">
                        ⏹️ Stoppen
                    </button>
                    <button id="save-btn" style="padding: 10px 20px; margin: 5px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">
                        💾 Speichern
                    </button>
                    <button id="retry-btn" style="padding: 10px 20px; margin: 5px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">
                        🔄 Neu aufnehmen
                    </button>
                    <button id="cancel-btn" style="padding: 10px 20px; margin: 5px; background: #999; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                        ❌ Abbrechen
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            let mediaRecorder;
            let audioChunks = [];
            let recordingStartTime;
            let timerInterval;
            let audioBlob;
            let audioUrl;
            
            const recordBtn = modal.querySelector('#record-btn');
            const stopBtn = modal.querySelector('#stop-btn');
            const saveBtn = modal.querySelector('#save-btn');
            const retryBtn = modal.querySelector('#retry-btn');
            const cancelBtn = modal.querySelector('#cancel-btn');
            const status = modal.querySelector('#recording-status');
            const timer = modal.querySelector('#recording-timer');
            const playback = modal.querySelector('#audio-playback');
            
            // Timer Update Function
            function updateTimer() {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                timer.textContent = `${minutes}:${seconds}`;
            }
            
            // Start Recording
            recordBtn.addEventListener('click', async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        audioUrl = URL.createObjectURL(audioBlob);
                        playback.src = audioUrl;
                        playback.style.display = 'block';
                        
                        // UI Update
                        status.textContent = 'Aufnahme abgeschlossen';
                        saveBtn.style.display = 'inline-block';
                        retryBtn.style.display = 'inline-block';
                        clearInterval(timerInterval);
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    recordingStartTime = Date.now();
                    
                    // UI Update
                    recordBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                    status.textContent = 'Aufnahme läuft...';
                    timer.style.display = 'block';
                    
                    // Start Timer
                    timerInterval = setInterval(updateTimer, 1000);
                    
                } catch (err) {
                    console.error('Mikrofon-Zugriff verweigert:', err);
                    showToast('Mikrofon-Zugriff verweigert', 'error');
                    document.body.removeChild(modal);
                }
            });
            
            // Stop Recording
            stopBtn.addEventListener('click', () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    stopBtn.style.display = 'none';
                    timer.style.display = 'none';
                }
            });
            
            // Retry Recording
            retryBtn.addEventListener('click', () => {
                // Reset UI
                playback.style.display = 'none';
                saveBtn.style.display = 'none';
                retryBtn.style.display = 'none';
                recordBtn.style.display = 'inline-block';
                status.textContent = 'Bereit zum Aufnehmen';
                timer.textContent = '00:00';
                
                // Clean up old recording
                if (audioUrl) {
                    URL.revokeObjectURL(audioUrl);
                }
            });
            
            // Save Recording
            saveBtn.addEventListener('click', () => {
                if (!audioBlob) return;
                
                // Convert to base64
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64Audio = reader.result;
                    const duration = timer.textContent;
                    const timestamp = Date.now();
                    
                    // Close modal first
                    document.body.removeChild(modal);
                    
                    // Function to create and save audio marker
                    const createAudioMarker = (lat, lng) => {
                        const marker = {
                            id: `voice_${timestamp}`,
                            lat: lat,
                            lng: lng,
                            type: 'voice',
                            audio: base64Audio,
                            duration: duration,
                            begehungId: begehungActive ? begehungStartTime : null,
                            begehungType: begehungActive ? begehungType : null,
                            timestamp: timestamp
                        };
                        
                        customMarkers.push(marker);
                        if (begehungActive) {
                            begehungMarkers.push(marker);
                        }
                        
                        // Add marker with audio popup
                        const mapMarker = new mapboxgl.Marker({
                            color: '#FF6B6B'
                        })
                        .setLngLat([lng, lat])
                        .setPopup(new mapboxgl.Popup().setHTML(`
                            <div style="padding: 10px;">
                                <h4 style="margin: 0 0 10px 0;">🎤 Audio-Aufnahme</h4>
                                <audio controls style="width: 200px;">
                                    <source src="${base64Audio}" type="audio/webm">
                                </audio>
                                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                    Dauer: ${duration}<br>
                                    ${new Date(timestamp).toLocaleString()}
                                </div>
                            </div>
                        `))
                        .addTo(map);
                        
                        saveCustomMarkers();
                        
                        // Auto-save session after adding audio marker
                        if (begehungActive) {
                            autoSaveBegehung();
                        }
                        
                        showToast('🎤 Audio-Aufnahme gespeichert', 'success');
                    };
                    
                    // Try to get GPS position
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                createAudioMarker(position.coords.latitude, position.coords.longitude);
                            },
                            (error) => {
                                // GPS failed, let user click on map
                                showToast('📍 Klicke auf die Karte für die Position', 'info');
                                map.getCanvas().style.cursor = 'crosshair';
                                
                                map.once('click', (e) => {
                                    createAudioMarker(e.lngLat.lat, e.lngLat.lng);
                                    map.getCanvas().style.cursor = '';
                                });
                            }
                        );
                    } else {
                        // No GPS available, let user click on map
                        showToast('📍 Klicke auf die Karte für die Position', 'info');
                        map.getCanvas().style.cursor = 'crosshair';
                        
                        map.once('click', (e) => {
                            createAudioMarker(e.lngLat.lat, e.lngLat.lng);
                            map.getCanvas().style.cursor = '';
                        });
                    }
                };
                
                reader.readAsDataURL(audioBlob);
            });
            
            // Cancel
            cancelBtn.addEventListener('click', () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                if (audioUrl) {
                    URL.revokeObjectURL(audioUrl);
                }
                document.body.removeChild(modal);
            });
        }
        
        
        function quickTextNote() {
            quickNote(); // Use the implemented function
        }
        
        function exportProject(projectId) {
            if (projectId) {
                // Old export for backward compatibility
                exportProjectAsJSON(projectId);
            } else {
                // New export dialog
                showExportDialog();
            }
        }
        
        // Export project as JSON (legacy)
        async function exportProjectAsJSON(projectId) {
            try {
                // Get project and all related data
                const projectData = await getFullProjectData(projectId);
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `projekt-${projectData.name.replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('📤 Projekt exportiert!', 'success');
            } catch (error) {
                showToast('❌ Export-Fehler', 'error');
            }
        }
        
        // Toggle between Standard and Kinderperspektive
        function toggleMapStyle() {
            const btn = document.getElementById('styleToggleBtn');
            const label = document.getElementById('styleLabel');
            const icon = btn.querySelector('.control-button-icon');
            
            if (currentMapStyle === 'Standard') {
                currentMapStyle = 'Kinderperspektive';
                label.textContent = 'Kinder';
                icon.textContent = '🎨';
                
                map.setStyle(mapStyles['Kinderperspektive']);
                map.once('style.load', () => {
                    map.setPitch(45);
                    map.setBearing(35);
                    applyKinderperspektiveEffects();
                    loadOSMDataToMap();
                    loadCustomMarkers();
                    displayBegehungTracks();
                });
            } else {
                currentMapStyle = 'Standard';
                label.textContent = 'Standard';
                icon.textContent = '🏞️';
                
                map.setStyle(mapStyles['Standard']);
                map.once('style.load', () => {
                    map.setPitch(0);
                    map.setBearing(0);
                    removeKinderperspektiveEffects();
                    loadOSMDataToMap();
                    loadCustomMarkers();
                    displayBegehungTracks();
                });
            }
            
            showToast(`Ansicht: ${currentMapStyle}`, 'info');
        }
        
        // Add event listeners for switch toggles
        document.addEventListener('DOMContentLoaded', () => {
            // Add click handlers for layer toggles in switch view
            document.querySelectorAll('.switch-toggle').forEach(toggle => {
                toggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const layer = this.dataset.layer;
                    toggleLayer(layer, this.classList.contains('active'));
                });
            });
        });
        
        function toggleLayer(layerName, visible) {
            if (!map) return;
            
            const visibility = visible ? 'visible' : 'none';
            
            // Handle different layer types
            if (layerName.startsWith('route-')) {
                // Handle begehung routes
                const type = layerName.replace('route-', '');
                const mapLayer = `begehung-${type}`;
                if (map.getLayer(mapLayer)) {
                    map.setLayoutProperty(mapLayer, 'visibility', visibility);
                }
            } else {
                // Handle regular layers
                [`${layerName}-fill`, `${layerName}-line`, `${layerName}-circles`, `${layerName}-streets`].forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', visibility);
                    }
                });
            }
        }
        
        // Show tab function for setup screen
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.project-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            const tab = document.getElementById(tabName + '-tab');
            if (tab) {
                tab.classList.add('active');
            }
            
            // Highlight button
            const btn = document.querySelector(`.tab-button[onclick*="${tabName}"]`);
            if (btn) {
                btn.classList.add('active');
            }
        }
        
        // Area management variables
        let previewMap = null;
        let currentAreaType = null;
        let drawingMode = false;
        let areaRectangle = null;
        let areaBounds = {
            stadt: null,
            ortsteile: [],
            begehung: null
        };
        
        // Initialize preview map
        function initPreviewMap() {
            if (window.previewMap) return;
            
            const mapContainer = document.getElementById('map-preview');
            if (!mapContainer) {
                console.log('Map preview container not found, will retry...');
                setTimeout(initPreviewMap, 500);
                return;
            }
            
            // Set Mapbox access token
            if (!mapboxgl.accessToken) {
                mapboxgl.accessToken = 'pk.eyJ1IjoidGlsbGl2YW5pbGxpNDQ0IiwiYSI6ImNtZHhsb3h4cDFqaTgyanF3YWQxa3Uybm0ifQ.oKAuIpFBkhS1ltzLvyN85w';
            }
            
            try {
                console.log('Creating Mapbox map with token:', mapboxgl.accessToken ? 'Token set' : 'No token');
                
                window.previewMap = previewMap = new mapboxgl.Map({
                    container: mapContainer,
                    style: 'mapbox://styles/mapbox/streets-v11',
                    center: [6.8, 51.4], // Default to NRW region
                    zoom: 8,
                    interactive: true
                });
                
                previewMap.on('load', () => {
                    console.log('✅ Preview map loaded successfully');
                    // Add drawing controls
                    previewMap.on('mousedown', startDrawing);
                    previewMap.on('mousemove', updateDrawing);
                    previewMap.on('mouseup', endDrawing);
                });
                
                previewMap.on('error', (e) => {
                    console.error('❌ Map error:', e);
                });
            } catch (error) {
                console.error('❌ Error initializing preview map:', error);
                console.error('Mapbox token:', mapboxgl.accessToken);
            }
        }
        
        // Watch for kommune input changes
        function setupKommuneWatcher() {
            const kommuneInput = document.getElementById('kommune-input');
            if (!kommuneInput) return;
            
            let debounceTimer;
            kommuneInput.addEventListener('input', (e) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    searchAndShowLocation(e.target.value);
                }, 500);
            });
            
            // Also trigger on Enter key
            kommuneInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    clearTimeout(debounceTimer);
                    searchAndShowLocation(e.target.value);
                }
            });
        }
        
        // Search for location and show on preview map
        window.searchAndShowLocation = async function(query) {
            if (!query || query.length < 3) return;
            
            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?` +
                    `access_token=${mapboxgl.accessToken}&country=DE&types=place,locality,district`
                );
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const location = data.features[0];
                    const [lng, lat] = location.center;
                    
                    if (previewMap) {
                        previewMap.flyTo({
                            center: [lng, lat],
                            zoom: 12,
                            duration: 1500
                        });
                        
                        // Update radius input to calculate appropriate bounds
                        updateRadiusFromBounds(location.bbox);
                    }
                }
            } catch (error) {
                console.error('Error searching location:', error);
            }
        }
        
        // Update radius based on location bounds
        function updateRadiusFromBounds(bbox) {
            if (!bbox || bbox.length !== 4) return;
            
            const [minLng, minLat, maxLng, maxLat] = bbox;
            const radiusKm = Math.max(
                haversineDistance(minLat, minLng, maxLat, minLng),
                haversineDistance(minLat, minLng, minLat, maxLng)
            ) / 2;
            
            const radiusInput = document.getElementById('radius-input');
            if (radiusInput) {
                radiusInput.value = Math.min(Math.max(radiusKm, 1), 10).toFixed(1);
            }
        }
        
        // Calculate distance between two points
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Update the global defineAreaBounds implementation
        window.defineAreaBounds = function(type) {
            if (!window.previewMap) {
                console.log('Map not initialized yet, initializing...');
                initPreviewMap();
                setTimeout(() => window.defineAreaBounds(type), 500);
                return;
            }
            
            currentAreaType = type;
            drawingMode = true;
            
            // Show selection controls
            const controls = document.querySelector('.area-selection-controls');
            if (controls) controls.style.display = 'block';
            
            // Change cursor
            if (previewMap) {
                previewMap.getCanvas().style.cursor = 'crosshair';
            }
            
            // Clear previous rectangle if exists
            if (areaRectangle && previewMap.getLayer('area-rectangle')) {
                previewMap.removeLayer('area-rectangle');
                previewMap.removeSource('area-rectangle');
                areaRectangle = null;
            }
        };
        
        // Manage Ortsteile
        window.manageOrtsteile = function() {
            // Create modal for managing districts
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            
            // Build ortsteile list HTML
            let ortsteileListHTML = '';
            if (areaBounds.ortsteile && areaBounds.ortsteile.length > 0) {
                areaBounds.ortsteile.forEach((ot, i) => {
                    ortsteileListHTML += '<div class="area-item">' + 
                        ot.name + 
                        '<button onclick="removeOrtsteil(' + i + ')" style="float: right; color: red;">❌</button>' +
                        '</div>';
                });
            } else {
                ortsteileListHTML = '<p style="color: var(--text-secondary);">Noch keine Ortsteile definiert</p>';
            }
            
            modal.innerHTML = '<div class="modal" style="max-width: 600px;">' +
                '<h2>🏘️ Ortsteile verwalten</h2>' +
                '<div style="margin: 20px 0;">' +
                    '<p style="color: var(--text-secondary); margin-bottom: 15px;">' +
                        'Definieren Sie die Ortsteile Ihrer Kommune' +
                    '</p>' +
                    '<div id="ortsteile-list" style="margin-bottom: 15px;">' +
                        ortsteileListHTML +
                    '</div>' +
                    '<div style="display: flex; gap: 10px;">' +
                        '<input type="text" id="new-ortsteil-name" placeholder="Name des Ortsteils" ' +
                            'style="flex: 1; padding: 10px; background: var(--tertiary); ' +
                            'border: 1px solid var(--border); border-radius: 8px; ' +
                            'color: var(--text-primary);">' +
                        '<button class="btn primary" onclick="addOrtsteil()">' +
                            '➕ Hinzufügen' +
                        '</button>' +
                    '</div>' +
                '</div>' +
                '<div style="text-align: center;">' +
                    '<button class="btn secondary" onclick="this.closest(\'.modal-overlay\').remove()">' +
                        'Schließen' +
                    '</button>' +
                '</div>' +
            '</div>';
            
            document.body.appendChild(modal);
        };
        
        // Add new Ortsteil
        window.addOrtsteil = function() {
            const nameInput = document.getElementById('new-ortsteil-name');
            if (!nameInput || !nameInput.value.trim()) return;
            
            const name = nameInput.value.trim();
            
            // Close modal
            document.querySelector('.modal-overlay').remove();
            
            // Start drawing mode for this Ortsteil
            currentAreaType = 'ortsteil';
            drawingMode = true;
            
            // Store name temporarily
            window.pendingOrtsteilName = name;
            
            // Show selection controls
            const controls = document.querySelector('.area-selection-controls');
            if (controls) {
                controls.style.display = 'block';
                controls.querySelector('div:first-child').textContent = `📍 Gebiet für "${name}" auswählen`;
            }
            
            if (previewMap) {
                previewMap.getCanvas().style.cursor = 'crosshair';
            }
        };
        
        // Remove Ortsteil
        window.removeOrtsteil = function(index) {
            areaBounds.ortsteile.splice(index, 1);
            updateAreaInfo();
            
            // Refresh modal
            const list = document.getElementById('ortsteile-list');
            if (list) {
                let html = '';
                if (areaBounds.ortsteile.length > 0) {
                    areaBounds.ortsteile.forEach((ot, i) => {
                        html += '<div class="area-item">' + 
                            ot.name + 
                            '<button onclick="removeOrtsteil(' + i + ')" style="float: right; color: red;">❌</button>' +
                            '</div>';
                    });
                } else {
                    html = '<p style="color: var(--text-secondary);">Noch keine Ortsteile definiert</p>';
                }
                list.innerHTML = html;
            }
        };
        
        // Drawing functions
        let startPoint = null;
        let currentRect = null;
        
        function startDrawing(e) {
            if (!drawingMode || !previewMap) return;
            
            startPoint = e.lngLat;
            currentRect = {
                type: 'Feature',
                geometry: {
                    type: 'Polygon',
                    coordinates: [[]]
                }
            };
        }
        
        function updateDrawing(e) {
            if (!drawingMode || !startPoint || !currentRect) return;
            
            const current = e.lngLat;
            const coords = [
                [startPoint.lng, startPoint.lat],
                [current.lng, startPoint.lat],
                [current.lng, current.lat],
                [startPoint.lng, current.lat],
                [startPoint.lng, startPoint.lat]
            ];
            
            currentRect.geometry.coordinates = [coords];
            
            // Update or add rectangle layer
            if (previewMap.getSource('temp-rectangle')) {
                previewMap.getSource('temp-rectangle').setData(currentRect);
            } else {
                previewMap.addSource('temp-rectangle', {
                    type: 'geojson',
                    data: currentRect
                });
                
                previewMap.addLayer({
                    id: 'temp-rectangle',
                    type: 'fill',
                    source: 'temp-rectangle',
                    paint: {
                        'fill-color': '#007AFF',
                        'fill-opacity': 0.3
                    }
                });
                
                previewMap.addLayer({
                    id: 'temp-rectangle-outline',
                    type: 'line',
                    source: 'temp-rectangle',
                    paint: {
                        'line-color': '#007AFF',
                        'line-width': 2
                    }
                });
            }
        }
        
        function endDrawing(e) {
            if (!drawingMode || !startPoint) return;
            
            const endPoint = e.lngLat;
            areaRectangle = [
                Math.min(startPoint.lng, endPoint.lng),
                Math.min(startPoint.lat, endPoint.lat),
                Math.max(startPoint.lng, endPoint.lng),
                Math.max(startPoint.lat, endPoint.lat)
            ];
            
            startPoint = null;
            currentRect = null;
        }
        
        // Confirm area selection
        window.confirmAreaSelection = function() {
            if (!areaRectangle) return;
            
            if (currentAreaType === 'stadt') {
                areaBounds.stadt = areaRectangle;
            } else if (currentAreaType === 'begehung') {
                areaBounds.begehung = areaRectangle;
            } else if (currentAreaType === 'ortsteil' && window.pendingOrtsteilName) {
                areaBounds.ortsteile.push({
                    name: window.pendingOrtsteilName,
                    bounds: areaRectangle
                });
                window.pendingOrtsteilName = null;
            }
            
            // Clean up
            cancelAreaSelection();
            updateAreaInfo();
            
            // Update radius based on stadt bounds
            if (currentAreaType === 'stadt' && areaBounds.stadt) {
                const [minLng, minLat, maxLng, maxLat] = areaBounds.stadt;
                const radiusKm = Math.max(
                    haversineDistance(minLat, minLng, maxLat, minLng),
                    haversineDistance(minLat, minLng, minLat, maxLng)
                ) / 2;
                
                const radiusInput = document.getElementById('radius-input');
                if (radiusInput) {
                    radiusInput.value = radiusKm.toFixed(1);
                }
            }
        };
        
        // Cancel area selection
        window.cancelAreaSelection = function() {
            drawingMode = false;
            currentAreaType = null;
            areaRectangle = null;
            
            // Hide controls
            const controls = document.querySelector('.area-selection-controls');
            if (controls) controls.style.display = 'none';
            
            // Reset cursor
            if (previewMap) {
                previewMap.getCanvas().style.cursor = '';
                
                // Remove temp rectangle
                if (previewMap.getLayer('temp-rectangle')) {
                    previewMap.removeLayer('temp-rectangle');
                    previewMap.removeLayer('temp-rectangle-outline');
                    previewMap.removeSource('temp-rectangle');
                }
            }
        };
        
        // Update area info display
        function updateAreaInfo() {
            const infoDiv = document.getElementById('area-info');
            if (!infoDiv) return;
            
            let html = '';
            
            if (areaBounds.stadt) {
                html += '<div class="area-item">✅ Stadtgebiet definiert</div>';
            }
            
            if (areaBounds.ortsteile && areaBounds.ortsteile.length > 0) {
                areaBounds.ortsteile.forEach(ot => {
                    html += '<div class="area-item">🏘️ ' + ot.name + '</div>';
                });
            }
            
            if (areaBounds.begehung) {
                html += '<div class="area-item">✅ Begehungsgebiet definiert</div>';
            }
            
            if (html) {
                infoDiv.innerHTML = html;
                infoDiv.style.display = 'block';
            } else {
                infoDiv.style.display = 'none';
            }
        }
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Loaded - Starting initialization...');
            setupApp();
            
            // Check for saved session
            const lastProject = localStorage.getItem('lastProject');
            if (lastProject && !window.DEV_CONFIG?.DEV_MODE) {
                try {
                    const project = JSON.parse(lastProject);
                    console.log('📂 Restoring last project:', project.name);
                    
                    // Set project data
                    currentProjectId = project.id;
                    currentProjectName = project.name;
                    currentKommune = project.kommune;
                    currentRadius = project.radius || 3;
                    if (project.areaBounds) {
                        areaBounds = project.areaBounds;
                    }
                    
                    // Skip setup and go directly to map
                    setTimeout(() => {
                        document.getElementById('setup-screen').style.display = 'none';
                        document.getElementById('app-container').style.display = 'block';
                        
                        geocodeKommune(project.kommune).then(location => {
                            if (location) {
                                initMap(location.lat, location.lng, project.kommune);
                                showToast(`📂 Projekt "${project.name}" wiederhergestellt!`, 'success');
                            }
                        });
                    }, 500);
                    return; // Skip rest of initialization
                } catch (error) {
                    console.error('Error restoring project:', error);
                    localStorage.removeItem('lastProject');
                }
            }
            
            // Initialize preview map with delay to ensure container exists
            setTimeout(() => {
                console.log('Initializing preview map...');
                initPreviewMap();
                setupKommuneWatcher();
            }, 100);
            
            // Hide old UI elements
            const oldElements = ['connection-status', 'gps-indicator', 'search-box'];
            oldElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            // Check for dev mode and skip setup if enabled
            if (window.DEV_CONFIG && window.DEV_CONFIG.DEV_MODE && window.DEV_CONFIG.SKIP_SETUP) {
                console.log('🚀 Dev Mode: Skipping setup screen...');
                
                // Auto-load project
                const config = window.DEV_CONFIG.AUTO_LOAD_PROJECT;
                if (config && config.enabled) {
                    currentKommune = config.kommune;
                    currentRadius = config.radius;
                    
                    // Hide setup screen
                    const setupScreen = document.getElementById('setup-screen');
                    if (setupScreen) setupScreen.style.display = 'none';
                    
                    // Show app container
                    const appContainer = document.getElementById('app-container');
                    if (appContainer) appContainer.style.display = 'block';
                    
                    // Initialize map with dev config
                    setTimeout(() => {
                        initMap(config.centerLat, config.centerLng, config.kommune);
                        
                        // searchAndLoadOSMData will be called automatically after map loads
                    }, 100);
                }
            } else {
                // Show default tab in setup screen
                showTab('new');
            }
        });
    </script>
</body>
</html>
